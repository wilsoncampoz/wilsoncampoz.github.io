/*!
 * tiny.js v0.2.3
 *
 * Copyright (c) 2015, MercadoLibre.com
 * Released under the MIT license.
 * https://raw.githubusercontent.com/mercadolibre/tiny.js/master/LICENSE
 */
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],3:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _interopDefault(ex) {
    return ex && (typeof ex === 'undefined' ? 'undefined' : _typeof(ex)) === 'object' && 'default' in ex ? ex['default'] : ex;
}

var inherits = _interopDefault(require('inherits'));
var EventEmitter = _interopDefault(require('events'));

function clone(obj) {
    if (obj === undefined || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
        throw new Error('The "obj" parameter is required and must be an object.');
    }

    var copy = {},
        prop = void 0;

    for (prop in obj) {
        if (obj[prop] !== undefined) {
            copy[prop] = obj[prop];
        }
    }

    return copy;
}

function isPlainObject(obj) {
    // Not plain objects:
    // - null
    // - undefined
    if (obj == null) {
        return false;
    }
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj.nodeType || obj === obj.window) {
        return false;
    }

    if (obj.constructor && !Object.prototype.hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) {
        return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
}

function extend() {
    var options = void 0,
        name = void 0,
        src = void 0,
        copy = void 0,
        copyIsArray = void 0,
        clone = void 0,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if (typeof target === 'boolean') {
        deep = target;

        // Skip the boolean and the target
        target = arguments[i] || {};
        i++;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object' && !(typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'function') {
        target = {};
    }

    // Nothing to extend, return original object
    if (length <= i) {
        return target;
    }

    for (; i < length; i++) {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null) {
            // Extend the base object
            for (name in options) {
                src = target[name];
                copy = options[name];

                // Prevent never-ending loop
                if (target === copy) {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {

                    if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && Array.isArray(src) ? src : [];
                    } else {
                        clone = src && isPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[name] = extend(deep, clone, copy);

                    // Don't bring in undefined values
                } else if (copy !== undefined) {
                        target[name] = copy;
                    }
            }
        }
    }

    // Return the modified object
    return target;
}

function ajax(url, settings) {
    var args = arguments;
    var opts = void 0;

    settings = args.length === 1 ? args[0] : args[1];

    var noop = function noop() {};

    var defaults = {
        url: args.length === 2 && typeof url === 'string' ? url : '.',
        cache: true,
        data: null,
        headers: {},
        context: null,
        dataType: 'text',
        method: 'GET',
        credentials: 'omit',
        success: noop,
        error: noop,
        complete: noop
    };

    opts = extend(defaults, settings || {});

    var mimeTypes = {
        'application/json': 'json',
        'text/html': 'html',
        'text/plain': 'text'
    };

    var dataTypes = {};
    for (var type in mimeTypes) {
        if (mimeTypes.hasOwnProperty(type)) {
            dataTypes[mimeTypes[type]] = type;
        }
    }

    if (!opts.cache) {
        opts.url = opts.url + (~opts.url.indexOf('?') ? '&' : '?') + 'nc=' + Math.floor(Math.random() * 9e9);
    }

    var complete = function complete(status, xhr) {
        opts.complete.call(opts.context, xhr, status);
    };

    var success = function success(data, xhr) {
        var status = 'success';
        opts.success.call(opts.context, data, status, xhr);
        complete(status, xhr);
    };

    var error = function error(_error, status, xhr) {
        opts.error.call(opts.context, xhr, status, _error);
        complete(status, xhr);
    };

    // toString shortcut for DRY
    var toString = Object.prototype.toString;

    var normalizeRequestData = function normalizeRequestData(data, headers, cors) {
        var charset = 'charset=UTF-8';
        var formUrlEncoded = 'application/x-www-form-urlencoded; ' + charset;

        if (typeof FormData !== 'undefined' && data instanceof FormData || /^\[object\s(ArrayBuffer|File|Blob)\]$/.test(toString.call(data))) {
            return data;
        }

        if (typeof URLSearchParams !== 'undefined' && data instanceof URLSearchParams || typeof data === 'string') {
            if (headers['Content-Type'] === undefined) {
                headers['Content-Type'] = formUrlEncoded;
            }

            return data.toString();
        }

        if (data !== null && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
            if (headers['Content-Type'] === undefined) {
                if (cors) {
                    // The content type of a CORS request is limited to
                    // application/x-www-form-urlencoded, multipart/form-data, or text/plain
                    headers['Content-Type'] = formUrlEncoded;
                } else {
                    headers['Content-Type'] = 'application/json;  ' + charset;
                }
            }

            return JSON.stringify(data);
        }

        return data;
    };

    // Normalize the method name
    opts.method = opts.method.toUpperCase();

    // Set the cross domain option
    // To avoid the preflight requests please use the "simple" requests only
    // @see https://www.w3.org/TR/cors/#resource-requests
    var testAnchor = document.createElement('a');
    var originAnchor = document.createElement('a');
    originAnchor.href = location.href;

    try {
        testAnchor.href = opts.url;

        // Support: IE lte 11
        // Anchor's host property isn't correctly set when opts.url is relative
        testAnchor.href = testAnchor.href;
        opts.crossDomain = originAnchor.protocol + '//' + originAnchor.host !== testAnchor.protocol + '//' + testAnchor.host;
    } catch (e) {
        opts.crossDomain = true;
    }

    var xhr = new XMLHttpRequest();

    var useXDR = opts.crossDomain && !('withCredentials' in xhr) && 'XDomainRequest' in window;

    if (useXDR) {
        // Use XDomainRequest instead of XMLHttpRequest for IE<=9 and when CORS is requested
        xhr = new XDomainRequest();
        xhr.onload = function () {
            var mime = xhr.contentType;
            var dataType = mime && mimeTypes[mime[1]] ? mimeTypes[mime[1]].toLowerCase() : 'json';
            var result = void 0;

            if (dataType === 'json') {
                try {
                    result = JSON.parse(xhr.responseText);
                } catch (e) {
                    result = xhr.responseText;
                }
            } else {
                result = xhr.responseText;
            }
            success(result, xhr);
        };
    } else {
        // Still cannot use xhr.onload for normal xhr due to required support of IE8 which
        // has no `onload` event https://msdn.microsoft.com/en-us/library/ms535874(v=vs.85).aspx#events
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                var result = void 0;
                var status = xhr.status === 1223 ? 204 : xhr.status;

                if (status >= 200 && status < 300 || status === 304) {
                    var mime = /([\/a-z]+)(;|\s|$)/.exec(xhr.getResponseHeader('content-type'));
                    var dataType = mime && mimeTypes[mime[1]] ? mimeTypes[mime[1]].toLowerCase() : 'text';
                    result = xhr.responseText;

                    if (dataType === 'json') {
                        try {
                            result = JSON.parse(result);
                        } catch (e) {
                            result = xhr.responseText;
                        }
                    }

                    success(result, xhr);
                } else {
                    error(new Error(xhr.statusText), 'error', xhr, opts);
                }

                return;
            }
        };
    }

    xhr.onerror = function () {
        error(new Error(xhr.statusText || 'Network request failed'), 'error', xhr, opts);
    };

    if ((opts.method === 'GET' || opts.method === 'HEAD') && typeof opts.data === 'string') {
        opts.url += (~opts.url.indexOf('?') ? '&' : '?') + opts.data;
    }

    xhr.open(opts.method, opts.url);

    if (opts.dataType && dataTypes[opts.dataType.toLowerCase()]) {
        opts.headers.Accept = dataTypes[opts.dataType.toLowerCase()] + ', */*; q=0.01';
    }

    // Set the "X-Requested-With" header only if it is not already set
    if (!opts.crossDomain && !opts.headers['X-Requested-With']) {
        opts.headers['X-Requested-With'] = 'XMLHttpRequest';
    }

    if (opts.credentials === 'include') {
        xhr.withCredentials = true;
    }

    opts.data = normalizeRequestData(opts.data, opts.headers, opts.crossDomain);

    if (!useXDR) {
        for (var key in opts.headers) {
            xhr.setRequestHeader(key, opts.headers[key]);
        }
    }

    xhr.send(opts.data);

    return this;
}

var noop = function noop() {};

// document.head is not available in IE<9
var head = document.getElementsByTagName('head')[0];

var jsonpCount = 0;

/**
 * JSONP handler
 *
 * @memberof tiny
 * @method
 * @param {String} url
 * @param {Object} [opts] Optional opts.
 * @param {String} [opts.prefix] Callback prefix. Default: `__jsonp`
 * @param {String} [opts.param] QS parameter. Default: `callback`
 * @param {String|Function} [opts.name] The name of the callback function that
 *   receives the result. Default: `opts.prefix${increment}`
 * @param {Number} [opts.timeout] How long after the request until a timeout
 *   error will occur. Default: 15000
 *
 * @returns {Function} Returns a cancel function
 *
 * @example
 * var cancel = tiny.jsonp('http://suggestgz.mlapps.com/sites/MLA/autosuggest?q=smartphone&v=1', {timeout: 5000});
 * if (something) {
 *   cancel();
 * }
 */
function jsonp(url, settings) {
    var id = void 0,
        script = void 0,
        timer = void 0,
        cleanup = void 0,
        cancel = void 0;

    var opts = extend({
        prefix: '__jsonp',
        param: 'callback',
        timeout: 15000,
        success: noop,
        error: noop
    }, settings);

    // Generate an unique id for the request.
    jsonpCount++;
    id = opts.name ? typeof opts.name === 'function' ? opts.name(opts.prefix, jsonpCount) : opts.name : opts.prefix + jsonpCount++;

    cleanup = function cleanup() {
        // Remove the script tag.
        if (script && script.parentNode) {
            script.parentNode.removeChild(script);
        }

        // Don't delete the jsonp handler from window to not generate an error
        // when script will be loaded after cleaning
        window[id] = noop;

        if (timer) {
            clearTimeout(timer);
        }
    };

    if (opts.timeout) {
        timer = setTimeout(function () {
            cleanup();
            opts.error(new Error('Script loading timeout'));
        }, opts.timeout);
    }

    window[id] = function (data) {
        cleanup();
        opts.success(data);
    };

    // Add querystring component
    url += (~url.indexOf('?') ? '&' : '?') + opts.param + '=' + encodeURIComponent(id);
    url = url.replace('?&', '?');

    // Create script element
    script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;
    script.onerror = function (e) {
        cleanup();
        opts.error(new Error(e.message || 'Script Error'));
    };
    head.appendChild(script);

    cancel = function cancel() {
        if (window[id]) {
            cleanup();
        }
    };

    return cancel;
}

// Based on the https://github.com/pablomoretti/jcors-loader written by Pablo Moretti

/* private */

var document$1 = window.document;
var node_createElementScript = document$1.createElement('script');
var node_elementScript = document$1.getElementsByTagName('script')[0];
var buffer = [];
var lastBufferIndex = 0;
var createCORSRequest = function () {
    var xhr = void 0,
        CORSRequest = void 0;
    if (window.XMLHttpRequest) {
        xhr = new window.XMLHttpRequest();
        if ('withCredentials' in xhr) {
            CORSRequest = function CORSRequest(url) {
                xhr = new window.XMLHttpRequest();
                xhr.open('get', url, true);
                return xhr;
            };
        } else if (window.XDomainRequest) {
            CORSRequest = function CORSRequest(url) {
                xhr = new window.XDomainRequest();
                xhr.open('get', url);
                return xhr;
            };
        }
    }

    return CORSRequest;
}();
function execute(script) {
    if (typeof script === 'string') {
        var g = node_createElementScript.cloneNode(false);
        g.text = script;
        node_elementScript.parentNode.insertBefore(g, node_elementScript);
    } else {
        script.apply(window);
    }
}

function saveInBuffer(index, script) {
    buffer[index] = script;
}

function finishedTask(index) {
    saveInBuffer(index, null);
    lastBufferIndex = index + 1;
}

function executeBuffer() {
    var dep = true,
        script = void 0,
        index = lastBufferIndex,
        len = buffer.length;

    while (index < len && dep) {
        script = buffer[index];
        if (script !== undefined && script !== null) {
            execute(script);
            finishedTask(index);
            index += 1;
        } else {
            dep = false;
        }
    }
}

function loadsAndExecuteScriptsOnChain() {
    if (buffer.length) {
        (function () {
            var scr = buffer.pop(),
                script = void 0;
            if (typeof scr === 'string') {
                script = node_createElementScript.cloneNode(true);
                script.type = 'text/javascript';
                script.async = true;
                script.src = scr;
                script.onload = script.onreadystatechange = function () {
                    if (!script.readyState || /loaded|complete/.test(script.readyState)) {
                        // Handle memory leak in IE
                        script.onload = script.onreadystatechange = null;
                        // Dereference the script
                        script = undefined;
                        // Load
                        loadsAndExecuteScriptsOnChain();
                    }
                };
                node_elementScript.parentNode.insertBefore(script, node_elementScript);
            } else {
                scr.apply(window);
                loadsAndExecuteScriptsOnChain();
            }
        })();
    }
}

function onloadCORSHandler(request, index) {
    return function () {
        saveInBuffer(index, request.responseText);
        executeBuffer();
        // Dereference the script
        request = undefined;
    };
}

function loadWithCORS() {
    var len = arguments.length,
        index,
        request;
    for (index = 0; index < len; index += 1) {
        if (typeof arguments[index] === 'string') {
            request = createCORSRequest(arguments[index]);
            request.onload = onloadCORSHandler(request, buffer.length);
            saveInBuffer(buffer.length, null);
            request.send();
        } else {
            saveInBuffer(buffer.length, arguments[index]);
            executeBuffer();
        }
    }
}

function loadWithoutCORS() {
    buffer.push(Array.prototype.slice.call(arguments, 0).reverse());
    loadsAndExecuteScriptsOnChain();
}

var jcors = createCORSRequest ? loadWithCORS : loadWithoutCORS;

var support = {
    /**
     * Verify that CSS Transitions are supported (or any of its browser-specific implementations).
     *
     * @static
     * @type {Boolean|Object}
     * @example
     * if (tiny.support.transition) {
         *     // Some code here!
         * }
     */
    transition: transitionEnd(),

    /**
     * Verify that CSS Animations are supported (or any of its browser-specific implementations).
     *
     * @static
     * @type {Boolean|Object}
     * @example
     * if (tiny.support.animation) {
         *     // Some code here!
         * }
     */
    animation: animationEnd(),

    /**
     * Checks is the User Agent supports touch events.
     * @type {Boolean}
     * @example
     * if (tiny.support.touch) {
         *     // Some code here!
         * }
     */
    touch: 'ontouchend' in document,

    /**
     * Checks is the User Agent supports custom events.
     * @type {Boolean}
     * @example
     * if (tiny.support.customEvent) {
         *     // Some code here!
         * }
     */
    customEvent: function () {
        // TODO: find better solution for CustomEvent check
        try {
            // IE8 has no support for CustomEvent, in IE gte 9 it cannot be
            // instantiated but exist
            new CustomEvent(name, {
                detail: {}
            });
            return true;
        } catch (e) {
            return false;
        }
    }()
};

/**
 * Checks for the CSS Transitions support (http://www.modernizr.com/)
 *
 * @function
 * @private
 */
function transitionEnd() {
    var el = document.createElement('tiny');

    var transEndEventNames = {
        WebkitTransition: 'webkitTransitionEnd',
        MozTransition: 'transitionend',
        OTransition: 'oTransitionEnd otransitionend',
        transition: 'transitionend'
    };

    for (var _name in transEndEventNames) {
        if (transEndEventNames.hasOwnProperty(_name) && el.style[_name] !== undefined) {
            return {
                end: transEndEventNames[_name]
            };
        }
    }

    return false;
}

/**
 * Checks for the CSS Animations support
 *
 * @function
 * @private
 */
function animationEnd() {
    var el = document.createElement('tiny');

    var animEndEventNames = {
        WebkitAnimation: 'webkitAnimationEnd',
        MozAnimation: 'animationend',
        OAnimation: 'oAnimationEnd oanimationend',
        animation: 'animationend'
    };

    for (var _name2 in animEndEventNames) {
        if (animEndEventNames.hasOwnProperty(_name2) && el.style[_name2] !== undefined) {
            return {
                end: animEndEventNames[_name2]
            };
        }
    }

    return false;
}

var testEl = document.createElement('div');
var isClassList = !!testEl.classList;

/**
 * Adds the specified class to an element
 *
 * @param el {HTMLElement}
 * @param className {String}
 *
 * @example
 * tiny.addClass(document.body, 'tiny-example');
 */
function addClass(el, className) {
    if (isClassList) {
        el.classList.add(className);
    } else {
        el.setAttribute('class', el.getAttribute('class') + ' ' + className);
    }
}

/**
 * Remove a single class from an element
 *
 * @param el {HTMLElement}
 * @param className {String}
 *
 * @example
 * tiny.removeClass(document.body, 'tiny-example');
 */
function removeClass(el, className) {
    if (isClassList) {
        el.classList.remove(className);
    } else {
        el.setAttribute('class', el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' '));
    }
}

/**
 * Determine whether is the given class is assigned to an element
 * @param el {HTMLElement}
 * @param className {String}
 * @returns {Boolean}
 *
 * @example
 * tiny.hasClass(document.body, 'tiny-example');
 */
function hasClass(el, className) {
    var exist;
    if (isClassList) {
        exist = el.classList.contains(className);
    } else {
        exist = new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);
    }
    return exist;
}

var classList = {
    addClass: addClass,
    removeClass: removeClass,
    hasClass: hasClass
};

/**
 * Get the parent of an element, optionally filtered by a tag
 *
 * @param {HTMLElement} el
 * @param {String} tagname
 * @returns {HTMLElement}
 *
 * @example
 * tiny.parent(el, 'div');
 */
function parent(el, tagname) {
    var parentNode = el.parentNode;
    var tag = tagname ? tagname.toUpperCase() : tagname;

    if (parentNode === null) {
        return parentNode;
    }

    if (parentNode.nodeType !== 1) {
        return parent(parentNode, tag);
    }

    if (tagname !== undefined && parentNode.tagName === tag) {
        return parentNode;
    } else if (tagname !== undefined && parentNode.tagName !== tag) {
        return parent(parentNode, tag);
    } else if (tagname === undefined) {
        return parentNode;
    }
}

/**
 * IE8 safe method to get the next element sibling
 *
 * @memberof tiny
 * @param {HTMLElement} el A given HTMLElement.
 * @returns {HTMLElement}
 *
 * @example
 * tiny.next(el);
 */
function next(element) {
    function next(el) {
        do {
            el = el.nextSibling;
        } while (el && el.nodeType !== 1);

        return el;
    }

    return element.nextElementSibling || next(element);
}

/**
 * Get the value of a computed style for the first element in set of
 * matched elements or set one or more CSS properties for every matched element.
 *
 * @memberof tiny
 * @param {String|HTMLElement} elem CSS selector or an HTML Element
 * @param {String|Object} key A CSS property or a map of <property, value> when used as setter.
 * @param {Sreing} value A value to set for the property
 *
 * @returns {String|Void}
 */
function css(elem, key, value) {
    var args = arguments,
        elements = getElements(elem),
        length = elements.length,
        setter;

    // Get attribute
    if (typeof key === 'string' && args.length === 2) {
        return length === 0 ? '' : getElStyle(elements[0], key);
    }

    // Set attributes
    if (args.length === 3) {
        setter = function setter(el) {
            el.style[key] = value;
        };
    } else if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
        setter = function setter(el) {
            Object.keys(key).forEach(function (name) {
                el.style[name] = key[name];
            });
        };
    }

    for (var i = 0; i < length; i++) {
        setter(elements[i]);
    }
}

function getElStyle(el, prop) {
    if (window.getComputedStyle) {
        return window.getComputedStyle(el, null).getPropertyValue(prop);
        // IE
    } else {
            // Turn style name into camel notation
            prop = prop.replace(/\-(\w)/g, function (str, $1) {
                return $1.toUpperCase();
            });
            return el.currentStyle[prop];
        }
}

function getElements(el) {
    if (!el) {
        return [];
    }

    if (typeof el === 'string') {
        return nodeListToArray(document.querySelectorAll(el));
    } else if (/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(el)) && (typeof el.length === 'number' || Object.prototype.hasOwnProperty.call(el, 'length')) && el.length > 0 && el[0].nodeType > 0) {

        return nodeListToArray(el);
    } else {
        return [el];
    }
}

function nodeListToArray(elements) {
    var i = 0,
        length = elements.length,
        arr = [];

    for (; i < length; i++) {
        arr.push(elements[i]);
    }

    return arr;
}

/**
 * Get the current vertical and horizontal positions of the scroll bars.
 *
 * @memberof tiny
 * @returns {{left: (Number), top: (Number)}}
 *
 * @example
 * tiny.scroll().top;
 */
function scroll() {
    return {
        'left': window.pageXOffset || document.documentElement.scrollLeft || 0,
        'top': window.pageYOffset || document.documentElement.scrollTop || 0
    };
}

/**
 * Get the current offset of an element.
 *
 * @param {HTMLElement} el A given HTMLElement.
 * @returns {{left: Number, top: Number}}
 *
 * @example
 * tiny.offset(el);
 */
function offset(el) {
    var rect = el.getBoundingClientRect(),
        fixedParent = getFixedParent(el),
        currentScroll = scroll(),
        offset = {
        'left': rect.left,
        'top': rect.top
    };

    if (css(el, 'position') !== 'fixed' && fixedParent === null) {
        offset.left += currentScroll.left;
        offset.top += currentScroll.top;
    }

    return offset;
}

/**
 * Get the current parentNode with the 'fixed' position.
 *
 * @private
 * @param {HTMLElement} el A given HTMLElement.
 *
 * @returns {HTMLElement}
 */
function getFixedParent(el) {
    var currentParent = el.offsetParent,
        parent = void 0;

    while (parent === undefined) {

        if (currentParent === null) {
            parent = null;
            break;
        }

        if (css(currentParent, 'position') !== 'fixed') {
            currentParent = currentParent.offsetParent;
        } else {
            parent = currentParent;
        }
    }

    return parent;
}

var defaults = {
    expires: '', // Empty string for session cookies
    path: '/',
    secure: false,
    domain: ''
};

var day = 60 * 60 * 24;

function get(key) {
    var collection = document.cookie.split('; '),
        value = null,
        l = collection.length;

    if (!l) {
        return value;
    }

    for (var i = 0; i < l; i++) {
        var parts = collection[i].split('='),
            _name3 = decodeURIComponent(parts.shift());

        if (key === _name3) {
            value = decodeURIComponent(parts.join('='));
            break;
        }
    }

    return value;
}

// Then `key` contains an object with keys and values for cookies, `value` contains the options object.
function set(key, value, options) {
    options = (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' ? options : { expires: options };

    var expires = options.expires != null ? options.expires : defaults.expires;

    if (typeof expires === 'string' && expires !== '') {
        expires = new Date(expires);
    } else if (typeof expires === 'number') {
        expires = new Date(+new Date() + 1000 * day * expires);
    }

    if (expires && 'toGMTString' in expires) {
        expires = ';expires=' + expires.toGMTString();
    }

    var path = ';path=' + (options.path || defaults.path);

    var domain = options.domain || defaults.domain;
    domain = domain ? ';domain=' + domain : '';

    var secure = options.secure || defaults.secure ? ';secure' : '';

    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
        if (Array.isArray(value) || isPlainObject(value)) {
            value = JSON.stringify(value);
        } else {
            value = '';
        }
    }

    document.cookie = encodeCookie(key) + '=' + encodeCookie(value) + expires + path + domain + secure;
}

function remove(key) {
    set(key, '', -1);
}

function isEnabled() {
    if (navigator.cookieEnabled) {
        return true;
    }

    set('__', '_');
    var exist = get('__') === '_';
    remove('__');

    return exist;
}

var cookies = {
    get: get,
    set: set,
    remove: remove,
    isEnabled: isEnabled
};

/*
 * Escapes only characters that are not allowed in cookies
 */
function encodeCookie(value) {
    return String(value).replace(/[,;"\\=\s%]/g, function (character) {
        return encodeURIComponent(character);
    });
}

var DOM_EVENTS = function () {
    var events = [];
    for (var attr in document) {
        if (attr.substring(0, 2) === 'on') {
            var evt = attr.replace('on', '');
            events.push(evt);
        }
    }
    return events;
}();

var MOUSE_EVENTS = DOM_EVENTS.filter(function (name) {
    return (/^(?:click|dblclick|mouse(?:down|up|over|move|out))$/.test(name)
    );
});

var isStandard = document.addEventListener ? true : false;

var addHandler = isStandard ? 'addEventListener' : 'attachEvent';

var removeHandler = isStandard ? 'removeEventListener' : 'detachEvent';

var dispatch = isStandard ? 'dispatchEvent' : 'fireEvent';

if (!Event.prototype.preventDefault && Object.defineProperties) {
    Object.defineProperties(window.Event.prototype, {
        bubbles: {
            value: true,
            writable: true
        },
        cancelable: {
            value: true,
            writable: true
        },
        preventDefault: {
            value: function value() {
                if (this.cancelable) {
                    this.defaultPrevented = true;
                    this.returnValue = false;
                }
            }
        },
        stopPropagation: {
            value: function value() {
                this.stoppedPropagation = true;
                this.cancelBubble = true;
            }
        },
        stopImmediatePropagation: {
            value: function value() {
                this.stoppedImmediatePropagation = true;
                this.stopPropagation();
            }
        }
    });
}

function getElements$1(el) {
    if (!el) {
        return [];
    }

    if (typeof el === 'string') {
        return nodeListToArray$1(document.querySelectorAll(el));
    } else if (/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(el)) && (typeof el.length === 'number' || Object.prototype.hasOwnProperty.call(el, 'length'))) {
        if (el.length === 0 || el[0].nodeType < 1) {
            return [];
        }

        return nodeListToArray$1(el);
    } else if (Array.isArray(el)) {
        return [].concat(el);
    } else {
        return [el];
    }
}

function nodeListToArray$1(elements) {
    var i = 0,
        length = elements.length,
        arr = [];

    for (; i < length; i++) {
        arr.push(elements[i]);
    }

    return arr;
}

function initEvent(name, props) {
    if (typeof name !== 'string') {
        props = name;
        name = props.type;
    }
    var event = void 0,
        isDomEvent = DOM_EVENTS.indexOf(name) !== -1,
        isMouseEvent = isDomEvent && MOUSE_EVENTS.indexOf(name) !== -1;

    var data = extend({
        bubbles: isDomEvent,
        cancelable: isDomEvent,
        detail: undefined
    }, props);

    if (document.createEvent) {
        event = document.createEvent(isMouseEvent && window.MouseEvent ? 'MouseEvents' : 'Events');
        event.initEvent(name, data.bubbles, data.cancelable, data.detail);
    } else if (document.createEventObject) {
        event = document.createEventObject(window.event);
        if (isMouseEvent) {
            event.button = 1;
        }
        if (!data.bubbles) {
            event.cancelBubble = true;
        }
    }

    return event;
}

function normalizeEventName(event) {
    if (event.substr(0, 2) === 'on') {
        return isStandard ? event.substr(2) : event;
    } else {
        return isStandard ? event : 'on' + event;
    }
}

/**
 * Crossbrowser implementation of {HTMLElement}.addEventListener.
 *
 * @memberof tiny
 * @type {Function}
 * @param {HTMLElement|String} elem An HTMLElement or a CSS selector to add listener to
 * @param {String} event Event name
 * @param {Function} handler Event handler function
 * @param {Boolean} bubbles Whether or not to be propagated to outer elements.
 *
 * @example
 * tiny.on(document, 'click', function(e){}, false);
 *
 * tiny.on('p > button', 'click', function(e){}, false);
 */
function on(elem, event, handler, bubbles) {
    getElements$1(elem).forEach(function (el) {
        el[addHandler](normalizeEventName(event), handler, bubbles || false);
    });
}

/**
 * Attach a handler to an event for the {HTMLElement} that executes only
 * once.
 *
 * @memberof ch.Event
 * @type {Function}
 * @param {HTMLElement|String} elem An HTMLElement or a CSS selector to add listener to
 * @param {String} event Event name
 * @param {Function} handler Event handler function
 * @param {Boolean} bubbles Whether or not to be propagated to outer elements.
 *
 * @example
 * tiny.once(document, 'click', function(e){}, false);
 */
function once(elem, event, _handler, bubbles) {
    getElements$1(elem).forEach(function (el) {
        var origHandler = _handler;

        _handler = function handler(e) {
            off(el, e.type, _handler);

            return origHandler.apply(el, arguments);
        };

        el[addHandler](normalizeEventName(event), _handler, bubbles || false);
    });
}

/**
 * Crossbrowser implementation of {HTMLElement}.removeEventListener.
 *
 * @memberof ch.Event
 * @type {Function}
 * @param {HTMLElement|String} elem An HTMLElement or a CSS selector to remove listener from
 * @param {String} event Event name
 * @param {Function} handler Event handler function to remove
 *
 * @example
 * tiny.off(document, 'click', fn);
 */
function off(elem, event, handler) {
    getElements$1(elem).forEach(function (el) {
        el[removeHandler](normalizeEventName(event), handler);
    });
}

/**
 * Crossbrowser implementation of {HTMLElement}.removeEventListener.
 *
 * @memberof tiny
 * @type {Function}
 * @param {HTMLElement} elem An HTMLElement or a CSS selector to dispatch event to
 * @param {String|Event} event Event name or an event object
 *
 * @example
 * tiny.trigger('.btn', 'click');
 */
function trigger(elem, event, props) {
    var _this = this;

    var name = typeof event === 'string' ? event : event.type;
    event = typeof event === 'string' || isPlainObject(event) ? initEvent(event, props) : event;

    getElements$1(elem).forEach(function (el) {
        // handle focus(), blur() by calling them directly
        if (event.type in focus && typeof _this[event.type] == 'function') {
            _this[event.type]();
        } else {
            isStandard ? el[dispatch](event) : el[dispatch](normalizeEventName(name), event);
        }
    });
}

var DOMEvents = {
    on: on,
    once: once,
    off: off,
    trigger: trigger
};

/**
 * Polyfill for supporting pointer events on every browser
 *
 * @see Based on: <a href="https://github.com/deltakosh/handjs" target="_blank">Hand.js</a>
 */
(function (window) {
    'use strict';

    var POINTER_TYPE_TOUCH = 'touch';
    var POINTER_TYPE_PEN = 'pen';
    var POINTER_TYPE_MOUSE = 'mouse';

    // If the user agent already supports Pointer Events, do nothing
    if (window.PointerEvent) {
        return;
    }

    // Due to polyfill IE8 can has document.createEvent but it has no support for
    // custom Mouse Events
    var supportsMouseEvents = !!window.MouseEvent;

    if (!supportsMouseEvents) {
        return;
    }

    // The list of standardized pointer events http://www.w3.org/TR/pointerevents/
    var upperCaseEventsNames = ['PointerDown', 'PointerUp', 'PointerMove', 'PointerOver', 'PointerOut', 'PointerCancel', 'PointerEnter', 'PointerLeave'];
    var supportedEventsNames = upperCaseEventsNames.map(function (name) {
        return name.toLowerCase();
    });

    var previousTargets = {};

    var checkPreventDefault = function checkPreventDefault(node) {
        while (node && !node.ch_forcePreventDefault) {
            node = node.parentNode;
        }
        return !!node || window.ch_forcePreventDefault;
    };

    // Touch events
    var generateTouchClonedEvent = function generateTouchClonedEvent(sourceEvent, newName, canBubble, target, relatedTarget) {
        // Considering touch events are almost like super mouse events
        var evObj;

        if (document.createEvent && supportsMouseEvents) {
            evObj = document.createEvent('MouseEvents');
            // TODO: Replace 'initMouseEvent' with 'new MouseEvent'
            evObj.initMouseEvent(newName, canBubble, true, window, 1, sourceEvent.screenX, sourceEvent.screenY, sourceEvent.clientX, sourceEvent.clientY, sourceEvent.ctrlKey, sourceEvent.altKey, sourceEvent.shiftKey, sourceEvent.metaKey, sourceEvent.button, relatedTarget || sourceEvent.relatedTarget);
        } else {
            evObj = document.createEventObject();
            evObj.screenX = sourceEvent.screenX;
            evObj.screenY = sourceEvent.screenY;
            evObj.clientX = sourceEvent.clientX;
            evObj.clientY = sourceEvent.clientY;
            evObj.ctrlKey = sourceEvent.ctrlKey;
            evObj.altKey = sourceEvent.altKey;
            evObj.shiftKey = sourceEvent.shiftKey;
            evObj.metaKey = sourceEvent.metaKey;
            evObj.button = sourceEvent.button;
            evObj.relatedTarget = relatedTarget || sourceEvent.relatedTarget;
        }
        // offsets
        if (evObj.offsetX === undefined) {
            if (sourceEvent.offsetX !== undefined) {

                // For Opera which creates readonly properties
                if (Object && Object.defineProperty !== undefined) {
                    Object.defineProperty(evObj, 'offsetX', {
                        writable: true
                    });
                    Object.defineProperty(evObj, 'offsetY', {
                        writable: true
                    });
                }

                evObj.offsetX = sourceEvent.offsetX;
                evObj.offsetY = sourceEvent.offsetY;
            } else if (Object && Object.defineProperty !== undefined) {
                Object.defineProperty(evObj, 'offsetX', {
                    get: function get() {
                        if (this.currentTarget && this.currentTarget.offsetLeft) {
                            return sourceEvent.clientX - this.currentTarget.offsetLeft;
                        }
                        return sourceEvent.clientX;
                    }
                });
                Object.defineProperty(evObj, 'offsetY', {
                    get: function get() {
                        if (this.currentTarget && this.currentTarget.offsetTop) {
                            return sourceEvent.clientY - this.currentTarget.offsetTop;
                        }
                        return sourceEvent.clientY;
                    }
                });
            } else if (sourceEvent.layerX !== undefined) {
                evObj.offsetX = sourceEvent.layerX - sourceEvent.currentTarget.offsetLeft;
                evObj.offsetY = sourceEvent.layerY - sourceEvent.currentTarget.offsetTop;
            }
        }

        // adding missing properties

        if (sourceEvent.isPrimary !== undefined) evObj.isPrimary = sourceEvent.isPrimary;else evObj.isPrimary = true;

        if (sourceEvent.pressure) evObj.pressure = sourceEvent.pressure;else {
            var button = 0;

            if (sourceEvent.which !== undefined) button = sourceEvent.which;else if (sourceEvent.button !== undefined) {
                button = sourceEvent.button;
            }
            evObj.pressure = button === 0 ? 0 : 0.5;
        }

        if (sourceEvent.rotation) evObj.rotation = sourceEvent.rotation;else evObj.rotation = 0;

        // Timestamp
        if (sourceEvent.hwTimestamp) evObj.hwTimestamp = sourceEvent.hwTimestamp;else evObj.hwTimestamp = 0;

        // Tilts
        if (sourceEvent.tiltX) evObj.tiltX = sourceEvent.tiltX;else evObj.tiltX = 0;

        if (sourceEvent.tiltY) evObj.tiltY = sourceEvent.tiltY;else evObj.tiltY = 0;

        // Width and Height
        if (sourceEvent.height) evObj.height = sourceEvent.height;else evObj.height = 0;

        if (sourceEvent.width) evObj.width = sourceEvent.width;else evObj.width = 0;

        // preventDefault
        evObj.preventDefault = function () {
            if (sourceEvent.preventDefault !== undefined) sourceEvent.preventDefault();
        };

        // stopPropagation
        if (evObj.stopPropagation !== undefined) {
            var current = evObj.stopPropagation;
            evObj.stopPropagation = function () {
                if (sourceEvent.stopPropagation !== undefined) sourceEvent.stopPropagation();
                current.call(this);
            };
        }

        // Pointer values
        evObj.pointerId = sourceEvent.pointerId;
        evObj.pointerType = sourceEvent.pointerType;

        switch (evObj.pointerType) {// Old spec version check
            case 2:
                evObj.pointerType = POINTER_TYPE_TOUCH;
                break;
            case 3:
                evObj.pointerType = POINTER_TYPE_PEN;
                break;
            case 4:
                evObj.pointerType = POINTER_TYPE_MOUSE;
                break;
        }

        // Fire event
        if (target) target.dispatchEvent(evObj);else if (sourceEvent.target && supportsMouseEvents) {
            sourceEvent.target.dispatchEvent(evObj);
        } else {
            sourceEvent.srcElement.fireEvent('on' + getMouseEquivalentEventName(newName), evObj); // We must fallback to mouse event for very old browsers
        }
    };

    var generateMouseProxy = function generateMouseProxy(evt, eventName, canBubble, target, relatedTarget) {
        evt.pointerId = 1;
        evt.pointerType = POINTER_TYPE_MOUSE;
        generateTouchClonedEvent(evt, eventName, canBubble, target, relatedTarget);
    };

    var generateTouchEventProxy = function generateTouchEventProxy(name, touchPoint, target, eventObject, canBubble, relatedTarget) {
        var touchPointId = touchPoint.identifier + 2; // Just to not override mouse id

        touchPoint.pointerId = touchPointId;
        touchPoint.pointerType = POINTER_TYPE_TOUCH;
        touchPoint.currentTarget = target;

        if (eventObject.preventDefault !== undefined) {
            touchPoint.preventDefault = function () {
                eventObject.preventDefault();
            };
        }

        generateTouchClonedEvent(touchPoint, name, canBubble, target, relatedTarget);
    };

    var checkEventRegistration = function checkEventRegistration(node, eventName) {
        return node.__chGlobalRegisteredEvents && node.__chGlobalRegisteredEvents[eventName];
    };
    var findEventRegisteredNode = function findEventRegisteredNode(node, eventName) {
        while (node && !checkEventRegistration(node, eventName)) {
            node = node.parentNode;
        }if (node) return node;else if (checkEventRegistration(window, eventName)) return window;
    };

    var generateTouchEventProxyIfRegistered = function generateTouchEventProxyIfRegistered(eventName, touchPoint, target, eventObject, canBubble, relatedTarget) {
        // Check if user registered this event
        if (findEventRegisteredNode(target, eventName)) {
            generateTouchEventProxy(eventName, touchPoint, target, eventObject, canBubble, relatedTarget);
        }
    };

    var getMouseEquivalentEventName = function getMouseEquivalentEventName(eventName) {
        return eventName.toLowerCase().replace('pointer', 'mouse');
    };

    var getPrefixEventName = function getPrefixEventName(prefix, eventName) {
        var upperCaseIndex = supportedEventsNames.indexOf(eventName);
        var newEventName = prefix + upperCaseEventsNames[upperCaseIndex];

        return newEventName;
    };

    var registerOrUnregisterEvent = function registerOrUnregisterEvent(item, name, func, enable) {
        if (item.__chRegisteredEvents === undefined) {
            item.__chRegisteredEvents = [];
        }

        if (enable) {
            if (item.__chRegisteredEvents[name] !== undefined) {
                item.__chRegisteredEvents[name]++;
                return;
            }

            item.__chRegisteredEvents[name] = 1;
            item.addEventListener(name, func, false);
        } else {

            if (item.__chRegisteredEvents.indexOf(name) !== -1) {
                item.__chRegisteredEvents[name]--;

                if (item.__chRegisteredEvents[name] !== 0) {
                    return;
                }
            }
            item.removeEventListener(name, func);
            item.__chRegisteredEvents[name] = 0;
        }
    };

    var setTouchAware = function setTouchAware(item, eventName, enable) {
        // Leaving tokens
        if (!item.__chGlobalRegisteredEvents) {
            item.__chGlobalRegisteredEvents = [];
        }
        if (enable) {
            if (item.__chGlobalRegisteredEvents[eventName] !== undefined) {
                item.__chGlobalRegisteredEvents[eventName]++;
                return;
            }
            item.__chGlobalRegisteredEvents[eventName] = 1;
        } else {
            if (item.__chGlobalRegisteredEvents[eventName] !== undefined) {
                item.__chGlobalRegisteredEvents[eventName]--;
                if (item.__chGlobalRegisteredEvents[eventName] < 0) {
                    item.__chGlobalRegisteredEvents[eventName] = 0;
                }
            }
        }

        var nameGenerator;
        var eventGenerator;
        if (window.MSPointerEvent) {
            nameGenerator = function nameGenerator(name) {
                return getPrefixEventName('MS', name);
            };
            eventGenerator = generateTouchClonedEvent;
        } else {
            nameGenerator = getMouseEquivalentEventName;
            eventGenerator = generateMouseProxy;
        }
        switch (eventName) {
            case 'pointerenter':
            case 'pointerleave':
                var targetEvent = nameGenerator(eventName);
                if (item['on' + targetEvent.toLowerCase()] !== undefined) {
                    registerOrUnregisterEvent(item, targetEvent, function (evt) {
                        eventGenerator(evt, eventName);
                    }, enable);
                }
                break;
        }
    };

    // Intercept addEventListener calls by changing the prototype
    var interceptAddEventListener = function interceptAddEventListener(root) {
        var current = root.prototype ? root.prototype.addEventListener : root.addEventListener;

        var customAddEventListener = function customAddEventListener(name, func, capture) {
            // Branch when a PointerXXX is used
            if (supportedEventsNames.indexOf(name) !== -1) {
                setTouchAware(this, name, true);
            }

            if (current === undefined) {
                this.attachEvent('on' + getMouseEquivalentEventName(name), func);
            } else {
                current.call(this, name, func, capture);
            }
        };

        if (root.prototype) {
            root.prototype.addEventListener = customAddEventListener;
        } else {
            root.addEventListener = customAddEventListener;
        }
    };

    // Intercept removeEventListener calls by changing the prototype
    var interceptRemoveEventListener = function interceptRemoveEventListener(root) {
        var current = root.prototype ? root.prototype.removeEventListener : root.removeEventListener;

        var customRemoveEventListener = function customRemoveEventListener(name, func, capture) {
            // Release when a PointerXXX is used
            if (supportedEventsNames.indexOf(name) !== -1) {
                setTouchAware(this, name, false);
            }

            if (current === undefined) {
                this.detachEvent(getMouseEquivalentEventName(name), func);
            } else {
                current.call(this, name, func, capture);
            }
        };
        if (root.prototype) {
            root.prototype.removeEventListener = customRemoveEventListener;
        } else {
            root.removeEventListener = customRemoveEventListener;
        }
    };

    // Hooks
    interceptAddEventListener(window);
    interceptAddEventListener(window.HTMLElement || window.Element);
    interceptAddEventListener(document);
    interceptAddEventListener(HTMLBodyElement);
    interceptAddEventListener(HTMLDivElement);
    interceptAddEventListener(HTMLImageElement);
    interceptAddEventListener(HTMLUListElement);
    interceptAddEventListener(HTMLAnchorElement);
    interceptAddEventListener(HTMLLIElement);
    interceptAddEventListener(HTMLTableElement);
    if (window.HTMLSpanElement) {
        interceptAddEventListener(HTMLSpanElement);
    }
    if (window.HTMLCanvasElement) {
        interceptAddEventListener(HTMLCanvasElement);
    }
    if (window.SVGElement) {
        interceptAddEventListener(SVGElement);
    }

    interceptRemoveEventListener(window);
    interceptRemoveEventListener(window.HTMLElement || window.Element);
    interceptRemoveEventListener(document);
    interceptRemoveEventListener(HTMLBodyElement);
    interceptRemoveEventListener(HTMLDivElement);
    interceptRemoveEventListener(HTMLImageElement);
    interceptRemoveEventListener(HTMLUListElement);
    interceptRemoveEventListener(HTMLAnchorElement);
    interceptRemoveEventListener(HTMLLIElement);
    interceptRemoveEventListener(HTMLTableElement);
    if (window.HTMLSpanElement) {
        interceptRemoveEventListener(HTMLSpanElement);
    }
    if (window.HTMLCanvasElement) {
        interceptRemoveEventListener(HTMLCanvasElement);
    }
    if (window.SVGElement) {
        interceptRemoveEventListener(SVGElement);
    }

    // Prevent mouse event from being dispatched after Touch Events action
    var touching = false;
    var touchTimer = -1;

    function setTouchTimer() {
        touching = true;
        clearTimeout(touchTimer);
        touchTimer = setTimeout(function () {
            touching = false;
        }, 700);
        // 1. Mobile browsers dispatch mouse events 300ms after touchend
        // 2. Chrome for Android dispatch mousedown for long-touch about 650ms
        // Result: Blocking Mouse Events for 700ms.
    }

    function getFirstCommonNode(x, y) {
        while (x) {
            if (x === document.documentElement || x.contains && x.contains(y)) {
                return x;
            }
            x = x.parentNode;
        }

        return null;
    }

    //generateProxy receives a node to dispatch the event
    function dispatchPointerEnter(currentTarget, relatedTarget, generateProxy) {
        var commonParent = getFirstCommonNode(currentTarget, relatedTarget);
        var node = currentTarget;
        var nodelist = [];
        while (node && node !== commonParent) {
            //target range: this to the direct child of parent relatedTarget
            if (checkEventRegistration(node, 'pointerenter')) //check if any parent node has pointerenter
                nodelist.push(node);
            node = node.parentNode;
        }
        while (nodelist.length > 0) {
            generateProxy(nodelist.pop());
        }
    }

    //generateProxy receives a node to dispatch the event
    function dispatchPointerLeave(currentTarget, relatedTarget, generateProxy) {
        var commonParent = getFirstCommonNode(currentTarget, relatedTarget);
        var node = currentTarget;
        while (node && node !== commonParent) {
            //target range: this to the direct child of parent relatedTarget
            if (checkEventRegistration(node, 'pointerleave')) //check if any parent node has pointerleave
                generateProxy(node);
            node = node.parentNode;
        }
    }

    // Handling events on window to prevent unwanted super-bubbling
    // All mouse events are affected by touch fallback
    function applySimpleEventTunnels(nameGenerator, eventGenerator) {
        ['pointerdown', 'pointermove', 'pointerup', 'pointerover', 'pointerout'].forEach(function (eventName) {
            window.addEventListener(nameGenerator(eventName), function (evt) {
                if (!touching && findEventRegisteredNode(evt.target, eventName)) eventGenerator(evt, eventName, true);
            });
        });
        if (window['on' + nameGenerator('pointerenter').toLowerCase()] === undefined) window.addEventListener(nameGenerator('pointerover'), function (evt) {
            if (touching) return;
            var foundNode = findEventRegisteredNode(evt.target, 'pointerenter');
            if (!foundNode || foundNode === window) return;else if (!foundNode.contains(evt.relatedTarget)) {
                dispatchPointerEnter(foundNode, evt.relatedTarget, function (targetNode) {
                    eventGenerator(evt, 'pointerenter', false, targetNode, evt.relatedTarget);
                });
            }
        });
        if (window['on' + nameGenerator('pointerleave').toLowerCase()] === undefined) window.addEventListener(nameGenerator('pointerout'), function (evt) {
            if (touching) return;
            var foundNode = findEventRegisteredNode(evt.target, 'pointerleave');
            if (!foundNode || foundNode === window) return;else if (!foundNode.contains(evt.relatedTarget)) {
                dispatchPointerLeave(foundNode, evt.relatedTarget, function (targetNode) {
                    eventGenerator(evt, 'pointerleave', false, targetNode, evt.relatedTarget);
                });
            }
        });
    }

    (function () {
        if (window.MSPointerEvent) {
            //IE 10
            applySimpleEventTunnels(function (name) {
                return getPrefixEventName('MS', name);
            }, generateTouchClonedEvent);
        } else {
            applySimpleEventTunnels(getMouseEquivalentEventName, generateMouseProxy);

            // Handling move on window to detect pointerleave/out/over
            if (window.ontouchstart !== undefined) {
                window.addEventListener('touchstart', function (eventObject) {
                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {
                        var touchPoint = eventObject.changedTouches[i];
                        previousTargets[touchPoint.identifier] = touchPoint.target;

                        generateTouchEventProxyIfRegistered('pointerover', touchPoint, touchPoint.target, eventObject, true);

                        //pointerenter should not be bubbled
                        dispatchPointerEnter(touchPoint.target, null, function (targetNode) {
                            generateTouchEventProxy('pointerenter', touchPoint, targetNode, eventObject, false);
                        });

                        generateTouchEventProxyIfRegistered('pointerdown', touchPoint, touchPoint.target, eventObject, true);
                    }
                    setTouchTimer();
                });

                window.addEventListener('touchend', function (eventObject) {
                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {
                        var touchPoint = eventObject.changedTouches[i];
                        var currentTarget = previousTargets[touchPoint.identifier];

                        if (!currentTarget) {
                            continue;
                        }

                        generateTouchEventProxyIfRegistered('pointerup', touchPoint, currentTarget, eventObject, true);
                        generateTouchEventProxyIfRegistered('pointerout', touchPoint, currentTarget, eventObject, true);

                        //pointerleave should not be bubbled
                        dispatchPointerLeave(currentTarget, null, function (targetNode) {
                            generateTouchEventProxy('pointerleave', touchPoint, targetNode, eventObject, false);
                        });

                        delete previousTargets[touchPoint.identifier];
                    }
                    setTouchTimer();
                });

                window.addEventListener('touchmove', function (eventObject) {
                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {
                        var touchPoint = eventObject.changedTouches[i];
                        var newTarget = document.elementFromPoint(touchPoint.clientX, touchPoint.clientY);
                        var currentTarget = previousTargets[touchPoint.identifier];

                        // If force preventDefault
                        if (currentTarget && checkPreventDefault(currentTarget) === true) eventObject.preventDefault();

                        // Viewport manipulation fires non-cancelable touchmove
                        if (!eventObject.cancelable) {
                            delete previousTargets[touchPoint.identifier];
                            generateTouchEventProxyIfRegistered('pointercancel', touchPoint, currentTarget, eventObject, true);
                            generateTouchEventProxyIfRegistered('pointerout', touchPoint, currentTarget, eventObject, true);

                            dispatchPointerLeave(currentTarget, null, function (targetNode) {
                                generateTouchEventProxy('pointerleave', touchPoint, targetNode, eventObject, false);
                            });
                            continue;
                        }

                        generateTouchEventProxyIfRegistered('pointermove', touchPoint, currentTarget, eventObject, true);

                        if (currentTarget === newTarget) {
                            continue; // We can skip this as the pointer is effectively over the current target
                        }

                        if (currentTarget) {
                            // Raise out
                            generateTouchEventProxyIfRegistered('pointerout', touchPoint, currentTarget, eventObject, true, newTarget);

                            // Raise leave
                            if (!currentTarget.contains(newTarget)) {
                                // Leave must be called if the new target is not a child of the current
                                dispatchPointerLeave(currentTarget, newTarget, function (targetNode) {
                                    generateTouchEventProxy('pointerleave', touchPoint, targetNode, eventObject, false, newTarget);
                                });
                            }
                        }

                        if (newTarget) {
                            // Raise over
                            generateTouchEventProxyIfRegistered('pointerover', touchPoint, newTarget, eventObject, true, currentTarget);

                            // Raise enter
                            if (!newTarget.contains(currentTarget)) {
                                // Leave must be called if the new target is not the parent of the current
                                dispatchPointerEnter(newTarget, currentTarget, function (targetNode) {
                                    generateTouchEventProxy('pointerenter', touchPoint, targetNode, eventObject, false, currentTarget);
                                });
                            }
                        }
                        previousTargets[touchPoint.identifier] = newTarget;
                    }
                    setTouchTimer();
                });

                window.addEventListener('touchcancel', function (eventObject) {
                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {
                        var touchPoint = eventObject.changedTouches[i];

                        generateTouchEventProxyIfRegistered('pointercancel', touchPoint, previousTargets[touchPoint.identifier], eventObject, true);
                    }
                });
            }
        }
    })();

    // Extension to navigator
    if (navigator.pointerEnabled === undefined) {

        // Indicates if the browser will fire pointer events for pointing input
        navigator.pointerEnabled = true;

        // IE
        if (navigator.msPointerEnabled) {
            navigator.maxTouchPoints = navigator.msMaxTouchPoints;
        }
    }
})(window);

/**
 * Normalizes touch/touch+click events into a 'pointertap' event that is not
 * part of standard.
 * Uses pointerEvents polyfill or native PointerEvents when supported.
 *
 * @example
 * // Use pointertap as fastclick on touch enabled devices
 * document.querySelector('.btn').addEventListener(ch.pointertap, function(e) {
 *   console.log('tap');
 * });
 */
(function () {
    'use strict';

    // IE8 has no support for custom Mouse Events, fallback to onclick

    if (!window.MouseEvent) {
        return;
    }

    var POINTER_TYPE_TOUCH = 'touch';
    var POINTER_TYPE_PEN = 'pen';
    var POINTER_TYPE_MOUSE = 'mouse';

    var isScrolling = false;
    var scrollTimeout = false;
    var sDistX = 0;
    var sDistY = 0;
    var activePointer;

    window.addEventListener('scroll', function () {
        if (!isScrolling) {
            sDistX = window.pageXOffset;
            sDistY = window.pageYOffset;
        }
        isScrolling = true;
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(function () {
            isScrolling = false;
            sDistX = 0;
            sDistY = 0;
        }, 100);
    });

    window.addEventListener('pointerdown', pointerDown);
    window.addEventListener('pointerup', pointerUp);
    window.addEventListener('pointerleave', pointerLeave);

    window.addEventListener('pointermove', function () /* e */{});

    /**
     * Handles the 'pointerdown' event from pointerEvents polyfill or native PointerEvents when supported.
     *
     * @private
     * @param {MouseEvent|PointerEvent} e Event.
     */
    function pointerDown(e) {
        // don't register an activePointer if more than one touch is active.
        var singleFinger = e.pointerType === POINTER_TYPE_MOUSE || e.pointerType === POINTER_TYPE_PEN || e.pointerType === POINTER_TYPE_TOUCH && e.isPrimary;

        if (!isScrolling && singleFinger) {
            activePointer = {
                id: e.pointerId,
                clientX: e.clientX,
                clientY: e.clientY,
                x: e.x || e.pageX,
                y: e.y || e.pageY,
                type: e.pointerType
            };
        }
    }

    /**
     * Handles the 'pointerleave' event from pointerEvents polyfill or native PointerEvents when supported.
     *
     * @private
     * @param {MouseEvent|PointerEvent} e Event.
     */
    function pointerLeave() /* e */{
        activePointer = null;
    }

    /**
     * Handles the 'pointerup' event from pointerEvents polyfill or native PointerEvents when supported.
     *
     * @private
     * @param {MouseEvent|PointerEvent} e Event.
     */
    function pointerUp(e) {
        // Does our event is the same as the activePointer set by pointerdown?
        if (activePointer && activePointer.id === e.pointerId) {
            // Have we moved too much?
            if (Math.abs(activePointer.x - (e.x || e.pageX)) < 5 && Math.abs(activePointer.y - (e.y || e.pageY)) < 5) {
                // Have we scrolled too much?
                if (!isScrolling || Math.abs(sDistX - window.pageXOffset) < 5 && Math.abs(sDistY - window.pageYOffset) < 5) {
                    makePointertapEvent(e);
                }
            }
        }
        activePointer = null;
    }

    /**
     * Creates the pointertap event that is not part of standard.
     *
     * @private
     * @param {MouseEvent|PointerEvent} sourceEvent An event to use as a base for pointertap.
     */
    function makePointertapEvent(sourceEvent) {
        var evt = document.createEvent('MouseEvents');
        var newTarget = document.elementFromPoint(sourceEvent.clientX, sourceEvent.clientY);

        // According to the MDN docs if the specified point is outside the visible bounds of the document
        // or either coordinate is negative, the result is null
        if (!newTarget) {
            return null;
        }

        // TODO: Replace 'initMouseEvent' with 'new MouseEvent'
        evt.initMouseEvent('pointertap', true, true, window, 1, sourceEvent.screenX, sourceEvent.screenY, sourceEvent.clientX, sourceEvent.clientY, sourceEvent.ctrlKey, sourceEvent.altKey, sourceEvent.shiftKey, sourceEvent.metaKey, sourceEvent.button, newTarget);

        evt.maskedEvent = sourceEvent;
        newTarget.dispatchEvent(evt);

        return evt;
    }
})();

var supportsMouseEvents = !!window.MouseEvent;

/**
 * Every time Chico UI needs to inform all visual components that layout has
 * been changed, it emits this event.
 *
 * @constant
 * @type {String}
 */
var onlayoutchange = 'layoutchange';

/**
 * Equivalent to 'resize'.
 * @constant
 * @type {String}
 */
var onresize = 'resize';

/**
 * Equivalent to 'scroll'.
 * @constant
 * @type {String}
 */
var onscroll = 'scroll';

/**
 * Equivalent to 'pointerdown' or 'mousedown', depending on browser capabilities.
 *
 * @constant
 * @type {String}
 * @link http://www.w3.org/TR/pointerevents/#dfn-pointerdown | Pointer Events W3C Recommendation
 */
var onpointerdown = supportsMouseEvents ? 'pointerdown' : 'mousedown';

/**
 * Equivalent to 'pointerup' or 'mouseup', depending on browser capabilities.
 *
 * @constant
 * @type {String}
 * @link http://www.w3.org/TR/pointerevents/#dfn-pointerup | Pointer Events W3C Recommendation
 */
var onpointerup = supportsMouseEvents ? 'pointerup' : 'mouseup';

/**
 * Equivalent to 'pointermove' or 'mousemove', depending on browser capabilities.
 *
 * @constant
 * @type {String}
 * @link http://www.w3.org/TR/pointerevents/#dfn-pointermove | Pointer Events W3C Recommendation
 */
var onpointermove = supportsMouseEvents ? 'pointermove' : 'mousemove';

/**
 * Equivalent to 'pointertap' or 'click', depending on browser capabilities.
 *
 * @constant
 * @type {String}
 * @link http://www.w3.org/TR/pointerevents/#list-of-pointer-events | Pointer Events W3C Recommendation
 */
var onpointertap = support.touch && supportsMouseEvents ? 'pointertap' : 'click';

/**
 * Equivalent to 'pointerenter' or 'mouseenter', depending on browser capabilities.
 *
 * @constant
 * @type {String}
 * @link http://www.w3.org/TR/pointerevents/#dfn-pointerenter | Pointer Events W3C Recommendation
 */
var onpointerenter = supportsMouseEvents ? 'pointerenter' : 'mouseenter';

/**
 * Equivalent to 'pointerleave' or 'mouseleave', depending on browser capabilities.
 *
 * @constant
 * @type {String}
 * @link http://www.w3.org/TR/pointerevents/#dfn-pointerleave | Pointer Events W3C Recommendation
 */
var onpointerleave = supportsMouseEvents ? 'pointerleave' : 'mouseleave';

/**
 * The DOM input event that is fired when the value of an <input> or <textarea>
 * element is changed. Equivalent to 'input' or 'keydown', depending on browser
 * capabilities.
 *
 * @constant
 * @type {String}
 */
var onkeyinput = 'oninput' in document.createElement('input') ? 'input' : 'keydown';

var events = Object.freeze({
    onlayoutchange: onlayoutchange,
    onresize: onresize,
    onscroll: onscroll,
    onpointerdown: onpointerdown,
    onpointerup: onpointerup,
    onpointermove: onpointermove,
    onpointertap: onpointertap,
    onpointerenter: onpointerenter,
    onpointerleave: onpointerleave,
    onkeyinput: onkeyinput
});

var tiny = {
    clone: clone,
    extend: extend,
    inherits: inherits,
    EventEmitter: EventEmitter,
    ajax: ajax,
    jsonp: jsonp,
    jcors: jcors,
    isPlainObject: isPlainObject,
    support: support,
    addClass: classList.addClass,
    removeClass: classList.removeClass,
    hasClass: classList.hasClass,
    parent: parent,
    next: next,
    css: css,
    offset: offset,
    scroll: scroll,
    cookies: cookies,
    on: DOMEvents.on,
    bind: DOMEvents.on,
    one: DOMEvents.once,
    once: DOMEvents.once,
    off: DOMEvents.off,
    trigger: DOMEvents.trigger
};

for (var e in events) {
    tiny[e] = events[e];
}

if (typeof window !== 'undefined') {
    window.tiny = tiny;
}

module.exports = tiny;

},{"events":1,"inherits":2}]},{},[3]);

/*!
 * Chico UI v2.0.9
 * http://chico-ui.com.ar/
 *
 * Copyright (c) 2016, MercadoLibre.com
 * Released under the MIT license.
 * http://chico-ui.com.ar/license
 */

(function (window) {
	'use strict';

    /**
     * An object which contains all the public members. A short alias for el.querySelectorAll
     * @param {String} selector Valid CSS selector expression
     * @param {String|HTMLElement} context A DOM Element, Document, or selector string to use as query context
     * @returns {NodeList} A collection of matched elements
     *
     * @namespace
     *
     * @example
     * // Get all first level headings
     * var headings = ch('h1');
     *
     * // Get a list of p children elements under a container, whose parent is a div that has the class 'wrapper'
     * var paragraphs = ch('p', ch('div.wrapper'));
     * // The same as above
     * var paragraphs = ch('p', 'div.wrapper');
     */
    /*eslint-disable no-unused-vars*/
    var ch = function(selector, context) {
        if (!context) {
            context = document;
        } else if (typeof context === 'string') {
            context = document.querySelector(context);
        }
        // Since NodeList is an array-like object but Array.isArray is always falsy
        // we should detect the NodeList
        // Please replace NodeList detection with `context instanceof NodeList && context.length > 0`
        //   when IE8 support will be dropped
        // Please replace Object.prototype.hasOwnProperty.call with `context.hasOwnProperty` when IE8
        //   support will be dropped
        if (typeof context === 'object' &&
            /^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(context)) &&
            Object.prototype.hasOwnProperty.call(context, 'length') && context.length > 0 && context[0].nodeType > 0) {
            context = context[0];
        }

        if (context === null || !context.nodeType) {
            context = document;
        }

        return context.querySelectorAll(selector);
    };
    /*eslint-enable no-unused-vars*/

    /**
     * Tab key event.
     * @constant
     * @memberof ch
     * @type {String}
     */
    ch.onkeytab = 'tab';

    /**
     * Enter key event.
     * @constant
     * @memberof ch
     * @type {String}
     */
    ch.onkeyenter = 'enter';

    /**
     * Esc key event.
     * @constant
     * @memberof ch
     * @type {String}
     */
    ch.onkeyesc = 'esc';

    /**
     * Left arrow key event.
     * @constant
     * @memberof ch
     * @type {String}
     */
    ch.onkeyleftarrow = 'left_arrow';

    /**
     * Up arrow key event.
     * @constant
     * @memberof ch
     * @type {String}
     */
    ch.onkeyuparrow = 'up_arrow';

    /**
     * Rigth arrow key event.
     * @constant
     * @memberof ch
     * @type {String}
     */
    ch.onkeyrightarrow = 'right_arrow';

    /**
     * Down arrow key event.
     * @constant
     * @memberof ch
     * @type {String}
     */
    ch.onkeydownarrow = 'down_arrow';

    /**
     * Backspace key event.
     * @constant
     * @memberof ch
     * @type {String}
     */
    ch.onkeybackspace = 'backspace';

    /**
     * Method in change of expose a friendly interface of the Chico constructors.
     *
     * @memberof ch
     * @param {Object} Klass Direct reference to the constructor from where the $-plugin will be created.
     * @link http://docs.jquery.com/Plugins/Authoring | Authoring
     */
    ch.factory = function (Klass) {
        /**
         * Identification of the constructor, in lowercases.
         * @type {String}
         */
        var name = Klass.prototype.name;

        // Uses the function.name property (non-standard) on the newest browsers OR
        // uppercases the first letter from the identification name of the constructor
        ch[(name.charAt(0).toUpperCase() + name.substr(1))] = Klass;
    };

// Remove the no-js classname from html tag
tiny.removeClass(document.documentElement, 'no-js');

// Expose event names
for (var m in tiny) {
    if (/^on\w+/.test(m) && typeof tiny[m] === 'string') {
        ch[m] = tiny[m];
    }
}

	ch.version = '2.0.9';
	window.ch = ch;
}(this));
(function (ch) {
    'use strict';

    /**
     * Add a function to manage components content.
     * @memberOf ch
     * @mixin
     * @returns {Function}
     */
    function Content() {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            defaults = {
                'method': this._options.method,
                'params': this._options.params,
                'cache': this._options.cache,
                'waiting': this._options.waiting
            };

        /**
         * Set async content into component's container and emits the current event.
         * @private
         */
        function setAsyncContent(event) {

            that._content.innerHTML = event.response;

            /**
             * Event emitted when the content change.
             * @event ch.Content#contentchange
             * @private
             */
            that.emit('_contentchange');

            /**
             * Event emitted if the content is loaded successfully.
             * @event ch.Content#contentdone
             * @ignore
             */

            /**
             * Event emitted when the content is loading.
             * @event ch.Content#contentwaiting
             * @example
             * // Subscribe to "contentwaiting" event.
             * component.on('contentwaiting', function (event) {
             *     // Some code here!
             * });
             */

            /**
             * Event emitted if the content isn't loaded successfully.
             * @event ch.Content#contenterror
             * @example
             * // Subscribe to "contenterror" event.
             * component.on('contenterror', function (event) {
             *     // Some code here!
             * });
             */

            that.emit('content' + event.status, event);
        }

        /**
         * Set content into component's container and emits the contentdone event.
         * @private
         */
        function setContent(content) {

            if (content.nodeType !== undefined) {
                that._content.innerHTML = '';
                that._content.appendChild(content);
            } else {
                that._content.innerHTML = content;
            }


            that._options.cache = true;

            /**
             * Event emitted when the content change.
             * @event ch.Content#contentchange
             * @private
             */
            that.emit('_contentchange');

            /**
             * Event emitted if the content is loaded successfully.
             * @event ch.Content#contentdone
             * @example
             * // Subscribe to "contentdone" event.
             * component.on('contentdone', function (event) {
             *     // Some code here!
             * });
             */
            that.emit('contentdone');
        }

        /**
         * Get async content with given URL.
         * @private
         */
        function getAsyncContent(url, options) {
            var requestCfg;
            // Initial options to be merged with the user's options
            options = tiny.extend({
                'method': 'GET',
                'params': '',
                'waiting': '<div class="ch-loading-large"></div>'
            }, defaults, options);

            // Set loading
            setAsyncContent({
                'status': 'waiting',
                'response': options.waiting
            });

            requestCfg = {
                method: options.method,
                success: function(resp) {
                    setAsyncContent({
                        'status': 'done',
                        'response': resp
                    });
                },
                error: function(err) {
                    setAsyncContent({
                        'status': 'error',
                        'response': '<p>Error on ajax call.</p>',
                        'data': err.message || JSON.stringify(err)
                    });
                }
            };

            if (options.cache !== undefined) {
                that._options.cache = options.cache;
            }

            if (options.cache === false && ['GET', 'HEAD'].indexOf(options.method.toUpperCase()) !== -1) {
                requestCfg.cache = false;
            }

            if (options.params) {
                if (['GET', 'HEAD'].indexOf(options.method.toUpperCase()) !== -1) {
                    url += (url.indexOf('?') !== -1 || options.params[0] === '?' ? '' : '?') + options.params;
                } else {
                    requestCfg.data = options.params;
                }
            }

            // Make a request
            tiny.ajax(url, requestCfg);
        }

        /**
         * Allows to manage the components content.
         * @function
         * @memberof! ch.Content#
         * @param {(String | HTMLElement)} content The content that will be used by a component.
         * @param {Object} [options] A custom options to be used with content loaded by ajax.
         * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
         * @param {String} [options.params] Params like query string to be sent to the server.
         * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true. false value will work only with HEAD and GET requests
         * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading.
         * @example
         * // Update content with some string.
         * component.content('Some new content here!');
         * @example
         * // Update content that will be loaded by ajax with custom options.
         * component.content('http://chico-ui.com.ar/ajax', {
         *     'cache': false,
         *     'params': 'x-request=true'
         * });
         */
        this.content = function (content, options) {
            var parent;

            // Returns the last updated content.
            if (content === undefined) {
                return that._content.innerHTML;
            }

            that._options.content = content;

            if (that._options.cache === undefined) {
                that._options.cache = true;
            }

            if (typeof content === 'string') {
                // Case 1: AJAX call
                if ((/^(((https|http|ftp|file):\/\/)|www\.|\.\/|(\.\.\/)+|(\/{1,2})|(\d{1,3}\.){3}\d{1,3})(((\w+|-)(\.?)(\/?))+)(\:\d{1,5}){0,1}(((\w+|-)(\.?)(\/?)(#?))+)((\?)(\w+=(\w?)+(&?))+)?(\w+#\w+)?$/).test(content)) {
                    getAsyncContent(content.replace(/#.+/, ''), options);
                // Case 2: Plain text
                } else {
                    setContent(content);
                }
            // Case 3: HTML Element
            } else if (content.nodeType !== undefined) {

                tiny.removeClass(content, 'ch-hide');
                parent = tiny.parent(content);

                setContent(content);

                if (!that._options.cache) {
                    parent.removeChild(content);
                }

            }

            return that;
        };

        // Loads content once. If the cache is disabled the content loads in each show.
        this.once('_show', function () {

            that.content(that._options.content);

            that.on('show', function () {
                if (!that._options.cache) {
                    that.content(that._options.content);
                }
            });
        });
    }

    ch.Content = Content;

}(this.ch));

(function (ch) {
    'use strict';

    var toggleEffects = {
        'slideDown': 'slideUp',
        'slideUp': 'slideDown',
        'fadeIn': 'fadeOut',
        'fadeOut': 'fadeIn'
    };

    /**
     * The Collapsible class gives to components the ability to shown or hidden its container.
     * @memberOf ch
     * @mixin
     * @returns {Function} Returns a private function.
     */
    function Collapsible() {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            triggerClass = 'ch-' + this.name + '-trigger-on',
            fx = this._options.fx,
            useEffects = (tiny.support.transition && fx !== 'none' && fx !== false),
            pt, pb;

        function showCallback(e) {
            if (useEffects) {
                tiny.removeClass(that.container, 'ch-fx-' + fx);

                // TODO: Use original height when it is defined
                if (/^slide/.test(fx)) {
                    that.container.style.height = '';
                }
            }
            tiny.removeClass(that.container, 'ch-hide');
            that.container.setAttribute('aria-hidden', 'false');

            if (e) {
                e.target.removeEventListener(e.type, showCallback);
            }

            /**
             * Event emitted when the component is shown.
             * @event ch.Collapsible#show
             * @example
             * // Subscribe to "show" event.
             * collapsible.on('show', function () {
             *     // Some code here!
             * });
             */
            that.emit('show');
        }

        function hideCallback(e) {
            if (useEffects) {
                tiny.removeClass(that.container, 'ch-fx-' + toggleEffects[fx]);
                that.container.style.display = '';
                if (/^slide/.test(fx)) {
                    that.container.style.height = '';
                }
            }
            tiny.addClass(that.container, 'ch-hide');
            that.container.setAttribute('aria-hidden', 'true');

            if (e) {
                e.target.removeEventListener(e.type, hideCallback);
            }

            /**
             * Event emitted when the component is hidden.
             * @event ch.Collapsible#hide
             * @example
             * // Subscribe to "hide" event.
             * collapsible.on('hide', function () {
             *     // Some code here!
             * });
             */
            that.emit('hide');
        }

        this._shown = false;

        /**
         * Shows the component container.
         * @function
         * @private
         */
        this._show = function () {

            that._shown = true;

            if (that.trigger !== undefined) {
                tiny.addClass(that.trigger, triggerClass);
            }

            /**
             * Event emitted before the component is shown.
             * @event ch.Collapsible#beforeshow
             * @example
             * // Subscribe to "beforeshow" event.
             * collapsible.on('beforeshow', function () {
             *     // Some code here!
             * });
             */
            that.emit('beforeshow');

            // Animate or not
            if (useEffects) {
                var _h = 0;

                // Be sure to remove an opposite class that probably exist and
                // transitionend listener for an opposite transition, aka $.fn.stop(true, true)
                tiny.off(that.container, tiny.support.transition.end, hideCallback);
                tiny.removeClass(that.container, 'ch-fx-' + toggleEffects[fx]);

                tiny.on(that.container, tiny.support.transition.end, showCallback);

                // Reveal an element before the transition
                that.container.style.display = 'block';

                // Set margin and padding to 0 to prevent content jumping at the transition end
                if (/^slide/.test(fx)) {
                    // Cache the original paddings for the first time
                    if (!pt || !pb) {
                        pt = tiny.css(that.container, 'padding-top');
                        pb = tiny.css(that.container, 'padding-bottom');

                        that.container.style.marginTop = that.container.style.marginBottom =
                            that.container.style.paddingTop = that.container.style.paddingBottom ='0px';
                    }

                    that.container.style.opacity = '0.01';
                    _h = that.container.offsetHeight;
                    that.container.style.opacity = '';
                    that.container.style.height = '0px';
                }

                // Transition cannot be applied at the same time when changing the display property
                setTimeout(function() {
                    if (/^slide/.test(fx)) {
                        that.container.style.height = _h + 'px';
                    }
                    that.container.style.paddingTop = pt;
                    that.container.style.paddingBottom = pb;
                    tiny.addClass(that.container, 'ch-fx-' + fx);
                }, 0);
            } else {
                showCallback();
            }

            that.emit('_show');

            return that;
        };

        /**
         * Hides the component container.
         * @function
         * @private
         */
        this._hide = function () {

            that._shown = false;

            if (that.trigger !== undefined) {
                tiny.removeClass(that.trigger, triggerClass);
            }

            /**
             * Event emitted before the component is hidden.
             * @event ch.Collapsible#beforehide
             * @example
             * // Subscribe to "beforehide" event.
             * collapsible.on('beforehide', function () {
             *     // Some code here!
             * });
             */
            that.emit('beforehide');

            // Animate or not
            if (useEffects) {
                // Be sure to remove an opposite class that probably exist and
                // transitionend listener for an opposite transition, aka $.fn.stop(true, true)
                tiny.off(that.container, tiny.support.transition.end, showCallback);
                tiny.removeClass(that.container, 'ch-fx-' + fx);

                tiny.on(that.container, tiny.support.transition.end, hideCallback);
                // Set margin and padding to 0 to prevent content jumping at the transition end
                if (/^slide/.test(fx)) {
                    that.container.style.height = tiny.css(that.container, 'height');
                    // Uses nextTick to trigger the height change
                    setTimeout(function() {
                        that.container.style.height = '0px';
                        that.container.style.paddingTop = that.container.style.paddingBottom ='0px';
                        tiny.addClass(that.container, 'ch-fx-' + toggleEffects[fx]);
                    }, 0);
                } else {
                    setTimeout(function() {
                        tiny.addClass(that.container, 'ch-fx-' + toggleEffects[fx]);
                    }, 0);
                }
            } else {
                hideCallback();
            }

            return that;
        };

        /**
         * Shows or hides the component.
         * @function
         * @private
         */
        this._toggle = function () {

            if (that._shown) {
                that.hide();
            } else {
                that.show();
            }

            return that;
        };

        this.on('disable', this.hide);
    }

    ch.Collapsible = Collapsible;

}(this.ch));

(function (window, ch) {
    'use strict';

    var resized = false,
        scrolled = false,
        requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, 1000 / 60);
                };
        }());

    function update() {

        var eve = (resized ? ch.onresize : ch.onscroll);

        // Refresh viewport
        this.refresh();

        // Change status
        resized = false;
        scrolled = false;

        /**
         * Event emitted when the dimensions of the viewport changes.
         * @event ch.viewport#resize
         * @example
         * ch.viewport.on('resize', function () {
         *     // Some code here!
         * });
         */

        /**
         * Event emitted when the viewport is scrolled.
         * @event ch.viewport#scroll
         * @example
         * ch.viewport.on('scroll', function () {
         *     // Some code here!
         * });
         */

        // Emits the current event
        this.emit(eve);
    }

    /**
     * The Viewport is a component to ease viewport management. You can get the dimensions of the viewport and beyond, which can be quite helpful to perform some checks with JavaScript.
     * @memberof ch
     * @constructor
     * @augments tiny.EventEmitter
     * @returns {viewport} Returns a new instance of Viewport.
     */
    function Viewport() {
        this._init();
    }

    tiny.inherits(Viewport, tiny.EventEmitter);

    /**
     * Initialize a new instance of Viewport.
     * @memberof! ch.Viewport.prototype
     * @function
     * @private
     * @returns {viewport}
     */
    Viewport.prototype._init = function () {
        // Set emitter to zero for unlimited listeners to avoid the warning in console
        // @see https://nodejs.org/api/events.html#events_emitter_setmaxlisteners_n
        this.setMaxListeners(0);

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        /**
         * Element representing the visible area.
         * @memberof! ch.viewport#element
         * @type {Object}
         */
        this.el = window;

        this.refresh();


        function viewportResize() {
            // No changing, exit
            if (!resized) {
                resized = true;

                /**
                 * requestAnimationFrame
                 */
                requestAnimFrame(function updateResize() {
                    update.call(that);
                });
            }
        }

        function viewportScroll() {
            // No changing, exit
            if (!scrolled) {
                scrolled = true;

                /**
                 * requestAnimationFrame
                 */
                requestAnimFrame(function updateScroll() {
                    update.call(that);
                });
            }
        }

        tiny.on(window, ch.onscroll, viewportScroll, false);
        tiny.on(window, ch.onresize, viewportResize, false);
    };

    /**
     * Calculates/updates the client rects of viewport (in pixels).
     * @memberof! ch.Viewport.prototype
     * @function
     * @returns {viewport}
     * @example
     * // Update the client rects of the viewport.
     * ch.viewport.calculateClientRect();
     */
    Viewport.prototype.calculateClientRect = function () {
        /**
         * The current top client rect of the viewport (in pixels).
         * @public
         * @name ch.Viewport#top
         * @type {Number}
         * @example
         * // Checks if the top client rect of the viewport is equal to 0.
         * (ch.viewport.top === 0) ? 'Yes': 'No';
         */

         /**
         * The current left client rect of the viewport (in pixels).
         * @public
         * @name ch.Viewport#left
         * @type {Number}
         * @example
         * // Checks if the left client rect of the viewport is equal to 0.
         * (ch.viewport.left === 0) ? 'Yes': 'No';
         */
        this.top = this.left = 0;

        /**
         * The current bottom client rect of the viewport (in pixels).
         * @public
         * @name ch.Viewport#bottom
         * @type {Number}
         * @example
         * // Checks if the bottom client rect of the viewport is equal to a number.
         * (ch.viewport.bottom === 900) ? 'Yes': 'No';
         */
        this.bottom = Math.max(this.el.innerHeight || 0, document.documentElement.clientHeight);

        /**
         * The current right client rect of the viewport (in pixels).
         * @public
         * @name ch.Viewport#right
         * @type {Number}
         * @example
         * // Checks if the right client rect of the viewport is equal to a number.
         * (ch.viewport.bottom === 1200) ? 'Yes': 'No';
         */
        this.right = Math.max(this.el.innerWidth || 0, document.documentElement.clientWidth);

        return this;
    };

    /**
     * Calculates/updates the dimensions (width and height) of the viewport (in pixels).
     * @memberof! ch.Viewport.prototype
     * @function
     * @returns {viewport}
     * @example
     * // Update the dimensions values of the viewport.
     * ch.viewport.calculateDimensions();
     */
    Viewport.prototype.calculateDimensions = function () {
        this.calculateClientRect();

        /**
         * The current height of the viewport (in pixels).
         * @public
         * @name ch.Viewport#height
         * @type Number
         * @example
         * // Checks if the height of the viewport is equal to a number.
         * (ch.viewport.height === 700) ? 'Yes': 'No';
         */
        this.height = this.bottom;

        /**
         * The current width of the viewport (in pixels).
         * @public
         * @name ch.Viewport#width
         * @type Number
         * @example
         * // Checks if the height of the viewport is equal to a number.
         * (ch.viewport.width === 1200) ? 'Yes': 'No';
         */
        this.width = this.right;

        return this;
    };

    /**
     * Calculates/updates the viewport position.
     * @memberof! ch.Viewport.prototype
     * @function
     * @returns {viewport}
     * @example
     * // Update the offest values of the viewport.
     * ch.viewport.calculateOffset();
     */
    Viewport.prototype.calculateOffset = function () {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var scroll = tiny.scroll();

        /**
         * The offset top of the viewport.
         * @memberof! ch.Viewport#offsetTop
         * @type {Number}
         * @example
         * // Checks if the offset top of the viewport is equal to a number.
         * (ch.viewport.offsetTop === 200) ? 'Yes': 'No';
         */
        this.offsetTop = scroll.top;

        /**
         * The offset left of the viewport.
         * @memberof! ch.Viewport#offsetLeft
         * @type {Number}
         * @example
         * // Checks if the offset left of the viewport is equal to a number.
         * (ch.viewport.offsetLeft === 200) ? 'Yes': 'No';
         */
        this.offsetLeft = scroll.left;

        /**
         * The offset right of the viewport.
         * @memberof! ch.Viewport#offsetRight
         * @type {Number}
         * @example
         * // Checks if the offset right of the viewport is equal to a number.
         * (ch.viewport.offsetRight === 200) ? 'Yes': 'No';
         */
        this.offsetRight = this.left + this.width;

        /**
         * The offset bottom of the viewport.
         * @memberof! ch.Viewport#offsetBottom
         * @type {Number}
         * @example
         * // Checks if the offset bottom of the viewport is equal to a number.
         * (ch.viewport.offsetBottom === 200) ? 'Yes': 'No';
         */
        this.offsetBottom = this.offsetTop + this.height;

        return this;
    };

    /**
     * Rertuns/updates the viewport orientation: landscape or portrait.
     * @memberof! ch.Viewport.prototype
     * @function
     * @returns {viewport}
     * @example
     * // Update the dimensions values of the viewport.
     * ch.viewport.calculateDimensions();
     */
    Viewport.prototype.calculateOrientation = function () {
        /** The viewport orientation: landscape or portrait.
         * @memberof! ch.Viewport#orientation
         * @type {String}
         * @example
         * // Checks if the orientation is "landscape".
         * (ch.viewport.orientation === 'landscape') ? 'Yes': 'No';
         */
        this.orientation = (Math.abs(this.el.orientation) === 90) ? 'landscape' : 'portrait';

        return this;
    };

    /**
     * Calculates if an element is completely located in the viewport.
     * @memberof! ch.Viewport.prototype
     * @function
     * @returns {Boolean}
     * @params {HTMLElement} el A given HMTLElement.
     * @example
     * // Checks if an element is in the viewport.
     * ch.viewport.inViewport(HTMLElement) ? 'Yes': 'No';
     */
    Viewport.prototype.inViewport = function (el) {
        var r = el.getBoundingClientRect();

        return (r.top > 0) && (r.right < this.width) && (r.bottom < this.height) && (r.left > 0);
    };

    /**
     * Calculates if an element is visible in the viewport.
     * @memberof! ch.Viewport.prototype
     * @function
     * @returns {Boolean}
     * @params {HTMLElement} el A given HTMLElement.
     * @example
     * // Checks if an element is visible.
     * ch.viewport.isVisisble(HTMLElement) ? 'Yes': 'No';
     */
    Viewport.prototype.isVisible = function (el) {
        var r = el.getBoundingClientRect();

        return (r.height >= this.offsetTop);
    };

    /**
     * Upadtes the viewport dimension, viewport positions and orietation.
     * @memberof! ch.Viewport.prototype
     * @function
     * @returns {viewport}
     * @example
     * // Refreshs the viewport.
     * ch.viewport.refresh();
     */
    Viewport.prototype.refresh = function () {
        this.calculateDimensions();
        this.calculateOffset();
        this.calculateOrientation();

        return this;
    };

    // Creates an instance of the Viewport into ch namespace.
    ch.viewport = new Viewport();

}(this, this.ch));

(function (window, ch) {
    'use strict';

    /**
     * The Positioner lets you position elements on the screen and changes its positions.
     * @memberof ch
     * @constructor
     * @param {Object} options Configuration object.
     * @param {String} options.target A HTMLElement that reference to the element to be positioned.
     * @param {String} [options.reference] A HTMLElement that it's a reference to position and size of element that will be considered to carry out the position. If it isn't defined through configuration, it will be the ch.viewport.
     * @param {String} [options.side] The side option where the target element will be positioned. You must use: "left", "right", "top", "bottom" or "center". Default: "center".
     * @param {String} [options.align] The align options where the target element will be positioned. You must use: "left", "right", "top", "bottom" or "center". Default: "center".
     * @param {Number} [options.offsetX] Distance to displace the target horizontally. Default: 0.
     * @param {Number} [options.offsetY] Distance to displace the target vertically. Default: 0.
     * @param {String} [options.position] Thethe type of positioning used. You must use: "absolute" or "fixed". Default: "fixed".
     * @requires ch.Viewport
     * @returns {positioner} Returns a new instance of Positioner.
     * @example
     * // Instance the Positioner It requires a little configuration.
     * // The default behavior place an element center into the Viewport.
     * var positioned = new ch.Positioner({
     *     'target': document.querySelector('.target'),
     *     'reference': document.querySelector('.reference'),
     *     'side': 'top',
     *     'align': 'left',
     *     'offsetX': 20,
     *     'offsetY': 10
     * });
     * @example
     * // offsetX: The Positioner could be configurated with an offsetX.
     * // This example show an element displaced horizontally by 10px of defined position.
     * var positioned = new ch.Positioner({
     *     'target': document.querySelector('.target'),
     *     'reference': document.querySelector('.reference'),
     *     'side': 'top',
     *     'align': 'left',
     *     'offsetX': 10
     * });
     * @example
     * // offsetY: The Positioner could be configurated with an offsetY.
     * // This example show an element displaced vertically by 10px of defined position.
     * var positioned = new ch.Positioner({
     *     'target': document.querySelector('.target'),
     *     'reference': document.querySelector('.reference'),
     *     'side': 'top',
     *     'align': 'left',
     *     'offsetY': 10
     * });
     * @example
     * // positioned: The positioner could be configured to work with fixed or absolute position value.
     * var positioned = new ch.Positioner({
     *     'target': document.querySelector('.target'),
     *     'reference': document.querySelector('.reference'),
     *     'position': 'fixed'
     * });
     */
    function Positioner(options) {

        if (options === undefined) {
            throw new window.Error('ch.Positioner: Expected options defined.');
        }

        // Creates its private options
        this._options = tiny.clone(this._defaults);

        // Init
        this._configure(options);
    }

    /**
     * The name of the component.
     * @memberof! ch.Positioner.prototype
     * @type {String}
     */
    Positioner.prototype.name = 'positioner';

    /**
     * Returns a reference to the Constructor function that created the instance's prototype.
     * @memberof! ch.Positioner.prototype
     * @function
     * @private
     */
    Positioner.prototype._constructor = Positioner;

    /**
     * Configuration by default.
     * @type {Object}
     * @private
     */
    Positioner.prototype._defaults = {
        'offsetX': 0,
        'offsetY': 0,
        'side': 'center',
        'align': 'center',
        'reference': ch.viewport,
        'position': 'fixed'
    };

    /**
     * Configures the positioner instance with a given options.
     * @memberof! ch.Positioner.prototype
     * @function
     * @private
     * @returns {positioner}
     * @params {Object} options A configuration object.
     */
    Positioner.prototype._configure = function (options) {

        // Merge user options with its options
        tiny.extend(this._options, options);

        this._options.offsetX = parseInt(this._options.offsetX, 10);
        this._options.offsetY = parseInt(this._options.offsetY, 10);

        /**
         * Reference to the element to be positioned.
         * @type {HTMLElement}
         */
        this.target = options.target || this.target;


        /**
         * It's a reference to position and size of element that will be considered to carry out the position.
         * @type {HTMLElement}
         */
        this.reference = options.reference || this.reference;
        this._reference = this._options.reference;

        this.target.style.position = this._options.position;

        return this;
    };

    /**
     * Updates the current position with a given options
     * @memberof! ch.Positioner.prototype
     * @function
     * @returns {positioner}
     * @params {Object} options A configuration object.
     * @example
     * // Updates the current position.
     * positioned.refresh();
     * @example
     * // Updates the current position with new offsetX and offsetY.
     * positioned.refresh({
     *     'offestX': 100,
     *     'offestY': 10
     * });
     */
    Positioner.prototype.refresh = function (options) {

        if (options !== undefined) {
            this._configure(options);
        }

        if (this._reference !== ch.viewport) {
            this._calculateReference();
        }

        this._calculateTarget();

        // the object that stores the top, left reference to set to the target
        this._setPoint();

        return this;
    };

    /**
     * Calculates the reference (element or ch.viewport) of the position.
     * @memberof! ch.Positioner.prototype
     * @function
     * @private
     * @returns {positioner}
     */
    Positioner.prototype._calculateReference = function () {

        var reference = this.reference,
            offset;

        reference.setAttribute('data-side', this._options.side);
        reference.setAttribute('data-align', this._options.align);

        this._reference = this._getOuterDimensions(reference);

        if (reference.offsetParent === this.target.offsetParent) {
            this._reference.left = reference.offsetLeft;
            this._reference.top = reference.offsetTop;

        } else {
            offset = tiny.offset(reference);
            this._reference.left = offset.left;
            this._reference.top = offset.top;
        }

        return this;
    };

    /**
     * Calculates the positioned element.
     * @memberof! ch.Positioner.prototype
     * @function
     * @private
     * @returns {positioner}
     */
    Positioner.prototype._calculateTarget = function () {

        var target = this.target;
        target.setAttribute('data-side', this._options.side);
        target.setAttribute('data-align', this._options.align);

        this._target = this._getOuterDimensions(target);

        return this;
    };

    /**
     * Get the current outer dimensions of an element.
     *
     * @memberof ch.Positioner.prototype
     * @param {HTMLElement} el A given HTMLElement.
     * @returns {Object}
     */
    Positioner.prototype._getOuterDimensions = function (el) {
        var obj = el.getBoundingClientRect();

        return {
            'width': (obj.right - obj.left),
            'height': (obj.bottom - obj.top)
        };
    };

    /**
     * Calculates the points.
     * @memberof! ch.Positioner.prototype
     * @function
     * @private
     * @returns {positioner}
     */
    Positioner.prototype._setPoint = function () {
        var side = this._options.side,
            orientation = (side === 'top' || side === 'bottom') ? 'horizontal' : ((side === 'right' || side === 'left') ? 'vertical' : 'center'),
            coors,
            orientationMap;

        // take the side and calculate the alignment and make the CSSpoint
        if (orientation === 'center') {
            // calculates the coordinates related to the center side to locate the target
            coors = {
                'top': (this._reference.top + (this._reference.height / 2 - this._target.height / 2)),
                'left': (this._reference.left + (this._reference.width / 2 - this._target.width / 2))
            };

        } else if (orientation === 'horizontal') {
            // calculates the coordinates related to the top or bottom side to locate the target
            orientationMap = {
                'left': this._reference.left,
                'center': (this._reference.left + (this._reference.width / 2 - this._target.width / 2)),
                'right': (this._reference.left + this._reference.width - this._target.width),
                'top': this._reference.top - this._target.height,
                'bottom': (this._reference.top + this._reference.height)
            };

            coors = {
                'top': orientationMap[side],
                'left': orientationMap[this._options.align]
            };

        } else {
            // calculates the coordinates related to the right or left side to locate the target
            orientationMap = {
                'top': this._reference.top,
                'center': (this._reference.top + (this._reference.height / 2 - this._target.height / 2)),
                'bottom': (this._reference.top + this._reference.height - this._target.height),
                'right': (this._reference.left + this._reference.width),
                'left': (this._reference.left - this._target.width)
            };

            coors = {
                'top': orientationMap[this._options.align],
                'left': orientationMap[side]
            };
        }

        coors.top += this._options.offsetY;
        coors.left += this._options.offsetX;

        this.target.style.top = coors.top + 'px';
        this.target.style.left = coors.left + 'px';

        return this;
    };

    ch.Positioner = Positioner;

}(this, this.ch));

(function (window, ch) {
    'use strict';

    var document = window.document,
        codeMap = {
            '8': ch.onkeybackspace,
            '9': ch.onkeytab,
            '13': ch.onkeyenter,
            '27': ch.onkeyesc,
            '37': ch.onkeyleftarrow,
            '38': ch.onkeyuparrow,
            '39': ch.onkeyrightarrow,
            '40': ch.onkeydownarrow
        },

        /**
         * Shortcuts
         * @memberof ch
         * @namespace
         */
        shortcuts = {

            '_active': null,

            '_queue': [],

            '_collection': {},

            /**
             * Add a callback to a shortcut with given name.
             * @param {(ch.onkeybackspace | ch.onkeytab | ch.onkeyenter | ch.onkeyesc | ch.onkeyleftarrow | ch.onkeyuparrow | ch.onkeyrightarrow | ch.onkeydownarrow)} shortcut Shortcut to subscribe.
             * @param {String} name A name to add in the collection.
             * @param {Function} callback A given function.
             * @returns {Object} Retuns the ch.shortcuts.
             * @example
             * // Add a callback to ESC key with "component" name.
             * ch.shortcuts.add(ch.onkeyesc, 'component', component.hide);
             */
            'add': function (shortcut, name, callback) {

                if (this._collection[name] === undefined) {
                    this._collection[name] = {};
                }

                if (this._collection[name][shortcut] === undefined) {
                    this._collection[name][shortcut] = [];
                }

                this._collection[name][shortcut].push(callback);

                return this;

            },

            /**
             * Removes a callback from a shortcut with given name.
             * @param {String} name A name to remove from the collection.
             * @param {(ch.onkeybackspace | ch.onkeytab | ch.onkeyenter | ch.onkeyesc | ch.onkeyleftarrow | ch.onkeyuparrow | ch.onkeyrightarrow | ch.onkeydownarrow)} [shortcut] Shortcut to unsubscribe.
             * @param {Function} callback A given function.
             * @returns {Object} Retuns the ch.shortcuts.
             * @example
             * // Remove a callback from ESC key with "component" name.
             * ch.shortcuts.remove(ch.onkeyesc, 'component', component.hide);
             */
            'remove': function (name, shortcut, callback) {
                var evt,
                    evtCollection,
                    evtCollectionLenght;

                if (name === undefined) {
                    throw new Error('Shortcuts - "remove(name, shortcut, callback)": "name" parameter must be defined.');
                }

                if (shortcut === undefined) {
                    delete this._collection[name];
                    return this;
                }

                if (callback === undefined) {
                    delete this._collection[name][shortcut];
                    return this;
                }

                evtCollection = this._collection[name][shortcut];

                evtCollectionLenght = evtCollection.length;

                for (evt = 0; evt < evtCollectionLenght; evt += 1) {

                    if (evtCollection[evt] === callback) {
                        evtCollection.splice(evt, 1);
                    }
                }

                return this;

            },

            /**
             * Turn on shortcuts associated to a given name.
             * @param {String} name A given name from the collection.
             * @returns {Object} Retuns the ch.shortcuts.
             * @example
             * // Turn on shortcuts associated to "component" name.
             * ch.shortcuts.on('component');
             */
            'on': function (name) {
                var queueLength = this._queue.length,
                    item = queueLength - 1;

                // check if the instance exist and move the order, adds it at the las position and removes the current
                for (item; item >= 0; item -= 1) {
                    if (this._queue[item] === name) {
                        this._queue.splice(item, 1);
                    }
                }

                this._queue.push(name);
                this._active = name;

                return this;
            },

            /**
             * Turn off shortcuts associated to a given name.
             * @param {String} name A given name from the collection.
             * @returns {Object} Retuns the ch.shortcuts.
             * @example
             * // Turn off shortcuts associated to "component" name.
             * ch.shortcuts.off('component');
             */
            'off': function (name) {
                var queueLength = this._queue.length,
                    item = queueLength - 1;

                for (item; item >= 0; item -= 1) {
                    if (this._queue[item] === name) {
                        // removes the instance that I'm setting off
                        this._queue.splice(item, 1);

                        // the queue is full
                        if (this._queue.length > 0) {
                            this._active = this._queue[this._queue.length - 1];
                        } else {
                        // the queue no has elements
                            this._active = null;
                        }
                    }
                }

                return this;
            }
        },
        shortcutsEmitter = function (event) {
            var keyCode = event.keyCode.toString(),
                shortcut = codeMap[keyCode],
                callbacks,
                callbacksLenght,
                i = 0;

            if (shortcut !== undefined && shortcuts._active !== null) {
                callbacks = shortcuts._collection[shortcuts._active][shortcut];

                event.shortcut = shortcut;


                if (callbacks !== undefined) {

                    callbacksLenght = callbacks.length;

                    for (i = 0; i < callbacksLenght; i += 1) {
                        callbacks[i](event);
                    }

                }

            }
        };

    tiny.on(document, 'keydown', shortcutsEmitter);

    ch.shortcuts = shortcuts;

}(this, this.ch));

(function (window, ch) {
    'use strict';

    var uid = 0;

    /**
     * Base class for all components.
     *
     * @memberof ch
     * @constructor
     * @augments tiny.EventEmitter
     * @param {HTMLElement} [el] It must be a HTMLElement.
     * @param {Object} [options] Configuration options.
     * @returns {component} Returns a new instance of Component.
     * @example
     * // Create a new Component.
     * var component = new ch.Component();
     * var component = new ch.Component('.my-component', {'option': 'value'});
     * var component = new ch.Component('.my-component');
     * var component = new ch.Component({'option': 'value'});
     */
    function Component(el, options) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Expandable is created.
             * @memberof! ch.Expandable.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Component#ready
         * @example
         * // Subscribe to "ready" event.
         * component.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    tiny.inherits(Component, tiny.EventEmitter);

    /**
     * The name of a component.
     * @memberof! ch.Component.prototype
     * @type {String}
     */
    Component.prototype.name = 'component';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Component.prototype
     * @function
     */
    Component.prototype.constructor = Component;

    /**
     * Initialize a new instance of Component and merge custom options with defaults options.
     * @memberof! ch.Component.prototype
     * @function
     * @private
     * @returns {component}
     */
    Component.prototype._init = function (el, options) {
        // Set emitter to zero for unlimited listeners to avoid the warning in console
        // @see https://nodejs.org/api/events.html#events_emitter_setmaxlisteners_n
        this.setMaxListeners(0);

        // Clones defaults or creates a defaults object
        var defaults = (this._defaults) ? tiny.clone(this._defaults) : {};

        if (el === null) {
            throw new Error('The "el" parameter is not present in the DOM');
        }

        /**
         * A unique id to identify the instance of a component.
         * @type {Number}
         */
        this.uid = (uid += 1);

        // el is HTMLElement
        // IE8 and earlier don't define the node type constants, 1 === document.ELEMENT_NODE
        if (el !== undefined && el.nodeType !== undefined && el.nodeType === 1) {

            this._el = el;

            // set the uid to the element to help search for the instance in the collection instances
            this._el.setAttribute('data-uid', this.uid);

            // we extend defaults with options parameter
            this._options = tiny.extend(defaults, options);

        // el is an object configuration
        } else if (el === undefined || el.nodeType === undefined && typeof el === 'object') {

            // creates a empty element becouse the user not set a DOM elment to use, but we requires one
            // this._el = document.createElement('div');

            // we extend defaults with the object that is in el parameter object
            this._options = tiny.extend(defaults, el);
        }

        /**
         * Indicates if a component is enabled.
         * @type {Boolean}
         * @private
         */
        this._enabled = true;

        /**
         * Stores all instances created
         * @type {Object}
         * @public
         */
        ch.instances = ch.instances || {};
        ch.instances[this.uid] = this;
    };


    /**
     * Adds functionality or abilities from other classes.
     * @memberof! ch.Component.prototype
     * @function
     * @returns {component}
     * @params {...String} var_args The name of the abilities to will be used.
     * @example
     * // You can require some abilitiest to use in your component.
     * // For example you should require the collpasible abitliy.
     * var component = new Component(element, options);
     * component.require('Collapsible');
     */
    Component.prototype.require = function () {

        var arg,
            i = 0,
            len = arguments.length;

        for (i; i < len; i += 1) {
            arg = arguments[i];

            if (this[arg.toLowerCase()] === undefined) {
                ch[arg].call(this);
            }
        }

        return this;
    };

    /**
     * Enables an instance of Component.
     * @memberof! ch.Component.prototype
     * @function
     * @returns {component}
     * @example
     * // Enabling an instance of Component.
     * component.enable();
     */
    Component.prototype.enable = function () {
        this._enabled = true;

        /**
         * Emits when a component is enabled.
         * @event ch.Component#enable
         * @example
         * // Subscribe to "enable" event.
         * component.on('enable', function () {
         *     // Some code here!
         * });
         */
        this.emit('enable');

        return this;
    };

    /**
     * Disables an instance of Component.
     * @memberof! ch.Component.prototype
     * @function
     * @returns {component}
     * @example
     * // Disabling an instance of Component.
     * component.disable();
     */
    Component.prototype.disable = function () {
        this._enabled = false;

        /**
         * Emits when a component is disable.
         * @event ch.Component#disable
         * @example
         * // Subscribe to "disable" event.
         * component.on('disable', function () {
         *     // Some code here!
         * });
         */
        this.emit('disable');

        return this;
    };

    /**
     * Destroys an instance of Component and remove its data from asociated element.
     * @memberof! ch.Component.prototype
     * @function
     * @example
     * // Destroy a component
     * component.destroy();
     * // Empty the component reference
     * component = undefined;
     */
    Component.prototype.destroy = function () {

        this.disable();

        if (this._el !== undefined) {
            delete ch.instances[this._el.getAttribute('data-uid')];
            this._el.removeAttribute('data-uid');
        }

        /**
         * Emits when a component is destroyed.
         * @event ch.Component#destroy
         * @exampleDescription
         * @example
         * // Subscribe to "destroy" event.
         * component.on('destroy', function () {
         *     // Some code here!
         * });
         */
        this.emit('destroy');

        return;
    };

    ch.Component = Component;

}(this, this.ch));

(function (window, ch) {
    'use strict';

    /**
     * Form is a controller of DOM's HTMLFormElement.
     * @memberof ch
     * @constructor
     * @augments ch.Component
     * @requires ch.Validations
     * @param {HTMLElement} el A HTMLElement to create an instance of ch.Form.
     * @param {Object} [options] Options to customize an instance.
     * @param {Object} [options.messages] A collections of validations messages.
     * @param {String} [options.messages.required] A validation message.
     * @param {String} [options.messages.string] A validation message.
     * @param {String} [options.messages.url] A validation message.
     * @param {String} [options.messages.email] A validation message.
     * @param {String} [options.messages.maxLength] A validation message.
     * @param {String} [options.messages.minLength] A validation message.
     * @param {String} [options.messages.custom] A validation message.
     * @param {String} [options.messages.number] A validation message.
     * @param {String} [options.messages.min] A validation message.
     * @param {String} [options.messages.max] A validation message.
     * @returns {form} Returns a new instance of Form.
     * @example
     * // Create a new Form.
     * var form = new ch.Form(el, [options]);
     * @example
     * // Create a new Form with custom messages.
     * var form = new ch.Form({
     *     'messages': {
     *          'required': 'Some message!',
     *          'email': 'Another message!'
     *     }
     * });
     */
    function Form(el, options) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        that._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Form is created.
             * @memberof! ch.Form.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * It emits an event when the form is ready to use.
         * @event ch.Form#ready
         * @example
         * // Subscribe to "ready" event.
         * form.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Form, ch.Component);

    var parent = Form.super_.prototype;

    /**
     * The name of the component.
     * @memberof! ch.Form.prototype
     * @type {String}
     */
    Form.prototype.name = 'form';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Form.prototype
     * @function
     */
    Form.prototype.constructor = Form;

    /**
     * Initialize a new instance of Form and merge custom options with defaults options.
     * @memberof! ch.Form.prototype
     * @function
     * @private
     * @returns {form}
     */
    Form.prototype._init = function (el, options) {
        // Call to its parent init method
        parent._init.call(this, el, options);

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        /**
         * A collection of active errors.
         * @type {Array}
         */
        this.errors = [];

        /**
         * Collection of defined messages.
         * @type {Object}
         * @private
         */
        this._messages = this._options.messages || {};

        /**
         * A collection of validations instances.
         * @type {Array}
         */
        this.validations = [];

        /**
         * The form container.
         * @type {HTMLElement}
         */
        this.container = this._el;
            // Add classname
        tiny.addClass(this.container, 'ch-form');
            // Disable HTML5 browser-native validations
        this.container.setAttribute('novalidate', 'novalidate');
            // Bind the submit
        tiny.on(this.container, 'submit', function (event) {
            // Runs validations
            that.validate(event);
        });

        // Bind the reset
        if (this.container.querySelector('input[type="reset"]')) {
            tiny.on(this.container.querySelector('input[type="reset"]'), ch.onpointertap, function (event) {
                event.preventDefault();
                that.reset();
            });
        }
        // Stub for EventEmitter to prevent the errors throwing
        this.on('error', function(){});

        // Clean validations
        this.on('disable', this.clear);

        return this;
    };

    /**
     * Executes all validations.
     * @memberof! ch.Form.prototype
     * @function
     * @returns {form}
     */
    Form.prototype.validate = function (event) {

        if (!this._enabled) {
            return this;
        }

        /**
         * It emits an event when the form will be validated.
         * @event ch.Form#beforevalidate
         * @example
         * // Subscribe to "beforevalidate" event.
         * component.on('beforevalidate', function () {
         *     // Some code here!
         * });
         */
        this.emit('beforevalidate');

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            i = 0,
            j = that.validations.length,
            validation,
            firstError,
            firstErrorVisible,
            triggerError;

        this.errors.length = 0;

        // Run validations
        for (i; i < j; i += 1) {
            validation = that.validations[i];

            // Validate
            validation.validate();

            // Store validations with errors
            if (validation.isShown()) {
                that.errors.push(validation);
            }
        }

        // Is there's an error
        if (that.errors.length > 0) {
            firstError = that.errors[0];
            firstErrorVisible = firstError.trigger;

            // Find the closest visible parent if current element is hidden
            while (tiny.css(firstErrorVisible, 'display') === 'none' && firstErrorVisible !== document.documentElement) {
                firstErrorVisible = firstErrorVisible.parentElement;
            }

            firstErrorVisible.scrollIntoView();

            // Issue UI-332: On validation must focus the first field with errors.
            // Doc: http://wiki.ml.com/display/ux/Mensajes+de+error
            triggerError = firstError.trigger;

            if (triggerError.tagName === 'DIV') {
                firstError.trigger.querySelector('input:first-child').focus();
            }

            if (triggerError.type !== 'hidden' || triggerError.tagName === 'SELECT') {
                triggerError.focus();
            }

            if (event && event.preventDefault) {
                event.preventDefault();
            }

            /**
             * It emits an event when a form has got errors.
             * @event ch.Form#error
             * @example
             * // Subscribe to "error" event.
             * form.on('error', function (errors) {
             *     console.log(errors.length);
             * });
             */
            this.emit('error', this.errors);

        } else {

            /**
             * It emits an event when a form hasn't got errors.
             * @event ch.Form#success
             * @example
             * // Subscribe to "success" event.
             * form.on("submit",function () {
             *     // Some code here!
             * });
             * @example
             * // Subscribe to "success" event and prevent the submit event.
             * form.on("submit",function (event) {
             *     event.preventDefault();
             *     // Some code here!
             * });
             */
            this.emit('success', event);
        }

        return this;
    };

    /**
     * Checks if the form has got errors but it doesn't show bubbles.
     * @memberof! ch.Form.prototype
     * @function
     * @returns {Boolean}
     * @example
     * // Checks if a form has errors and do something.
     * if (form.hasError()) {
     *     // Some code here!
     * };
     */
    Form.prototype.hasError = function () {

        if (!this._enabled) {
            return false;
        }

        this.errors.length = 0;

        var i = 0,
            j = this.validations.length,
            validation;

        // Run hasError
        for (i; i < j; i += 1) {

            validation = this.validations[i];

            if (validation.hasError()) {
                this.errors.push(validation);
            }

        }

        return this.errors.length > 0;
    };

    /**
     * Clear all active errors.
     * @memberof! ch.Form.prototype
     * @function
     * @returns {form}
     * @example
     * // Clear active errors.
     * form.clear();
     */
    Form.prototype.clear = function () {
        var i = 0,
            j = this.validations.length;

        for (i; i < j; i += 1) {
            this.validations[i].clear();
        }

        /**
         * It emits an event when the form is cleaned.
         * @event ch.Form#clear
         * @example
         * // Subscribe to "clear" event.
         * form.on('clear', function () {
         *     // Some code here!
         * });
         */
        this.emit('clear');

        return this;
    };

    /**
     * Clear all active errors and executes the reset() native mehtod.
     * @memberof! ch.Form.prototype
     * @function
     * @returns {form}
     * @example
     * // Resets form fields and clears active errors.
     * form.reset();
     */
    Form.prototype.reset = function () {

        // Clears all shown validations
        this.clear();

        // Executes the native reset() method
        this._el.reset();

        /**
         * It emits an event when a form resets its fields.
         * @event ch.Form#reset
         * @example
         * // Subscribe to "reset" event.
         * form.on('reset', function () {
         *     // Some code here!
         * });
         */
        this.emit('reset');

        return this;
    };

    /**
     * Destroys a Form instance.
     * @memberof! ch.Form.prototype
     * @function
     * @example
     * // Destroy a form
     * form.destroy();
     * // Empty the form reference
     * form = undefined;
     */
    Form.prototype.destroy = function () {

        // this.$container.off('.form')
        this.container.removeAttribute('novalidate');

        this.validations.forEach(function (e) {
            e.destroy();
        });

        parent.destroy.call(this);

        return;
    };

    // Factorize
    ch.factory(Form);

}(this, this.ch));

(function (ch) {
    'use strict';

    // Private Members
    var conditions = {
        'string': {
            'fn': function (value) {
                // the following regular expression has the utf code for the lating characters
                // the ranges are A,EI,O,U,a,ei,o,u,ç,Ç please for reference see http://www.fileformat.info/info/charset/UTF-8/list.htm
                return (/^([a-zA-Z\u00C0-\u00C4\u00C8-\u00CF\u00D2-\u00D6\u00D9-\u00DC\u00E0-\u00E4\u00E8-\u00EF\u00F2-\u00F6\u00E9-\u00FC\u00C7\u00E7\s]*)$/i).test(value);
            },
            'message': 'Use only letters.'
        },
        'email': {
            'fn': function (value) {
                return (/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/).test(value);
            },
            'message': 'Use a valid e-mail such as name@example.com.'
        },
        'url': {
            'fn': function (value) {
                return (/^((https?|ftp|file):\/\/|((www|ftp)\.)|(\/|.*\/)*)[a-z0-9-]+((\.|\/)[a-z0-9-]+)+([/?].*)?$/i).test(value);
            },
            'message': 'It must be a valid URL.'
        },
        'minLength': {
            'fn': function (a, b) { return a.length >= b; },
            'message': 'Enter at least {#num#} characters.'
        },
        'maxLength': {
            'fn': function (a, b) { return a.length <= b; },
            'message': 'The maximum amount of characters is {#num#}.'
        },
        'number': {
            'fn': function (value) {
                return (/^(-?[0-9]+)$/i).test(value);
            },
            'message': 'Use only numbers.'
        },
        'max': {
            'fn': function (a, b) { return a <= b; },
            'message': 'The amount must be smaller than {#num#}.'
        },
        'min': {
            'fn': function (a, b) { return a >= b; },
            'message': 'The amount must be higher than {#num#}.'
        },
        'required': {
            'fn': function (value) {

                var tag = tiny.hasClass(this.trigger, 'ch-form-options') ? 'OPTIONS' : this._el.tagName,
                    validated;

                switch (tag) {
                case 'OPTIONS':
                    validated = this.trigger.querySelectorAll('input:checked').length !== 0;
                    break;

                case 'SELECT':
                    validated = (value !== '-1' && value !== '');
                    break;

                // INPUTS and TEXTAREAS
                default:
                    validated = value.replace(/^\s+|\s+$/g, '').length !== 0;
                    break;
                }

                return validated;
            },
            'message': 'Fill in this information.'
        },
        'custom': {
            // I don't have pre-conditions, comes within conf.fn argument
            'message': 'Error'
        }
    };

    /**
     * Condition utility.
     * @memberof ch
     * @constructor
     * @requires ch.Validation
     * @param {Array} [condition] A conditions to validate.
     * @param {String} [condition.name] The name of the condition.
     * @param {String} [condition.message] The given error message to the condition.
     * @param {String} [condition.fn] The method to validate a given condition.
     * @returns {condition} Returns a new instance of Condition.
     * @example
     * // Create a new condition object with patt.
     * var condition = ch.Condition({
     *     'name': 'string',
     *     'patt': /^([a-zA-Z\u00C0-\u00C4\u00C8-\u00CF\u00D2-\u00D6\u00D9-\u00DC\u00E0-\u00E4\u00E8-\u00EF\u00F2-\u00F6\u00E9-\u00FC\u00C7\u00E7\s]*)$/,
     *     'message': 'Some message here!'
     * });
     * @example
     * //Create a new condition object with expr.
     * var condition = ch.Condition({
     *     'name': 'maxLength',
     *     'patt': function(a,b) { return a.length <= b },
     *     'message': 'Some message here!',
     *     'value': 4
     * });
     * @example
     * // Create a new condition object with func.
     * var condition = ch.Condition({
     *     'name': 'custom',
     *     'patt': function (value) {
     *         if (value === 'ChicoUI') {
     *
     *             // Some code here!
     *
     *             return true;
     *         };
     *
     *         return false;
     *     },
     *     'message': 'Your message here!'
     * });
     */
    function Condition(condition) {

        tiny.extend(this, conditions[condition.name], condition);

        // replaces the condition default message in the following conditions max, min, minLenght, maxLenght
        if (this.name === 'min' || this.name === 'max' || this.name === 'minLength' || this.name === 'maxLength') {
            this.message = this.message.replace('{#num#}', this.num);
        }

        this._enabled = true;

        return this;
    }

    /**
     * The name of the component.
     * @memberof! ch.Condition.prototype
     * @type {String}
     */
    Condition.prototype.name = 'condition';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Condition.prototype
     * @function
     */
    Condition.prototype.constructor = Condition;

    /**
     * Enables an instance of condition.
     * @memberof! ch.Condition.prototype
     * @function
     * @returns {condition}
     * @example
     * // Enabling an instance of Condition.
     * condition.enable();
     * @example
     * // Enabling a condition.
     * condition.enable();
     */
    Condition.prototype.enable = function () {
        this._enabled = true;

        return this;
    };

    /**
     * Disables an instance of a condition.
     * @memberof! ch.Condition.prototype
     * @function
     * @returns {condition}
     * @example
     * // Disabling an instance of Condition.
     * condition.disable();
     * @example
     * // Disabling a condition.
     * condition.disable();
     */
    Condition.prototype.disable = function () {
        this._enabled = false;

        return this;
    };

    /**
     * Enables an instance of condition.
     * @memberof! ch.Condition.prototype
     * @function
     * @param {(String | Number)} value A given value.
     * @param {condition} validation A given validation to execute.
     * @returns {Boolean} Returns a boolean indicating whether the condition fails or not.
     * @example
     * // Testing a condition.
     * condition.test('foobar', validationA);
     */
    Condition.prototype.test = function (value, validation) {

        if (!this._enabled) {
            return true;
        }

        return this.fn.call(validation, value, this.num);
    };

    ch.Condition = Condition;

}(this.ch));

(function (window, ch) {
    'use strict';

    /**
     * Validation is an engine to validate HTML forms elements.
     * @memberof ch
     * @constructor
     * @augments ch.Component
     * @requires ch.Condition
     * @requires ch.Form
     * @requires ch.Bubble
     * @param {HTMLElement} el A HTMLElement to create an instance of ch.Validation.
     * @param {Object} [options] Options to customize an instance.
     * @param {Array} [options.conditions] A collection of conditions to validate.
     * @param {String} [options.conditions.name] The name of the condition.
     * @param {String} [options.conditions.message] The given error message to the condition.
     * @param {String} [options.conditions.fn] The method to validate a given condition.
     * @param {HTMLElement} [options.reference] It's a reference to position and size of element that will be considered to carry out the position.
     * @param {String} [options.side] The side option where the target element will be positioned. Default: "right".
     * @param {String} [options.align] The align options where the target element will be positioned. Default: "top".
     * @param {Number} [options.offsetX] Distance to displace the target horizontally. Default: 10.
     * @param {Number} [options.offsetY] Distance to displace the target vertically. Default: 0.
     * @param {String} [options.position] The type of positioning used. Default: "absolute".
     * @returns {validation} Returns a new instance of Validation.
     * @example
     * // Create a new Validation.
     * var validation = new ch.Validation(document.querySelector('.name-field'), [options]);
     * @example
     * // Create a validation with with custom options.
     * var validation = new ch.Validation({
     *     'conditions': [
     *         {
     *             'name': 'required',
     *             'message': 'Please, fill in this information.'
     *         },
     *         {
     *             'name': 'custom-email',
     *             'fn': function (value) { return value === "customail@custom.com"; },
     *             'message': 'Use a valid e-mail such as name@custom.com.'
     *         }
     *     ],
     *     'offsetX': 0,
     *     'offsetY': 10,
     *     'side': 'bottom',
     *     'align': 'left'
     * });
     */
    function Validation(el, options) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Validation is created.
             * @memberof! ch.Validation.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Validation#ready
         * @example
         * // Subscribe to "ready" event.
         * validation.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Validation, ch.Component);

    var parent = Validation.super_.prototype,
        // Creates methods enable and disable into the prototype.
        methods = ['enable', 'disable'],
        len = methods.length;

    function createMethods(method) {
        Validation.prototype[method] = function (condition) {
            var key;

            // Specific condition
            if (condition !== undefined && this.conditions[condition] !== undefined) {

                this.conditions[condition][method]();

            } else {

                // all conditions
                for (key in this.conditions) {
                    if (this.conditions[key] !== undefined) {
                        this.conditions[key][method]();
                    }
                }

                parent[method].call(this);
            }

            return this;
        };
    }

    /**
     * The name of the component.
     * @memberof! ch.Validation.prototype
     * @type {String}
     */
    Validation.prototype.name = 'validation';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Validation.prototype
     * @function
     */
    Validation.prototype.constructor = Validation;

    /**
     * Configuration by default.
     * @type {Object}
     * @private
     */
    Validation.prototype._defaults = {
        'offsetX': 10
    };

    /**
     * Initialize a new instance of Validation and merge custom options with defaults options.
     * @memberof! ch.Validation.prototype
     * @function
     * @private
     * @returns {validation}
     */
    Validation.prototype._init = function (el, options) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        parent._init.call(this, el, options);

        /**
         * The validation trigger.
         * @type {HTMLElement}
         */
        this.trigger = this._el;

        /**
         * The validation container.
         * @type {HTMLElement}
         */
        this._configureContainer();

        /**
         * The collection of conditions.
         * @type {Object}
         */
        this.conditions = {};

        // Merge conditions
        this._mergeConditions(options.conditions);

        /**
         * Flag that let you know if there's a validation going on.
         * @type {Boolean}
         * @private
         */
        this._shown = false;

        /**
         * The current error. If the validations has not error is "null".
         * @type {Object}
         */
        this.error = null;

        this
            // Clean the validation if is shown;
            .on('disable', this.clear);

        this.on('error', this._handleError);

        /**
         * Reference to a Form instance. If there isn't any, the Validation instance will create one.
         * @type {form}
         */
        this.form = (ch.instances[tiny.parent(that.trigger, 'form').getAttribute('data-uid')] || new ch.Form(tiny.parent(that.trigger, 'form')));

        this.form.validations.push(this);

        /**
         * Set a validation event to add listeners.
         * @private
         */
        this._validationEvent = (tiny.hasClass(this.trigger, 'ch-form-options') || this._el.tagName === 'SELECT' || (this._el.tagName === 'INPUT' && this._el.type === 'range')) ? 'change' : 'blur';

        return this;
    };

    /**
     * Merges the collection of conditions with a given conditions.
     * @function
     * @private
     */
    Validation.prototype._mergeConditions = function (conditions) {
        var i = 0,
            j = conditions.length;

        for (i; i < j; i += 1) {
            this.conditions[conditions[i].name] = new ch.Condition(conditions[i]);
        }

        return this;
    };

    /**
     * Validates the value of $el.
     * @memberof! ch.Validation.prototype
     * @function
     * @returns {validation}
     */
    Validation.prototype.validate = function () {

        if (this.hasError()) {
            this._error();
        } else {
            this._success();
        }

        return this;
    };

    /**
     * If the validation has got an error executes this function.
     * @private
     */
    Validation.prototype._error = function () {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            previousValue;

        // It must happen only once.
        tiny.on(this.trigger, this._validationEvent, function () {

            if (previousValue !== this.value || that._validationEvent === 'change' && that.isShown()) {
                previousValue = this.value;
                that.validate();
            }

            if (that.conditions.required === undefined && this.value === '') {
                that.clear();
            }

        });

        /**
         * It emits an error event when a validation got an error.
         * @event ch.Validation#error
         *
         * @example
         * // Subscribe to "error" event.
         * validation.on('error', function (errors) {
         *     console.log(errors.length);
         * });
         */
        this.emit('error', this.error);

        return this;
    };

    /**
     * Internal error handler, shows the errors when needed
     *
     * @param err {Object} A ch.Validation#error object that contain the error message and the error condition
     * @private
     */
    Validation.prototype._handleError = function(err) {
        var that = this;

        if (!that._previousError.condition || !that._shown) {
            if (that._el.nodeName === 'INPUT' || that._el.nodeName === 'TEXTAREA') {
                tiny.addClass(that.trigger, 'ch-validation-error');
            }

            that._showErrorMessage(err.message || 'Error');
        }

        if (err.condition !== that._previousError.condition) {
            that._showErrorMessage(err.message || that.form._messages[err.condition] || 'Error');
        }

        that._shown = true;
    };

    /**
     * If the validation hasn't got an error executes this function.
     * @private
     */
    Validation.prototype._success = function () {

        // Status OK (with previous error) this._previousError
        if (this._shown || !this._enabled) {
            // Public status OK
            this._shown = false;
        }

        this.trigger.removeAttribute('aria-label');
        tiny.removeClass(this.trigger, 'ch-validation-error');


        this._hideErrorMessage();

        /**
         * It emits an event when a validation hasn't got an error.
         * @event ch.Validation#success
         * @example
         * // Subscribe to "success" event.
         * validation.on("submit",function () {
         *     // Some code here!
         * });
         */
        this.emit('success');

        return this;
    };

    /**
     * Checks if the validation has got errors but it doesn't show bubbles.
     * @memberof! ch.Validation.prototype
     * @function
     * @returns {Boolean}
     * @example
     * // Checks if a validation has errors and do something.
     * if (validation.hasError()) {
     *     // Some code here!
     * };
     */
    Validation.prototype.hasError = function () {

        // Pre-validation: Don't validate disabled
        if (this.trigger.getAttribute('disabled') || !this._enabled) {
            return false;
        }

        var condition,
            required = this.conditions.required,
            value = this._el.value;

        // Avoid fields that aren't required when they are empty or de-activated
        if (!required && value === '' && this._shown === false) {
            // Has got an error? Nop
            return false;
        }

        /**
         * Stores the previous error object
         * @private
         */
        this._previousError = tiny.clone(this.error);

        // for each condition
        for (condition in this.conditions) {

            if (this.conditions[condition] !== undefined && !this.conditions[condition].test(value, this)) {
                // Update the error object
                this.error = {
                    'condition': condition,
                    'message': this.conditions[condition].message
                };

                // Has got an error? Yeah
                return true;
            }

        }

        // Update the error object
        this.error = null;

        // Has got an error? No
        return false;
    };

    /**
     * Clear active error.
     * @memberof! ch.Validation.prototype
     * @function
     * @returns {validation}
     * @example
     * // Clear active error.
     * validation.clear();
     */
    Validation.prototype.clear = function () {

        this.trigger.removeAttribute('aria-label');
        tiny.removeClass(this.trigger, 'ch-validation-error');

        this.error = null;

        this._hideErrorMessage();

        this._shown = false;

        /**
         * It emits an event when a validation is cleaned.
         * @event ch.Validation#clear
         * @example
         * // Subscribe to "clear" event.
         * validation.on('clear', function () {
         *     // Some code here!
         * });
         */
        this.emit('clear');

        return this;
    };

    /**
     * Indicates if the validation is shown.
     * @memberof! ch.Validation.prototype
     * @function
     * @returns {Boolean}
     * @example
     * // Execute a function if the validation is shown.
     * if (validation.isShown()) {
     *     fn();
     * }
     */
    Validation.prototype.isShown = function () {
        return this._shown;
    };

    /**
     * Sets or gets messages to specifics conditions.
     * @memberof! ch.Validation.prototype
     * @function
     * @returns {(validation | String)}
     * @example
     * // Gets a message from a condition
     * validation.message('required');
     * @example
     * // Sets a new message
     * validation.message('required', 'New message for required validation');
     */
    Validation.prototype.message = function (condition, message) {

        if (condition === undefined) {
            throw new Error('validation.message(condition, message): Please, a condition parameter is required.');
        }

        // Get a new message from a condition
        if (message === undefined) {
            return this.conditions[condition].message;
        }

        // Sets a new message
        this.conditions[condition].message = message;

        if (this.isShown() && this.error.condition === condition) {
            this._showErrorMessage(message);
        }

        return this;
    };

    /**
     * Enables an instance of validation or a specific condition.
     * @memberof! ch.Validation.prototype
     * @name enable
     * @function
     * @param {String} [condition] - A given number of fold to enable.
     * @returns {validation} Returns an instance of Validation.
     * @example
     * // Enabling an instance of Validation.
     * validation.enable();
     * @example
     * // Enabling the "max" condition.
     * validation.enable('max');
     */

    /**
     * Disables an instance of a validation or a specific condition.
     * @memberof! ch.Validation.prototype
     * @name disable
     * @function
     * @param {String} [condition] - A given number of fold to disable.
     * @returns {validation} Returns an instance of Validation.
     * @example
     * // Disabling an instance of Validation.
     * validation.disable();
     * @example
     * // Disabling the "email" condition.
     * validation.disable('email');
     */
    while (len) {
        createMethods(methods[len -= 1]);
    }

    /**
     * Destroys a Validation instance.
     * @memberof! ch.Validation.prototype
     * @function
     * @example
     * // Destroying an instance of Validation.
     * validation.destroy();
     */
    Validation.prototype.destroy = function () {

        // this.$trigger.off('.validation')
        this.trigger.removeAttribute('data-side data-align');

        parent.destroy.call(this);

        return;
    };

    // Factorize
    ch.factory(Validation);

}(this, this.ch));

(function (ch) {
    'use strict';

    /**
     * Creates a bubble to show the validation message.
     * @memberof! ch.Validation.prototype
     * @function
     * @private
     * @returns {validation}
     */
    ch.Validation.prototype._configureContainer = function () {

        var that = this;

        /**
         * Is the little sign that popover showing the validation message. It's a Popover component, so you can change it's content, width or height and change its visibility state.
         * @type {Bubble}
         * @see ch.Bubble
         */
        this.bubble = this._container = new ch.Bubble({
            'reference': that._options.reference || (function () {
                var reference,
                    trigger = that.trigger,
                    h4,
                    span;
                // CHECKBOX, RADIO
                // TODO: when old forms be deprecated we must only support ch-form-options class
                if (tiny.hasClass(trigger, 'ch-form-options')) {
                // Helper reference from will be fired
                    if (trigger.querySelectorAll('h4').length > 0) {
                        // Wrap content with inline element
                        h4 = trigger.querySelector('h4'); // Find h4
                        span = document.createElement('span');
                        span.insertAdjacentHTML('beforeend', h4.innerHTML);
                        h4.innerHTML = '';
                        h4.insertBefore(span, h4.firstChild);
                        reference = h4.children[0]; // Inline element in h4 like helper reference
                    // Legend
                    } else if (trigger.previousElementSibling && trigger.previousElementSibling.tagName === 'LEGEND') {
                        reference = trigger.previousElementSibling; // Legend like helper reference
                    } else {
                        reference = trigger.querySelector('label');
                    }
                // INPUT, SELECT, TEXTAREA
                } else {
                    reference = trigger;
                }

                return reference;
            }()),
            'align': that._options.align,
            'side': that._options.side,
            'offsetY': that._options.offsetY,
            'offsetX': that._options.offsetX
            // 'position': that._options.position
        });

    };

    /**
     * Shows the validation message.
     * @memberof! ch.Validation.prototype
     * @function
     * @private
     * @returns {validation}
     */
    ch.Validation.prototype._showErrorMessage = function (message) {
        this.bubble.content(message).show();
        this.trigger.setAttribute('aria-label', 'ch-' + this.bubble.name + '-' + this.bubble.uid);

        return this;
    };

    /**
     * Hides the validation message.
     * @memberof! ch.Validation.prototype
     * @function
     * @private
     * @returns {validation}
     */
    ch.Validation.prototype._hideErrorMessage = function () {
        this.bubble.hide();
        this.trigger.removeAttribute('aria-label');

        return this;
    };

    /**
     * Sets or gets positioning configuration. Use it without arguments to get actual configuration. Pass an argument to define a new positioning configuration.
     * @memberof! ch.Validation.prototype
     * @function
     * @returns {validation}
     * @example
     * // Change validaton bubble's position.
     * validation.refreshPosition({
     *     offsetY: -10,
     *     side: 'top',
     *     align: 'left'
     * });
     */
    ch.Validation.prototype.refreshPosition = function (options) {

        if (options === undefined) {
            return this.bubble._position;
        }

        this.bubble.refreshPosition(options);

        return this;
    };

}(this.ch));

(function (window, ch) {
    'use strict';

    function normalizeOptions(options) {
        if (typeof options === 'string' || options instanceof HTMLElement) {
            options = {
                'content': options
            };
        }
        return options;
    }

    /**
     * Expandable lets you show or hide content. Expandable needs a pair: a title and a container related to title.
     * @memberof ch
     * @constructor
     * @augments ch.Component
     * @mixes ch.Collapsible
     * @mixes ch.Content
     * @param {HTMLElement} el A HTMLElement to create an instance of ch.Expandable.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.fx] Enable or disable UI effects. You must use: "slideDown", "fadeIn" or "none". Default: "none".
     * @param {Boolean} [options.toggle] Customize toggle behavior. Default: true.
     * @param {HTMLElement} [options.container] The container where the expanbdale puts its content. Default: the next sibling of el parameter.
     * @param {(String | HTMLElement)} [options.content] The content to be shown into the expandable container.
     * @returns {expandable} Returns a new instance of Expandable.
     * @example
     * // Create a new Expandable.
     * var expandable = new ch.Expandable([el], [options]);
     * @example
     * // Create a new Expandable with custom options.
     * var expandable = new ch.Expandable({
     *     'container': document.querySelector('.my-container'),
     *     'toggle': false,
     *     'fx': 'slideDown',
     *     'content': 'http://ui.ml.com:3040/ajax'
     * });
     * @example
     * // Create a new Expandable using the shorthand way (content as parameter).
     * var expandable = new ch.Expandable('http://ui.ml.com:3040/ajax');
     */
    function Expandable(el, options) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Expandable is created.
             * @memberof! ch.Expandable.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Expandable#ready
         * @example
         * // Subscribe to "ready" event.
         * expandable.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Expandable, ch.Component);

    var parent = Expandable.super_.prototype;

    /**
     * The name of the component.
     * @memberof! ch.Expandable.prototype
     * @type {String}
     */
    Expandable.prototype.name = 'expandable';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Expandable.prototype
     * @function
     */
    Expandable.prototype.constructor = Expandable;

    /**
     * Configuration by default.
     * @type {Object}
     * @private
     */
    Expandable.prototype._defaults = {
        '_classNameTrigger': 'ch-expandable-trigger',
        '_classNameIcon': 'ch-expandable-ico',
        '_classNameContainer': 'ch-expandable-container',
        'fx': false,
        'toggle': true
    };

    /**
     * Initialize a new instance of Expandable and merge custom options with defaults options.
     * @memberof! ch.Expandable.prototype
     * @function
     * @private
     * @returns {expandable}
     */
    Expandable.prototype._init = function (el, options) {
        // Call to its parent init method
        parent._init.call(this, el, options);

        // Requires abilities
        this.require('Collapsible', 'Content');

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        /**
         * The expandable trigger.
         * @type {HTMLElement}
         * @example
         * // Gets the expandable trigger.
         * expandable.trigger;
         */
        this.trigger = this._el;
        tiny.addClass(this.trigger, this._options._classNameTrigger);
        tiny.addClass(this.trigger, this._options._classNameIcon);

        if (navigator.pointerEnabled) {
            tiny.on(this._el, 'click', function(e) {
                if (e.target.tagName === 'A') {
                    e.preventDefault();
                }
            });
        }

        tiny.on(this.trigger, ch.onpointertap, function (event) {
            if (ch.pointerCanceled) {
                return;
            }

            event.preventDefault();

            if (that._options.toggle) {
                that._toggle();
            } else {
                that.show();
            }
        });

        /**
         * The expandable container.
         * @type {HTMLElement}
         * @example
         * // Gets the expandable container.
         * expandable.container;
         */
        this.container = this._content = (this._options.container ?
            this._options.container : tiny.next(this._el));
        tiny.addClass(this.container, this._options._classNameContainer);
        tiny.addClass(this.container, 'ch-hide');
        if (tiny.support.transition && this._options.fx !== 'none' && this._options.fx !== false) {
            tiny.addClass(this.container, 'ch-fx');
        }
        this.container.setAttribute('aria-expanded', 'false');

        /**
         * Default behavior
         */
        if (this.container.getAttribute('id') === '') {
            this.container.setAttribute('id', 'ch-expandable-' + this.uid);
        }

        this.trigger.setAttribute('aria-controls', this.container.getAttribute('id'));

        this
            .on('show', function () {
                tiny.trigger(window.document, ch.onlayoutchange);
            })
            .on('hide', function () {
                tiny.trigger(window.document, ch.onlayoutchange);
            });

        this.trigger.setAttribute('unselectable', 'on');
        tiny.addClass(this.trigger, 'ch-user-no-select');

        return this;
    };

    /**
     * Shows expandable's content.
     * @memberof! ch.Expandable.prototype
     * @function
     * @param {(String | HTMLElement)} [content] The content that will be used by expandable.
     * @param {Object} [options] A custom options to be used with content loaded by ajax.
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading.
     * @returns {expandable}
     * @example
     * // Shows a basic expandable.
     * component.show();
     * @example
     * // Shows an expandable with new content.
     * component.show('Some new content here!');
     * @example
     * // Shows an expandable with a new content that will be loaded by ajax and some custom options.
     * component.show('http://chico-ui.com.ar/ajax', {
     *     'cache': false,
     *     'params': 'x-request=true'
     * });
     */
    Expandable.prototype.show = function (content, options) {

        if (!this._enabled) {
            return this;
        }

        this._show();

        // Update ARIA
        this.container.setAttribute('aria-expanded', 'true');

        // Set new content
        if (content !== undefined) {
            this.content(content, options);
        }

        return this;
    };

    /**
     * Hides component's container.
     * @memberof! ch.Expandable.prototype
     * @function
     * @returns {expandable}
     * @example
     * // Close an expandable.
     * expandable.hide();
     */
    Expandable.prototype.hide = function () {

        if (!this._enabled) {
            return this;
        }

        this._hide();

        this.container.setAttribute('aria-expanded', 'false');

        return this;
    };


    /**
     * Returns a Boolean specifying if the component's core behavior is shown. That means it will return 'true' if the component is on, and it will return false otherwise.
     * @memberof! ch.Expandable.prototype
     * @function
     * @returns {Boolean}
     * @example
     * // Execute a function if the component is shown.
     * if (expandable.isShown()) {
     *     fn();
     * }
     */
    Expandable.prototype.isShown = function () {
        return this._shown;
    };

    /**
     * Destroys an Expandable instance.
     * @memberof! ch.Expandable.prototype
     * @function
     * @example
     * // Destroy an expandable
     * expandable.destroy();
     * // Empty the expandable reference
     * expandable = undefined;
     */
    Expandable.prototype.destroy = function () {
        var trigger = this.trigger;

        [
            'ch-expandable-trigger',
            'ch-expandable-ico',
            'ch-user-no-select'
        ].forEach(function(className){
            tiny.removeClass(trigger, className);
        });

        this.trigger.removeAttribute('unselectable');
        this.trigger.removeAttribute('aria-controls');
        tiny.removeClass(this.container, 'ch-expandable-container');
        tiny.removeClass(this.container, 'ch-hide');
        this.container.removeAttribute('aria-expanded');
        this.container.removeAttribute('aria-hidden');

        tiny.trigger(window.document, ch.onlayoutchange);

        parent.destroy.call(this);

        return;
    };

    // Factorize
    ch.factory(Expandable, normalizeOptions);

}(this, this.ch));

(function (window, ch) {
    'use strict';

    /**
     * Menu lets you organize the links by categories.
     * @memberof ch
     * @constructor
     * @augments ch.Component
     * @requires ch.Expandable
     * @param {HTMLElement} el A HTMLElement to create an instance of ch.Menu.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.fx] Enable or disable UI effects. You should use: "slideDown", "fadeIn" or "none". Default: "slideDown".
     * @returns {menu} Returns a new instance of Menu.
     * @example
     * // Create a new Menu.
     * var menu = new ch.Menu(el, [options]);
     * @example
     * // Create a new Menu with custom options.
     * var menu = new ch.Menu({
     *     'fx': 'none'
     * });
     */
    function Menu(el, options) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        that._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Menu is created.
             * @memberof! ch.Menu.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Menu#ready
         * @example
         * // Subscribe to "ready" event.
         * menu.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Menu, ch.Component);

    var parent = Menu.super_.prototype,

        // Creates methods enable and disable into the prototype.
        methods = ['enable', 'disable'],
        len = methods.length;

    function createMethods(method) {
        Menu.prototype[method] = function (child) {
            var i,
                fold = this.folds[child - 1];

            // Enables or disables a specific expandable fold
            if (fold && fold.name === 'expandable') {

                fold[method]();

            // Enables or disables Expandable folds
            } else {

                i = this.folds.length;

                while (i) {

                    fold = this.folds[i -= 1];

                    if (fold.name === 'expandable') {
                        fold[method]();
                    }
                }

                // Executes parent method
                parent[method].call(this);

                // Updates "aria-disabled" attribute
                this._el.setAttribute('aria-disabled', !this._enabled);
            }

            return this;
        };
    }

    /**
     * The name of the component.
     * @memberof! ch.Menu.prototype
     * @type {String}
     */
    Menu.prototype.name = 'menu';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Menu.prototype
     * @function
     */
    Menu.prototype.constructor = Menu;

    /**
     * Configuration by default.
     * @type {Object}
     * @private
     */
    Menu.prototype._defaults = {
        'fx': 'slideDown'
    };

    /**
     * Initialize a new instance of Menu and merge custom options with defaults options.
     * @memberof! ch.Menu.prototype
     * @function
     * @private
     * @returns {menu}
     */
    Menu.prototype._init = function (el, options) {
        // Call to its parent init method
        parent._init.call(this, el, options);

        // cloneNode(true) > parameters is required. Opera & IE throws and internal error. Opera mobile breaks.
        this._snippet = this._el.cloneNode(true);

        /**
         * The menu container.
         * @type {HTMLElement}
         */
        this.container = this._el;
        this.container.setAttribute('role', 'navigation');
        tiny.addClass(this.container, 'ch-menu');

        this._options._className ? tiny.addClass(this.container, this._options._className) : null;
        this._options.addClass ? tiny.addClass(this.container, this._options.addClass) : null;

        /**
         * A collection of folds.
         * @type {Array}
         */
        this.folds = [];

        // Inits an expandable component on each list inside main HTML code snippet
        this._createExpandables();

        return this;
    };

    /**
     * Inits an Expandable component on each list inside main HTML code snippet.
     * @function
     * @private
     */
    Menu.prototype._createExpandables = function () {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            child;

        function createExpandable(li, i) {
            var expandable,
                menu;

            // List element
            tiny.addClass(li, 'ch-menu-fold');

            // Children of list elements
            child = li.children[0];

            // Anchor inside list
            if (child.tagName === 'A') {
                // Add attr role to match wai-aria
                li.setAttribute('role', 'presentation');
                //
                tiny.addClass(child, 'ch-fold-trigger');
                // Add anchor to that.fold
                that.folds.push(child);

            } else {
                // List inside list, inits an Expandable
                expandable = new ch.Expandable(child, {
                    // Show/hide on IE8- instead slideUp/slideDown
                    'fx': that._options.fx
                });

                expandable
                    .on('show', function () {
                        /**
                         * Event emitted when the menu shows a fold.
                         * @event ch.Menu#show
                         * @example
                         * // Subscribe to "show" event.
                         * menu.on('show', function (shown) {
                         *     // Some code here!
                         * });
                         */
                        that.emit('show', i + 1);
                    })
                    .on('hide', function () {
                        /**
                         * Event emitted when the menu hides a fold.
                         * @event ch.Menu#hide
                         * @example
                         * // Subscribe to "hide" event.
                         * menu.on('hide', function () {
                         *     // Some code here!
                         * });
                         */
                        that.emit('hide');
                    });

                menu = tiny.next(child);
                menu.setAttribute('role', 'menu');

                Array.prototype.forEach.call(menu.children, function (item){
                    item.setAttribute('role', 'presentation');
                    item.children[0] ? item.children[0].setAttribute('role', 'menuitem') : null;
                });

                // Add expandable to that.fold
                that.folds.push(expandable);
            }
        }

        Array.prototype.forEach.call(this.container.children, createExpandable);

        return this;
    };

    /**
     * Shows a specific fold.
     * @memberof! ch.Menu.prototype
     * @function
     * @param {Number} child - A given number of fold.
     * @returns {menu}
     * @example
     * // Shows the second fold.
     * menu.show(2);
     */
    Menu.prototype.show = function (child) {

        this.folds[child - 1].show();

        return this;
    };

    /**
     * Hides a specific fold.
     * @memberof! ch.Menu.prototype
     * @function
     * @param {Number} child - A given number of fold.
     * @returns {menu}
     * @example
     * // Hides the second fold.
     * menu.hide(2);
     */
    Menu.prototype.hide = function (child) {

        this.folds[child - 1].hide();

        return this;
    };

    /**
     * Allows to manage the menu content.
     * @param {Number} fold A given fold to change its content.
     * @param {(String | HTMLElement)} content The content that will be used by a fold.
     * @param {Object} [options] A custom options to be used with content loaded by ajax.
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading.
     * @example
     * // Updates the content of the second fold with some string.
     * menu.content(2, 'http://ajax.com', {'cache': false});
     */
    Menu.prototype.content = function (fold, content, options) {
        if (fold === undefined || typeof fold !== 'number') {
            throw new window.Error('Menu.content(fold, content, options): Expected number of fold.');
        }

        if (content === undefined) {
            return this.folds[fold - 1].content();
        }

        this.folds[fold - 1].content(content, options);

        return this;
    };

    while (len) {
        createMethods(methods[len -= 1]);
    }

    /**
     * Destroys a Menu instance.
     * @memberof! ch.Menu.prototype
     * @function
     * @example
     * // Destroy a menu
     * menu.destroy();
     * // Empty the menu reference
     * menu = undefined;
     */
    Menu.prototype.destroy = function () {

        this.folds.forEach(function (e) {
            if (e.destroy !== undefined) {
                e.destroy();
            }
        });

        this._el.parentNode.replaceChild(this._snippet, this._el);

        tiny.trigger(window.document, ch.onlayoutchange);

        parent.destroy.call(this);

        return;
    };

    ch.factory(Menu);

}(this, this.ch));

(function (window, ch) {
    'use strict';

    /**
     * Popover is the basic unit of a dialog window.
     * @memberof ch
     * @constructor
     * @augments ch.Component
     * @mixes ch.Collapsible
     * @mixes ch.Content
     * @requires ch.Positioner
     * @param {HTMLElement} el A HTMLElement to create an instance of ch.Popover.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.addClass] CSS class names that will be added to the container on the component initialization.
     * @param {String} [options.fx] Enable or disable UI effects. You must use: "slideDown", "fadeIn" or "none". Default: "fadeIn".
     * @param {String} [options.width] Set a width for the container. Default: "auto".
     * @param {String} [options.height] Set a height for the container. Default: "auto".
     * @param {String} [options.shownby] Determines how to interact with the trigger to show the container. You must use: "pointertap", "pointerenter" or "none". Default: "pointertap".
     * @param {String} [options.hiddenby] Determines how to hide the component. You must use: "button", "pointers", "pointerleave", "all" or "none". Default: "button".
     * @param {HTMLElement} [options.reference] It's a HTMLElement reference to position and size of element that will be considered to carry out the position. Default: the trigger element.
     * @param {String} [options.side] The side option where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "center".
     * @param {String} [options.align] The align options where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "center".
     * @param {Number} [options.offsetX] Distance to displace the target horizontally. Default: 0.
     * @param {Number} [options.offsetY] Distance to displace the target vertically. Default: 0.
     * @param {String} [options.position] The type of positioning used. Its value must be "absolute" or "fixed". Default: "absolute".
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading. Default: '&lt;div class="ch-loading ch-loading-centered"&gt;&lt;/div&gt;'.
     * @param {(String | HTMLElement)} [options.content] The content to be shown into the Popover container.
     * @param {(Boolean | String)} [options.wrapper] Wrap the reference element and place the container into it instead of body. When value is a string it will be applied as additional wrapper class. Default: false.
     *
     * @returns {popover} Returns a new instance of Popover.
     *
     * @example
     * // Create a new Popover.
     * var popover = new ch.Popover([el], [options]);
     * @example
     * // Create a new Popover with disabled effects.
     * var popover = new ch.Popover(el, {
     *     'fx': 'none'
     * });
     * @example
     * // Create a new Popover using the shorthand way (content as parameter).
     * var popover = new ch.Popover(document.querySelector('.popover'), {'content': 'http://ui.ml.com:3040/ajax'});
     */
    function Popover(el, options) {
        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Popover is created.
             * @memberof! ch.Popover.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Popover#ready
         * @example
         * // Subscribe to "ready" event.
         * popover.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Popover, ch.Component);

    var document = window.document,
        parent = Popover.super_.prototype,
        shownbyEvent = {
            'pointertap': ch.onpointertap,
            'pointerenter': ch.onpointerenter
        };

    /**
     * The name of the component.
     * @memberof! ch.Popover.prototype
     * @type {String}
     */
    Popover.prototype.name = 'popover';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Popover.prototype
     * @function
     */
    Popover.prototype.constructor = Popover;

    /**
     * Configuration by default.
     * @memberof! ch.Popover.prototype
     * @type {Object}
     * @private
     */
    Popover.prototype._defaults = {
        '_ariaRole': 'dialog',
        '_className': '',
        '_hideDelay': 400,
        'addClass': '',
        'fx': 'fadeIn',
        'width': 'auto',
        'height': 'auto',
        'shownby': 'pointertap',
        'hiddenby': 'button',
        'waiting': '<div class="ch-loading ch-loading-centered"></div>',
        'position': 'absolute',
        'wrapper': false
    };

    /**
     * Initialize a new instance of Popover and merge custom options with defaults options.
     * @memberof! ch.Popover.prototype
     * @function
     * @private
     * @returns {popover}
     */
    Popover.prototype._init = function (el, options) {
        // Call to its parent init method
        parent._init.call(this, el, options);

        // Require abilities
        this.require('Collapsible', 'Content');

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            container = document.createElement('div');

        this._configureWrapper();

        container.innerHTML = [
            '<div',
            ' class="ch-popover ch-hide ' + this._options._className + ' ' + this._options.addClass +
                (tiny.support.transition && this._options.fx !== 'none' && this._options.fx !== false ? ' ch-fx' : '') + '"',
            ' role="' + this._options._ariaRole + '"',
            ' id="ch-' + this.name + '-' + this.uid + '"',
            ' style="width:' + this._options.width + ';height:' + this._options.height + '"',
            '></div>'
        ].join('');

        /**
         * The popover container. It's the element that will be shown and hidden.
         * @type {HTMLDivElement}
         */
        this.container = container.querySelector('div');

        tiny.on(this.container, ch.onpointertap, function (event) {
            event.stopPropagation();
        });

        /**
         * Element where the content will be added.
         * @private
         * @type {HTMLDivElement}
         */
        this._content = document.createElement('div');

        tiny.addClass(this._content, 'ch-popover-content');

        this.container.appendChild(this._content);

        // Add functionality to the trigger if it exists
        this._configureTrigger();

        this._positioner = new ch.Positioner({
            'target': this.container,
            'reference': this._options.reference,
            'side': this._options.side,
            'align': this._options.align,
            'offsetX': this._options.offsetX,
            'offsetY': this._options.offsetY,
            'position': this._options.position
        });

        /**
         * Handler to execute the positioner refresh() method on layout changes.
         * @private
         * @function
         * @todo Define this function on prototype and use bind(): $document.on(ch.onlayoutchange, this.refreshPosition.bind(this));
         */
        this._refreshPositionListener = function () {
            if (that._shown) {
                that._positioner.refresh(options);
            }

            return that;
        };

        this._hideTimer = function () {
            that._timeout = window.setTimeout(function () {
                that.hide();
            }, that._options._hideDelay);
        };

        this._hideTimerCleaner = function () {
            window.clearTimeout(that._timeout);
        };

        // Configure the way it hides
        this._configureHiding();

        // Refresh position:
        // on layout change
        tiny.on(document, ch.onlayoutchange, this._refreshPositionListener);
        // on resize
        ch.viewport.on(ch.onresize, this._refreshPositionListener);

        this
            .once('_show', this._refreshPositionListener)
            // on content change
            .on('_contentchange', this._refreshPositionListener);

        return this;
    };

    /**
     * Adds functionality to the trigger. When a non-trigger popover is initialized, this method isn't executed.
     * @memberof! ch.Popover.prototype
     * @private
     * @function
     */
    Popover.prototype._configureTrigger = function () {

        if (this._el === undefined) {
            return;
        }

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            // It will be triggered on pointertap/pointerenter of the $trigger
            // It can toggle, show, or do nothing (in specific cases)
            showHandler = (function () {
                // Toggle as default
                var fn = that._toggle;
                // When a Popover is shown on pointerenter, it will set a timeout to manage when
                // to close the component. Avoid to toggle and let choise when to close to the timer
                if (that._options.shownby === 'pointerenter' || that._options.hiddenby === 'none' || that._options.hiddenby === 'button') {
                    fn = function () {
                        if (!that._shown) {
                            that.show();
                        }
                    };
                }

                return fn;
            }());

        /**
         * The original and entire element and its state, before initialization.
         * @private
         * @type {HTMLDivElement}
         */
        // cloneNode(true) > parameters is required. Opera & IE throws and internal error. Opera mobile breaks.
        this._snippet = this._el.cloneNode(true);

        // Use the trigger as the positioning reference
        this._options.reference = this._options.reference || this._el;

        // Open event when configured as able to shown anyway
        if (this._options.shownby !== 'none') {

            tiny.addClass(this._el, 'ch-shownby-' + this._options.shownby);

            if (this._options.shownby === shownbyEvent.pointertap && navigator.pointerEnabled) {
                tiny.on(this._el, 'click', function(e) {
                    e.preventDefault();
                });
            }

            tiny.on(this._el, shownbyEvent[this._options.shownby], function (event) {
                event.stopPropagation();
                event.preventDefault();
                showHandler();
            });
        }

        // Get a content if it's not defined
        if (this._options.content === undefined) {
            // Content from anchor href
            // IE defines the href attribute equal to src attribute on images.
            if (this._el.nodeName === 'A' && this._el.href !== '') {
                this._options.content = this._el.href;

            // Content from title or alt
            } else if (this._el.title !== '' || this._el.alt !== '') {
                // Set the configuration parameter
                this._options.content = this._el.title || this._el.alt;
                // Keep the attributes content into the element for possible usage
                this._el.setAttribute('data-title', this._options.content);
                // Avoid to trigger the native tooltip
                this._el.title = this._el.alt = '';
            }
        }

        // Set WAI-ARIA
        this._el.setAttribute('aria-owns', 'ch-' + this.name + '-' + this.uid);
        this._el.setAttribute('aria-haspopup', 'true');

        /**
         * The popover trigger. It's the element that will show and hide the container.
         * @type {HTMLElement}
         */
        this.trigger = this._el;
    };

    /**
     * Determines how to hide the component.
     * @memberof! ch.Popover.prototype
     * @private
     * @function
     */
    Popover.prototype._configureHiding = function () {
        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            hiddenby = this._options.hiddenby,
            dummy,
            button;



        // Don't hide anytime
        if (hiddenby === 'none') { return; }

        // Hide by leaving the component
        if (hiddenby === 'pointerleave' && this.trigger !== undefined) {

            [this.trigger, this.container].forEach(function(el) {
                tiny.on(el, ch.onpointerenter, that._hideTimerCleaner);
            });
            [this.trigger, this.container].forEach(function(el) {
                tiny.on(el, ch.onpointerleave, that._hideTimer);
            });
        }

        // Hide with the button Close
        if (hiddenby === 'button' || hiddenby === 'all') {
            dummy = document.createElement('div');
            dummy.innerHTML = '<i class="ch-close" role="button" aria-label="Close"></i>';
            button = dummy.querySelector('i');

            tiny.on(button, ch.onpointertap, function () {
                that.hide();
            });

            this.container.insertBefore(button, this.container.firstChild);

        }

        if ((hiddenby === 'pointers' || hiddenby === 'all') && this._hidingShortcuts !== undefined) {
            this._hidingShortcuts();
        }

    };

    /**
     * Creates an options object from the parameters arriving to the constructor method.
     * @memberof! ch.Popover.prototype
     * @private
     * @function
     */
    Popover.prototype._normalizeOptions = function (options) {
        // IE8 and earlier don't define the node type constants, 1 === document.ELEMENT_NODE
        if (typeof options === 'string' || (typeof options === 'object' && options.nodeType === 1)) {
            options = {
                'content': options
            };
        }
        return options;
    };

    /**
     * Wraps the target element and use the wrapper as the placement for container
     * @memberof! ch.Popover.prototype
     * @private
     * @function
     */
    Popover.prototype._configureWrapper = function() {
        var target = this._el || this._options.reference,
            wrapper = this._options.wrapper;

        if (wrapper && target && target.nodeType === 1) {
            // Create the wrapper element and append to it
            wrapper = document.createElement('span');
            tiny.addClass(wrapper, 'ch-popover-wrapper');

            if (typeof this._options.wrapper === 'string') {
                this._options.wrapper.split(' ').forEach(function(className) {
                    tiny.addClass(wrapper, className);
                });
            }

            tiny.parent(target).insertBefore(wrapper, target);
            wrapper.appendChild(target);
            if (tiny.css(wrapper, 'position') === 'static') {
                tiny.css(wrapper, {
                    display: 'inline-block',
                    position: 'relative'
                });
            }

            this._containerWrapper = wrapper;
        } else {
            this._containerWrapper = document.body;
        }
    };

    /**
     * Shows the popover container and appends it to the body.
     * @memberof! ch.Popover.prototype
     * @function
     * @param {(String | HTMLElement)} [content] The content that will be used by popover.
     * @param {Object} [options] A custom options to be used with content loaded by ajax.
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading.
     * @returns {popover}
     * @example
     * // Shows a basic popover.
     * popover.show();
     * @example
     * // Shows a popover with new content
     * popover.show('Some new content here!');
     * @example
     * // Shows a popover with a new content that will be loaded by ajax with some custom options
     * popover.show('http://domain.com/ajax/url', {
     *     'cache': false,
     *     'params': 'x-request=true'
     * });
     */
    Popover.prototype.show = function (content, options) {
        // Don't execute when it's disabled
        if (!this._enabled || this._shown) {
            return this;
        }

        // Append to the configured holder
        this._containerWrapper.appendChild(this.container);

        // Open the collapsible
        this._show();

        // Request the content
        if (content !== undefined) {
            this.content(content, options);
        }

        return this;
    };

    /**
     * Hides the popover container and deletes it from the body.
     * @memberof! ch.Popover.prototype
     * @function
     * @returns {popover}
     * @example
     * // Close a popover
     * popover.hide();
     */
    Popover.prototype.hide = function() {
        var self = this,
            parent;
        // Don't execute when it's disabled
        if (!this._enabled || !this._shown) {
            return this;
        }

        // Detach the container from the DOM when it is hidden
        this.once('hide', function() {
            // Due to transitions this._shown can be outdated here
            parent = self.container.parentNode;
            if (parent !== null) {
                parent.removeChild(self.container);
            }
        });

        // Close the collapsible
        this._hide();

        return this;
    };

    /**
     * Returns a Boolean specifying if the container is shown or not.
     * @memberof! ch.Popover.prototype
     * @function
     * @returns {Boolean}
     * @example
     * // Check the popover status
     * popover.isShown();
     * @example
     * // Check the popover status after an user action
     * $(window).on(ch.onpointertap, function () {
     *     if (popover.isShown()) {
     *         alert('Popover: visible');
     *     } else {
     *         alert('Popover: not visible');
     *     }
     * });
     */
    Popover.prototype.isShown = function () {
        return this._shown;
    };

    /**
     * Sets or gets the width of the container.
     * @memberof! ch.Popover.prototype
     * @function
     * @param {String} [data] Set a width for the container.
     * @returns {(Number | popover)}
     * @example
     * // Set a new popover width
     * component.width('300px');
     * @example
     * // Get the current popover width
     * component.width(); // '300px'
     */
    Popover.prototype.width = function (data) {

        if (data === undefined) {
            return this._options.width;
        }

        this.container.style.width = data;

        this._options.width = data;

        this.refreshPosition();

        return this;
    };

    /**
     * Sets or gets the height of the container.
     * @memberof! ch.Popover.prototype
     * @function
     * @param {String} [data] Set a height for the container.
     * @returns {(Number | popover)}
     * @example
     * // Set a new popover height
     * component.height('300px');
     * @example
     * // Get the current popover height
     * component.height(); // '300px'
     */
    Popover.prototype.height = function (data) {

        if (data === undefined) {
            return this._options.height;
        }

        this.container.style.height = data;

        this._options.height = data;

        this.refreshPosition();

        return this;
    };

    /**
     * Updates the current position of the container with given options or defaults.
     * @memberof! ch.Popover.prototype
     * @function
     * @params {Object} [options] A configuration object.
     * @returns {popover}
     * @example
     * // Update the current position
     * popover.refreshPosition();
     * @example
     * // Update the current position with a new offsetX and offsetY
     * popover.refreshPosition({
     *     'offestX': 100,
     *     'offestY': 10
     * });
     */
    Popover.prototype.refreshPosition = function (options) {

        if (this._shown) {
            // Refresh its position.
            this._positioner.refresh(options);

        } else {
            // Update its options. It will update position the next time to be shown.
            this._positioner._configure(options);
        }

        return this;
    };

    /**
     * Enables a Popover instance.
     * @memberof! ch.Popover.prototype
     * @function
     * @returns {popover}
     * @example
     * // Enable a popover
     * popover.enable();
     */
    Popover.prototype.enable = function () {

        if (this._el !== undefined) {
            this._el.setAttribute('aria-disabled', false);
        }

        parent.enable.call(this);

        return this;
    };

    /**
     * Disables a Popover instance.
     * @memberof! ch.Popover.prototype
     * @function
     * @returns {popover}
     * @example
     * // Disable a popover
     * popover.disable();
     */
    Popover.prototype.disable = function () {

        if (this._el !== undefined) {
            this._el.setAttribute('aria-disabled', true);
        }

        if (this._shown) {
            this.hide();
        }

        parent.disable.call(this);

        return this;
    };

    /**
     * Destroys a Popover instance.
     * @memberof! ch.Popover.prototype
     * @function
     * @returns {popover}
     * @example
     * // Destroy a popover
     * popover.destroy();
     * // Empty the popover reference
     * popover = undefined;
     */
    Popover.prototype.destroy = function () {

        if (this.trigger !== undefined) {

            tiny.off(this.trigger, ch.onpointerenter, this._hideTimerCleaner);
            tiny.off(this.trigger, ch.onpointerleave, this._hideTimer);

            tiny.removeClass(this.trigger, 'ch-' + this.name + '-trigger');

            this.trigger.removeAttribute('data-title');
            this.trigger.removeAttribute('aria-owns');
            this.trigger.removeAttribute('aria-haspopup');
            this.trigger.removeAttribute('data-side');
            this.trigger.removeAttribute('data-align');
            this.trigger.removeAttribute('role');

            this._snippet.alt ? this.trigger.setAttribute('alt', this._snippet.alt) : null;
            this._snippet.title ? this.trigger.setAttribute('title', this._snippet.title) : null;
        }

        tiny.off(document, ch.onlayoutchange, this._refreshPositionListener);

        ch.viewport.removeListener(ch.onresize, this._refreshPositionListener);

        parent.destroy.call(this);

        return;
    };

    ch.factory(Popover, Popover.prototype._normalizeOptions);

}(this, this.ch));

(function (window, ch) {
    'use strict';

    var document = window.document;

    ch.Popover.prototype._hidingShortcuts = function () {

        var that = this;

        function hide(event) {
            // event.button === 0: Fix issue #933 Right click closes it on Firefox.
            if (event.target !== that._el && event.target !== that.container && event.button === 0) {
                that.hide();
            }
        }

        ch.shortcuts.add(ch.onkeyesc, this.uid, function () {
            that.hide();
        });

        this
            .on('show', function () {
                ch.shortcuts.on(that.uid);
                tiny.on(document, ch.onpointertap, hide);
            })
            .on('hide', function () {
                ch.shortcuts.off(that.uid);
                tiny.off(document, ch.onpointertap, hide);
            })
            .once('destroy', function () {
                ch.shortcuts.remove(that.uid, ch.onkeyesc);
            });
    };

}(this, this.ch));

(function (window, ch) {
    'use strict';

    /**
     * Layer is a dialog window that can be shown one at a time.
     * @memberof ch
     * @constructor
     * @augments ch.Popover
     * @param {String} [el] A HTMLElement to create an instance of ch.Layer.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.addClass] CSS class names that will be added to the container on the component initialization.
     * @param {String} [options.fx] Enable or disable UI effects. You must use: "slideDown", "fadeIn" or "none". Default: "fadeIn".
     * @param {String} [options.width] Set a width for the container. Default: "auto".
     * @param {String} [options.height] Set a height for the container. Default: "auto".
     * @param {String} [options.shownby] Determines how to interact with the trigger to show the container. You must use: "pointertap", "pointerenter" or "none". Default: "pointerenter".
     * @param {String} [options.hiddenby] Determines how to hide the component. You must use: "button", "pointers", "pointerleave", "all" or "none". Default: "pointerleave".
     * @param {HTMLElement} [options.reference] It's a reference to position and size of element that will be considered to carry out the position. Default: the trigger element.
     * @param {String} [options.side] The side option where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "bottom".
     * @param {String} [options.align] The align options where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "left".
     * @param {Number} [options.offsetX] Distance to displace the target horizontally. Default: 0.
     * @param {Number} [options.offsetY] Distance to displace the target vertically. Default: 10.
     * @param {String} [options.position] The type of positioning used. Its value must be "absolute" or "fixed". Default: "absolute".
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading. Default: '&lt;div class="ch-loading ch-loading-centered"&gt;&lt;/div&gt;'.
     * @param {( String | HTMLElement)} [options.content] The content to be shown into the Layer container.
     * @param {(Boolean | String)} [options.wrapper] Wrap the reference element and place the container into it instead of body. When value is a string it will be applied as additional wrapper class. Default: false.
     *
     * @returns {layer} Returns a new instance of Layer.
     * @example
     * // Create a new Layer.
     * var layer = new ch.Layer([el], [options]);
     * @example
     * // Create a new Layer with disabled effects.
     * var layer = new ch.Layer({
     *     'content': 'This is the content of the Layer'
     * });
     * @example
     * // Create a new Layer using the shorthand way (content as parameter).
     * var layer = new ch.Layer('http://ui.ml.com:3040/ajax');
     */
    function Layer(el, options) {
        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Layer is created.
             * @memberof! ch.Layer.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Layer#ready
         * @example
         * // Subscribe to "ready" event.
         * layer.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Layer, ch.Popover);

    // Reference to the last component open. Allows to close and to deny to
    // have 2 components open at the same time
    var lastShown,
        parent = Layer.super_.prototype;

    /**
     * The name of the component.
     * @memberof! ch.Layer.prototype
     * @type {String}
     */
    Layer.prototype.name = 'layer';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Layer.prototype
     * @function
     */
    Layer.prototype.constructor = Layer;

    /**
     * Configuration by default.
     * @memberof! ch.Layer.prototype
     * @type {Object}
     * @private
     */
    Layer.prototype._defaults = tiny.extend(tiny.clone(parent._defaults), {
        '_className': 'ch-layer ch-box-lite ch-cone',
        '_ariaRole': 'tooltip',
        'shownby': 'pointerenter',
        'hiddenby': 'pointerleave',
        'side': 'bottom',
        'align': 'left',
        'offsetX': 0,
        'offsetY': 10,
        'waiting': '<div class="ch-loading-small"></div>',
        'wrapper': false
    });

    /**
     * Shows the layer container and hides other layers.
     * @memberof! ch.Layer.prototype
     * @function
     * @param {(String | HTMLElement)} [content] The content that will be used by layer.
     * @param {Object} [options] A custom options to be used with content loaded by ajax.
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading.
     * @returns {layer}
     * @example
     * // Shows a basic layer.
     * layer.show();
     * @example
     * // Shows a layer with new content
     * layer.show('Some new content here!');
     * @example
     * // Shows a layer with a new content that will be loaded by ajax with some custom options
     * layer.show('http://domain.com/ajax/url', {
     *     'cache': false,
     *     'params': 'x-request=true'
     * });
     */
    Layer.prototype.show = function (content, options) {
        // Don't execute when it's disabled
        if (!this._enabled || this._shown) {
            return this;
        }

        // Only hide if there was a component opened before
        if (lastShown !== undefined && lastShown.name === this.name && lastShown !== this) {
            lastShown.hide();
        }

        // Only save to future close if this component is closable
        if (this._options.hiddenby !== 'none' && this._options.hiddenby !== 'button') {
            lastShown = this;
        }

        // Execute the original show()
        parent.show.call(this, content, options);

        return this;
    };

    ch.factory(Layer, parent._normalizeOptions);

}(this, this.ch));

(function (ch) {
    'use strict';

    /**
     * Improves the native tooltips.
     * @memberof ch
     * @constructor
     * @augments ch.Popover
     * @param {HTMLElement} el A HTMLElement to create an instance of ch.Tooltip.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.addClass] CSS class names that will be added to the container on the component initialization.
     * @param {String} [options.fx] Enable or disable UI effects. You must use: "slideDown", "fadeIn" or "none". Default: "fadeIn".
     * @param {String} [options.width] Set a width for the container. Default: "auto".
     * @param {String} [options.height] Set a height for the container. Default: "auto".
     * @param {String} [options.shownby] Determines how to interact with the trigger to show the container. You must use: "pointertap", "pointerenter" or "none". Default: "pointerenter".
     * @param {String} [options.hiddenby] Determines how to hide the component. You must use: "button", "pointers", "pointerleave", "all" or "none". Default: "pointerleave".
     * @param {HTMLElement} [options.reference] It's a reference to position and size of element that will be considered to carry out the position. Default: the trigger element.
     * @param {String} [options.side] The side option where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "bottom".
     * @param {String} [options.align] The align options where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "left".
     * @param {Number} [options.offsetX] Distance to displace the target horizontally. Default: 0.
     * @param {Number} [options.offsetY] Distance to displace the target vertically. Default: 10.
     * @param {String} [options.position] The type of positioning used. Its value must be "absolute" or "fixed". Default: "absolute".
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading. Default: '<div class="ch-loading ch-loading-centered"></div>'.
     * @param {(String | HTMLElement)} [options.content] The content to be shown into the Tooltip container.
     * @returns {tooltip} Returns a new instance of Tooltip.
     * @example
     * // Create a new Tooltip.
     * var tooltip = new ch.Tooltip(document.querySelector('.trigger'), [options]);
     * @example
     * // Create a new Tooltip using the shorthand way (content as parameter).
     * var tooltip = new ch.Tooltip(document.querySelector('.trigger'), {'content': 'http://ui.ml.com:3040/ajax'});
     */
    function Tooltip(el, options) {

        // TODO: Review what's going on here with options
        /*
        if (options === undefined && el !== undefined && el.nodeType !== undefined) {
            options = el;
            el = undefined;
        }
        */

        options = tiny.extend(tiny.clone(this._defaults), options);

        return new ch.Layer(el, options);
    }

    /**
     * The name of the component.
     * @memberof! ch.Tooltip.prototype
     * @type {String}
     * @example
     * // You can reach the associated instance.
     * var tooltip = $(selector).data('tooltip');
     */
    Tooltip.prototype.name = 'tooltip';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Tooltip.prototype
     * @function
     */
    Tooltip.prototype.constructor = Tooltip;

    /**
     * Configuration by default.
     * @memberof! ch.Tooltip.prototype
     * @type {Object}
     * @private
     */
    Tooltip.prototype._defaults = tiny.extend(tiny.clone(ch.Layer.prototype._defaults), {
        '_className': 'ch-tooltip ch-cone'
    });

    ch.factory(Tooltip, ch.Layer.prototype._normalizeOptions);

}(this.ch));

(function (window, ch) {
    'use strict';

    /**
     * Dialog window with an error skin.
     * @memberof ch
     * @constructor
     * @augments ch.Component
     * @requires ch.Positioner
     * @param {HTMLElement} el A HTMLElement to create an instance of ch.Bubble.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.addClass] CSS class names that will be added to the container on the component initialization.
     * @param {String} [options.fx] Enable or disable UI effects. You must use: "slideDown", "fadeIn" or "none". Default: "fadeIn".
     * @param {String} [options.width] Set a width for the container. Default: "auto".
     * @param {String} [options.height] Set a height for the container. Default: "auto".
     * @param {String} [options.shownby] Determines how to interact with the trigger to show the container. You must use: "pointertap", "pointerenter" or "none". Default: "none".
     * @param {String} [options.hiddenby] Determines how to hide the component. You must use: "button", "pointers", "pointerleave", "all" or "none". Default: "none".
     * @param {HTMLElement} [options.reference] It's a reference to position and size of element that will be considered to carry out the position. Default: the trigger element.
     * @param {String} [options.side] The side option where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "right".
     * @param {String} [options.align] The align options where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "top".
     * @param {Number} [options.offsetX] Distance to displace the target horizontally. Default: 10.
     * @param {Number} [options.offsetY] Distance to displace the target vertically. Default: 0.
     * @param {String} [options.position] The type of positioning used. Its value must be "absolute" or "fixed". Default: "absolute".
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading. Default: '&lt;div class="ch-loading ch-loading-centered"&gt;&lt;/div&gt;'.
     * @param {(String | HTMLElement)} [options.content] The content to be shown into the Bubble container. Default: "Check the information, please."
     * @returns {bubble} Returns a new instance of Bubble.
     * @example
     * // Create a new Bubble.
     * var bubble = new ch.Bubble($el, [options]);
     * @example
     * // Create a new Bubble with disabled effects.
     * var bubble = new ch.Bubble({
     *     'fx': 'none'
     * });
     * @example
     * // Create a new Bubble using the shorthand way (content as parameter).
     * var bubble = new ch.Bubble('http://ui.ml.com:3040/ajax');
     */
    function Bubble(el, options) {
        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Bubble is created.
             * @memberof! ch.Bubble.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Bubble#ready
         * @example
         * // Subscribe to "ready" event.
         * bubble.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Bubble, ch.Popover);

    var parent = Bubble.super_.prototype;

    /**
     * The name of the component.
     * @memberof! ch.Bubble.prototype
     * @type {String}
     */
    Bubble.prototype.name = 'bubble';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Bubble.prototype
     * @function
     */
    Bubble.prototype.constructor = Bubble;

    /**
     * Configuration by default.
     * @memberof! ch.Bubble.prototype
     * @type {Object}
     * @private
     */
    Bubble.prototype._defaults = tiny.extend(tiny.clone(parent._defaults), {
        '_className': 'ch-bubble ch-box-icon ch-box-error ch-cone',
        '_ariaRole': 'alert',
        'shownby': 'none',
        'hiddenby': 'none',
        'side': 'right',
        'align': 'center',
        'offsetX': 10,
        'content': 'Check the information, please.'
    });

    /**
     * Initialize a new instance of Bubble and merge custom options with defaults options.
     * @memberof! ch.Bubble.prototype
     * @function
     * @private
     * @returns {bubble}
     */
    Bubble.prototype._init = function (el, options) {
        // Call to its parent init method
        parent._init.call(this, el, options);

        this.container.insertAdjacentHTML('beforeend', '<i class="ch-icon-remove-sign"></i>');

        return this;
    };

    ch.factory(Bubble, parent._normalizeOptions);

}(this, this.ch));

(function (window, ch) {
    'use strict';

    /**
     * Modal is a dialog window with an underlay.
     * @memberof ch
     * @constructor
     * @augments ch.Popover
     * @param {HTMLElement} [el] A HTMLElement to create an instance of ch.Modal.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.addClass] CSS class names that will be added to the container on the component initialization.
     * @param {String} [options.fx] Enable or disable UI effects. You must use: "slideDown", "fadeIn" or "none". Default: "fadeIn".
     * @param {String} [options.width] Set a width for the container. Default: "50%".
     * @param {String} [options.height] Set a height for the container. Default: "auto".
     * @param {String} [options.shownby] Determines how to interact with the trigger to show the container. You must use: "pointertap", "pointerenter" or "none". Default: "pointertap".
     * @param {String} [options.hiddenby] Determines how to hide the component. You must use: "button", "pointers", "pointerleave", "all" or "none". Default: "all".
     * @param {HTMLElement} [options.reference] It's a reference to position and size of element that will be considered to carry out the position. Default: ch.viewport.
     * @param {String} [options.side] The side option where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "center".
     * @param {String} [options.align] The align options where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "center".
     * @param {Number} [options.offsetX] Distance to displace the target horizontally. Default: 0.
     * @param {Number} [options.offsetY] Distance to displace the target vertically. Default: 0.
     * @param {String} [options.position] The type of positioning used. Its value must be "absolute" or "fixed". Default: "fixed".
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading. Default: '&lt;div class="ch-loading-large ch-loading-centered"&gt;&lt;/div&gt;'.
     * @param {(String | HTMLElement)} [options.content] The content to be shown into the Modal container.
     * @returns {modal} Returns a new instance of Modal.
     * @example
     * // Create a new Modal.
     * var modal = new ch.Modal([el], [options]);
     * @example
     * // Create a new Modal.
     * var modal = new ch.Modal([options]);
     * @example
     * // Create a new Modal with disabled effects.
     * var modal = new ch.Modal({
     *     'content': 'This is the content of the Modal'
     * });
     * @example
     * // Create a new Modal using the shorthand way (content as parameter).
     * var modal = new ch.Modal('http://ui.ml.com:3040/ajax');
     */
    function Modal(el, options) {
        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Modal is created.
             * @memberof! ch.Modal.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Modal#ready
         * @example
         * // Subscribe to "ready" event.
         * modal.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Modal, ch.Popover);

    var document = window.document,
        underlay = (function () {
            var dummyElement = document.createElement('div');
            dummyElement.innerHTML = '<div class="ch-underlay" tabindex="-1"></div>';

            return dummyElement.querySelector('div');
        }()),
        parent = Modal.super_.prototype;

    /**
     * The name of the component.
     * @memberof! ch.Modal.prototype
     * @type {String}
     */
    Modal.prototype.name = 'modal';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Modal.prototype
     * @function
     */
    Modal.prototype.constructor = Modal;

    /**
     * Configuration by default.
     * @memberof! ch.Modal.prototype
     * @type {Object}
     * @private
     */
    Modal.prototype._defaults = tiny.extend(tiny.clone(parent._defaults), {
        '_className': 'ch-modal ch-box-lite',
        '_ariaRole': 'dialog',
        'width': '50%',
        'hiddenby': 'all',
        'reference': ch.viewport,
        'waiting': '<div class="ch-loading-large ch-loading-centered"></div>',
        'position': 'fixed'
    });

    /**
     * Shows the Modal underlay.
     * @memberof! ch.Modal.prototype
     * @function
     * @private
     */
    Modal.prototype._showUnderlay = function () {
        var useAnimation = tiny.support.transition && this._options.fx !== 'none' && this._options.fx !== false,
            fxName = 'ch-fx-' + this._options.fx.toLowerCase();

        document.body.appendChild(underlay);

        function showCallback(e) {
            tiny.removeClass(underlay, fxName + '-enter-active');
            tiny.removeClass(underlay, fxName + '-enter');

            tiny.off(e.target, e.type, showCallback);
        }

        if (useAnimation) {
            tiny.addClass(underlay, fxName + '-enter');
            setTimeout(function() {
                tiny.addClass(underlay, fxName + '-enter-active');
            },10);
            tiny.on(underlay, tiny.support.transition.end, showCallback);
        }
    };

    /**
     * Hides the Modal underlay.
     * @memberof! ch.Modal.prototype
     * @function
     * @private
     */
    Modal.prototype._hideUnderlay = function () {
        var useAnimation = tiny.support.transition && this._options.fx !== 'none' && this._options.fx !== false,
            fxName = 'ch-fx-' + this._options.fx.toLowerCase(),
            parent = underlay.parentNode;

        function hideCallback(e) {
            tiny.removeClass(underlay, fxName + '-leave-active');
            tiny.removeClass(underlay, fxName + '-leave');

            tiny.off(e.target, e.type, hideCallback);
            parent.removeChild(underlay);
        }

        if (useAnimation) {
            tiny.addClass(underlay, fxName + '-leave');
            setTimeout(function() {
                tiny.addClass(underlay, fxName + '-leave-active');
            },10);
            tiny.on(underlay, tiny.support.transition.end, hideCallback);
        } else {
            parent.removeChild(underlay);
        }
    };

    /**
     * Shows the modal container and the underlay.
     * @memberof! ch.Modal.prototype
     * @function
     * @param {(String | HTMLElement)} [content] The content that will be used by modal.
     * @param {Object} [options] A custom options to be used with content loaded by ajax.
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading.
     * @returns {modal}
     * @example
     * // Shows a basic modal.
     * modal.show();
     * @example
     * // Shows a modal with new content
     * modal.show('Some new content here!');
     * @example
     * // Shows a modal with a new content that will be loaded by ajax with some custom options
     * modal.show('http://domain.com/ajax/url', {
     *     'cache': false,
     *     'params': 'x-request=true'
     * });
     */
    Modal.prototype.show = function (content, options) {
        // Don't execute when it's disabled
        if (!this._enabled || this._shown) {
            return this;
        }

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        function hideByUnderlay(e) {
            that.hide();
            // Allow only one click to analyze the config every time and to close ONLY THIS modal
            e.target.removeEventListener(e.type, hideByUnderlay);
        }

        // Add to the underlay the ability to hide the component
        if (this._options.hiddenby === 'all' || this._options.hiddenby === 'pointers') {
            tiny.on(underlay, ch.onpointertap, hideByUnderlay);
        }

        // Show the underlay
        this._showUnderlay();
        // Execute the original show()
        parent.show.call(this, content, options);

        return this;
    };

    /**
     * Hides the modal container and the underlay.
     * @memberof! ch.Modal.prototype
     * @function
     * @returns {modal}
     * @example
     * // Close a modal
     * modal.hide();
     */
    Modal.prototype.hide = function () {
        if (!this._shown) {
            return this;
        }

        // Delete the underlay listener
        tiny.off(underlay, ch.onpointertap);
        // Hide the underlay element
        this._hideUnderlay();
        // Execute the original hide()
        parent.hide.call(this);

        return this;
    };

    ch.factory(Modal, parent._normalizeOptions);

}(this, this.ch));

(function (ch) {
    'use strict';

    /**
     * Transition lets you give feedback to the users when their have to wait for an action.
     * @memberof ch
     * @constructor
     * @augments ch.Popover
     * @param {HTMLElement} [el] A HTMLElement to create an instance of ch.Transition.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.addClass] CSS class names that will be added to the container on the component initialization.
     * @param {String} [options.fx] Enable or disable UI effects. You must use: "slideDown", "fadeIn" or "none". Default: "fadeIn".
     * @param {String} [options.width] Set a width for the container. Default: "50%".
     * @param {String} [options.height] Set a height for the container. Default: "auto".
     * @param {String} [options.shownby] Determines how to interact with the trigger to show the container. You must use: "pointertap", "pointerenter" or "none". Default: "pointertap".
     * @param {String} [options.hiddenby] Determines how to hide the component. You must use: "button", "pointers", "pointerleave", "all" or "none". Default: "none".
     * @param {String} [options.reference] It's a reference to position and size of element that will be considered to carry out the position. Default: ch.viewport.
     * @param {String} [options.side] The side option where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "center".
     * @param {String} [options.align] The align options where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "center".
     * @param {Number} [options.offsetX] Distance to displace the target horizontally. Default: 0.
     * @param {Number} [options.offsetY] Distance to displace the target vertically. Default: 0.
     * @param {String} [options.position] The type of positioning used. Its value must be "absolute" or "fixed". Default: "fixed".
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(HTMLElement | String)} [options.waiting] Temporary content to use while the ajax request is loading. Default: '&lt;div class="ch-loading-large ch-loading-centered"&gt;&lt;/div&gt;'.
     * @param {(HTMLElement | String)} [options.content] The content to be shown into the Transition container. Default: "Please wait..."
     * @returns {transition} Returns a new instance of Transition.
     * @example
     * // Create a new Transition.
     * var transition = new ch.Transition([el], [options]);
     * @example
     * // Create a new Transition with disabled effects.
     * var transition = new ch.Transition({
     *     'fx': 'none'
     * });
     * @example
     * // Create a new Transition using the shorthand way (content as parameter).
     * var transition = new ch.Transition('http://ui.ml.com:3040/ajax');
     */
    function Transition(el, options) {

        if (el === undefined || options === undefined) {
            options = {};
        }

        options.content = (function () {
            var dummyElement = document.createElement('div'),
                content = options.waiting || '';

            // TODO: options.content could be a HTMLElement
            dummyElement.innerHTML = '<div class="ch-loading-large"></div><p>' + content + '</p>';

            return dummyElement.firstChild;
        }());

        // el is not defined
        if (el === undefined) {
            el = tiny.extend(tiny.clone(this._defaults), options);
        // el is present as a object configuration
        } else if (el.nodeType === undefined && typeof el === 'object') {
            el = tiny.extend(tiny.clone(this._defaults), el);
        } else if (options !== undefined) {
            options = tiny.extend(tiny.clone(this._defaults), options);
        }

        return new ch.Modal(el, options);
    }

    /**
     * The name of the component.
     * @memberof! ch.Transition.prototype
     * @type {String}
     */
    Transition.prototype.name = 'transition';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Transition.prototype
     * @function
     */
    Transition.prototype.constructor = Transition;

    /**
     * Configuration by default.
     * @memberof! ch.Transition.prototype
     * @type {Object}
     * @private
     */
    Transition.prototype._defaults = tiny.extend(tiny.clone(ch.Modal.prototype._defaults), {
        '_className': 'ch-transition ch-box-lite',
        '_ariaRole': 'alert',
        'hiddenby': 'none',
        'content': 'Please wait...'
    });

    ch.factory(Transition, ch.Modal.prototype._normalizeOptions);

}(this.ch));

(function (window, ch) {
    'use strict';

    /**
     * Zoom shows a contextual reference to an augmented version of a declared image.
     * @memberof ch
     * @constructor
     * @augments ch.Layer
     * @param {String} selector A CSS Selector to create an instance of ch.Zoom.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.addClass] CSS class names that will be added to the container on the component initialization.
     * @param {String} [options.fx] Enable or disable UI effects. You must use: "slideDown", "fadeIn" or "none". Default: "none".
     * @param {String} [options.width] Set a width for the container. Default: "300px".
     * @param {String} [options.height] Set a height for the container. Default: "300px".
     * @param {String} [options.shownby] Determines how to interact with the trigger to show the container. You must use: "pointertap", "pointerenter" or "none". Default: "pointerenter".
     * @param {String} [options.hiddenby] Determines how to hide the component. You must use: "button", "pointers", "pointerleave", "all" or "none". Default: "pointerleave".
     * @param {String} [options.reference] It's a CSS Selector reference to position and size of element that will be considered to carry out the position. Default: the trigger element.
     * @param {String} [options.side] The side option where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "right".
     * @param {String} [options.align] The align options where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "top".
     * @param {Number} [options.offsetX] Distance to displace the target horizontally. Default: 20.
     * @param {Number} [options.offsetY] Distance to displace the target vertically. Default: 0.
     * @param {String} [options.position] The type of positioning used. Its value must be "absolute" or "fixed". Default: "absolute".
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading. Default: 'Loading zoom...'.
     * @param {(HTMLElement | String)} [options.content] The content to be shown into the Zoom container.
     * @returns {zoom} Returns a new instance of Zoom.
     * @example
     * // Create a new Zoom.
     * var zoom = new ch.Zoom([selector], [options]);
     * @example
     * // Create a new Zoom with a defined width (half of the screen).
     * var zoom = new ch.Zoom({
     *     'width': (ch.viewport.width / 2) + 'px'
     * });
     */
    function Zoom(selector, options) {
        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(selector, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Zoom is created.
             * @memberof! ch.Zoom.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Zoom#ready
         * @example
         * // Subscribe to "ready" event.
         * zoom.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Zoom, ch.Layer);

    var parent = Zoom.super_.prototype;

    /**
     * The name of the component.
     * @memberof! ch.Zoom.prototype
     * @type {String}
     */
    Zoom.prototype.name = 'zoom';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Zoom.prototype
     * @function
     */
    Zoom.prototype.constructor = Zoom;

    /**
     * Configuration by default.
     * @memberof! ch.Zoom.prototype
     * @type {Object}
     * @private
     */
    Zoom.prototype._defaults = tiny.extend(tiny.clone(parent._defaults), {
        '_className': 'ch-zoom',
        '_ariaRole': 'tooltip',
        '_hideDelay': 0,
        'fx': 'none',
        'width': '300px',
        'height': '300px',
        'side': 'right',
        'align': 'top',
        'offsetX': 20,
        'offsetY': 0,
        'waiting': 'Loading zoom...'
    });

    /**
     * Initialize a new instance of Zoom and merge custom options with defaults options.
     * @memberof! ch.Zoom.prototype
     * @function
     * @private
     * @returns {zoom}
     */
    Zoom.prototype._init = function (selector, options) {
        // Call to its parent init method
        parent._init.call(this, selector, options);

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        /**
         * Flag to control when zoomed image is loaded.
         * @type {Boolean}
         * @private
         */
        this._loaded = false;

        /**
         * Feedback showed before the zoomed image is load. It's a transition message and its content can be configured through parameter "waiting".
         * @type {HTMLElement}
         * @private
         * @example
         * // Changing the loading feedback.
         * var zoom = new ch.Zoom({
         *     'waiting': 'My custom message'
         * });
         */
        this._loading = (function() {
            var dummyElement = document.createElement('div');
            dummyElement.innerHTML = '<div class="ch-zoom-loading ch-hide"><div class="ch-loading-large"></div><p>' + that._options.waiting + '</p></div>';

            return dummyElement.firstChild;
        }());

        this.trigger.appendChild(this._loading);


        /**
         * HTML Element shape with visual feedback to the relative size of the zoomed area.
         * @type {HTMLDivElement}
         * @private
         */
        this._seeker = (function (){
            var dummyElement = document.createElement('div');
            dummyElement.innerHTML = '<div class="ch-zoom-seeker ch-hide"></div>';

            return dummyElement.firstChild;
        }());

        this.trigger.appendChild(this._seeker);

        /**
         * The main specified image with original size (not zoomed).
         * @type {HTMLElement}
         * @private
         */
        this._original = this.trigger.children[0];

        /**
         * The zoomed image specified as a link href (see the HTML snippet).
         * @type {HTMLImageElement}
         * @private
         */
        // Use a new Image to calculate the
        // size before append the image to DOM, in ALL the browsers.
        this._zoomed = new window.Image();

        // Assign event handlers to the original image
        onImagesLoads(this._original, function () {
            that._originalLoaded();

            tiny.on(window, 'resize', that._updateOffset.bind(that));
        });

        // Assign event handlers to the zoomed image
        onImagesLoads(this._zoomed, function () {
            that._zoomedLoaded();
        });

        // Make the entire Show process if it tried to show before
        this.on('imageload', function () {
            if (!tiny.hasClass(this._loading, 'ch-hide')) {
                that.show();
                tiny.addClass(this._loading, 'ch-hide');
            }
        });

        // Assign event handlers to the anchor
        tiny.addClass(this.trigger, 'ch-zoom-trigger');

        // Prevent to redirect to the href
        tiny.on(this.trigger, 'click', function (event) { event.preventDefault(); }, false);

        // Bind move calculations
        tiny.on(this.trigger, ch.onpointermove, function (event) { that._move(event); }, false);

        return this;
    };

    /**
     * Sets the correct size to the wrapper anchor.
     * @memberof! ch.Zoom.prototype
     * @function
     * @private
     */
    Zoom.prototype._originalLoaded = function () {

        var width = this._original.width,
            height = this._original.height;

        // Set the wrapper anchor size (same as image)
        this.trigger.style.width = width + 'px';
        this.trigger.style.height = height + 'px';

        // Loading position centered into the anchor
        this._loading.style.display = 'block';
        this._loading.style.left = (width - this._loading.clientWidth) / 2 + 'px';
        this._loading.style.top = (height - this._loading.clientHeight) / 2 + 'px';
        this._loading.style.display = '';

        /**
         * Width of the original specified image.
         * @type {Number}
         * @private
         */
        this._originalWidth = width;

        /**
         * Height of the original specified image.
         * @type {Number}
         * @private
         */
        this._originalHeight = height;

        this._updateOffset();
    };

    /**
     * Recalculate an offset of the original image that is used as reference element for Popover
     * @private
     */
    Zoom.prototype._updateOffset = function() {
        var offset = tiny.offset(this._el);

        /**
         * Left position of the original specified anchor/image.
         * @type {Number}
         * @private
         */
        this._originalOffsetLeft = offset.left;

        /**
         * Top position of the original specified anchor/image.
         * @type {Number}
         * @private
         */
        this._originalOffsetTop = offset.top;

        // Refresh zoomed image position that stays in a Popover
        this._positioner.refresh();
    };

    /**
     * Loads the Zoom content and sets the Seeker size.
     * @memberof! ch.Zoom.prototype
     * @function
     * @private
     */
    Zoom.prototype._zoomedLoaded = function () {

        /**
         * Relation between the zoomed and the original image width.
         * @type {Number}
         * @private
         */
        this._ratioX = (this._zoomed.width / this._originalWidth);

        /**
         * Relation between the zoomed and the original image height.
         * @type {Number}
         * @private
         */
        this._ratioY = (this._zoomed.height / this._originalHeight);

        /**
         * Width of the Seeker, calculated from ratio.
         * @type {Number}
         * @private
         */
        this._seekerWidth = window.Math.floor(window.parseInt(this._options.width, 10) / this._ratioX);

        /**
         * Height of the Seeker, calculated from ratio.
         * @type {Number}
         * @private
         */
        this._seekerHeight = window.Math.floor(window.parseInt(this._options.height, 10) / this._ratioY);

        /**
         * Half of the width of the Seeker. Used to position it.
         * @type {Number}
         * @private
         */
        this._seekerHalfWidth = window.Math.floor(this._seekerWidth / 2);

        /**
         * Half of the height of the Seeker. Used to position it.
         * @type {Number}
         * @private
         */
        this._seekerHalfHeight = window.Math.floor(this._seekerHeight / 2);

        // Set size of the Seeker
        this._seeker.style.cssText = 'width:' + this._seekerWidth + 'px;height:' + this._seekerHeight + 'px';

        // Use the zoomed image as content for the floated element
        this.content(this._zoomed);

        // Update the flag to allow to zoom
        this._loaded = true;

        /**
         * Event emitted when the zoomed image is downloaded.
         * @event ch.Zoom#imageload
         * @example
         * // Subscribe to "imageload" event.
         * zoom.on('imageload', function () {
         *     alert('Zoomed image ready!');
         * });
         */
        this.emit('imageload');
    };

    /**
     * Calculates movement limits and sets it to Seeker and zoomed image.
     * @memberof! ch.Zoom.prototype
     * @function
     * @private
     * @param {Event} event Used to take the cursor position.
     */
    Zoom.prototype._move = function (event) {
        // Don't execute when it's disabled or it's not loaded
        if (!this._enabled || !this._loaded) {
            return;
        }

        // By defining these variables in here, it avoids to make
        // the substraction twice if it's a free movement
        var pageX = (event.pageX || event.clientX + document.documentElement.scrollLeft),
            pageY = (event.pageY || event.clientY + document.documentElement.scrollTop),
            seekerLeft = pageX - this._seekerHalfWidth,
            seekerTop = pageY - this._seekerHalfHeight,
            x,
            y;

        // Left side of seeker LESS THAN left side of image
        if (seekerLeft <= this._originalOffsetLeft) {
            x = 0;
        // Right side of seeker GREATER THAN right side of image
        } else if (pageX + this._seekerHalfWidth > this._originalWidth + this._originalOffsetLeft) {
            x = this._originalWidth - this._seekerWidth - 2;
        // Free move
        } else {
            x = seekerLeft - this._originalOffsetLeft;
        }

        // Top side of seeker LESS THAN top side of image
        if (seekerTop <= this._originalOffsetTop) {
            y = 0;
        // Bottom side of seeker GREATER THAN bottom side of image
        } else if (pageY + this._seekerHalfHeight > this._originalHeight + this._originalOffsetTop) {
            y = this._originalHeight - this._seekerHeight - 2;
        // Free move
        } else {
            y = seekerTop - this._originalOffsetTop;
        }

        // Move seeker and the zoomed image
        this._seeker.style.left = x + 'px';
        this._seeker.style.top = y + 'px';
        this._zoomed.style.cssText = 'left:' + (-this._ratioX * x) + 'px;top:' + (-this._ratioY * y) + 'px';
    };

    /**
     * Shows the zoom container and the Seeker, or show a loading feedback until the zoomed image loads.
     * @memberof! ch.Zoom.prototype
     * @function
     * @param {(String | HTMLElement)} [content] The content that will be used by dropdown.
     * @param {Object} [options] A custom options to be used with content loaded by ajax.
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading.
     * @returns {zoom}
     * @example
     * // Shows a basic zoom.
     * zoom.show();
     * @example
     * // Shows a zoom with new content
     * zoom.show('Some new content here!');
     * @example
     * // Shows a zoom with a new content that will be loaded by ajax with some custom options
     * zoom.show('http://domain.com/ajax/url', {
     *     'cache': false,
     *     'params': 'x-request=true'
     * });
     */
    Zoom.prototype.show = function (content, options) {
        // Don't execute when it's disabled
        if (!this._enabled || this._shown) {
            return this;
        }

        // Show feedback and trigger the image load, if it's not loaded
        if (!this._loaded) {
            tiny.removeClass(this._loading, 'ch-hide');
            this.loadImage();
            return this;
        }

        // Delete the Loading and show the Seeker
        tiny.removeClass(this._seeker, 'ch-hide');

        // Execute the original show()
        parent.show.call(this, content, options);

        return this;
    };

    /**
     * Hides the zoom container and the Seeker.
     * @memberof! ch.Zoom.prototype
     * @function
     * @returns {zoom}
     * @example
     * // Close a zoom
     * zoom.hide();
     */
    Zoom.prototype.hide = function () {
        if (!this._shown) {
            return this;
        }

        // Avoid unnecessary execution
        if (!this._loaded) {
            tiny.addClass(this._loading, 'ch-hide');
            return this;
        }

        tiny.addClass(this._seeker, 'ch-hide');

        parent.hide.call(this);

        return this;
    };

    /**
     * Adds the zoomed image source to the <img> tag to trigger the request.
     * @memberof! ch.Zoom.prototype
     * @function
     * @returns {zoom}
     * @example
     * // Load the zoomed image on demand.
     * component.loadImage();
     */
    Zoom.prototype.loadImage = function () {

        this._zoomed.src = this._el.href;

        return this;
    };

    /**
     * Destroys a Zoom instance.
     * @memberof! ch.Zoom.prototype
     * @function
     * @returns {zoom}
     * @example
     * // Destroy a zoom
     * zoom.destroy();
     * // Empty the zoom reference
     * zoom = undefined;
     */
    Zoom.prototype.destroy = function () {
        var parentElement;

        parentElement = tiny.parent(this._seeker);
        parentElement.removeChild(this._seeker);

        parent.destroy.call(this);
    };

    ch.factory(Zoom, parent._normalizeOptions);


    /**
     * Executes a callback function when the images of a query selection loads.
     * @private
     * @param {HTMLImageElement} image An image or a collection of images.
     * @param {Function} [callback] The handler the component will fire after the images loads.
     *
     * @example
     * onImagesLoads(HTMLImageElement, function () {
     *     console.log('The size of the loaded image is ' + this.width);
     * });
     */
    function onImagesLoads(image, callback) {
        var images;

        if (Array.isArray(image)) {
            images = image;
        } else {
            images = [image];
        }

        images.forEach(function (image) {
            tiny.on(image, 'load', function onImgLoad() {
                var len = images.length;

                window.setTimeout(function () {
                    if (--len <= 0) {
                        callback.call(image);
                    }
                }, 200);

                image.removeEventListener('load', onImgLoad);
            }, false);

            if (image.complete || image.complete === undefined) {
                var src = image.src;
                // Data uri fix bug in web-kit browsers
                image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';
                image.src = src;
            }
        });
    }

}(this, this.ch));

(function (window, ch) {
    'use strict';

    function normalizeOptions(options) {
        if (typeof options === 'string' || Array.isArray(options)) {
            options = {
                'selected': options
            };
        }
        return options;
    }

    /**
     * It lets you move across the months of the year and allow to set dates as selected.
     * @memberof ch
     * @constructor
     * @augments ch.Component
     * @param {HTMLElement} el A HTMLElement to create an instance of ch.Calendar.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.format] Sets the date format. You must use "DD/MM/YYYY", "MM/DD/YYYY" or "YYYY/MM/DD". Default: "DD/MM/YYYY".
     * @param {String} [options.selected] Sets a date that should be selected by default. Default: The date of today.
     * @param {String} [options.from] Set a minimum selectable date. The format of the given date should be YYYY/MM/DD.
     * @param {String} [options.to] Set a maximum selectable date. The format of the given date should be YYYY/MM/DD.
     * @param {Array} [options.monthsNames] A collection of months names. Default: ["Enero", ... , "Diciembre"].
     * @param {Array} [options.weekdays] A collection of weekdays. Default: ["Dom", ... , "Sab"].
     * @returns {calendar} Returns a new instance of Calendar.
     * @example
     * // Create a new Calendar.
     * var calendar = new ch.Calendar([el], [options]);
     * @example
     * // Creates a new Calendar with custom options.
     * var calendar =  new ch.Calendar({
     *     'format': 'MM/DD/YYYY',
     *     'selected': '2011/12/25',
     *     'from': '2010/12/25',
     *     'to': '2012/12/25',
     *     'monthsNames': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
     *     'weekdays': ['Su', 'Mo', 'Tu', 'We', 'Thu', 'Fr', 'Sa']
     * });
     * @example
     * // Creates a new Calendar using a shorthand way (selected date as parameter).
     * var calendar = new ch.Calendar('2011/12/25');
     */
    function Calendar(el, options) {
        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Calendar is created.
             * @memberof! ch.Calendar.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Calendar#ready
         * @example
         * // Subscribe to "ready" event.
         * calendar.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Calendar, ch.Component);

    /**
     * Completes with zero the numbers less than 10.
     * @function
     * @private
     * @returns {String}
     */
    var addZero = function (num) {
            return (parseInt(num, 10) < 10) ? '0' + num : num;
        },

        /**
         * Map of date formats.
         * @type {Object}
         * @private
         */
        FORMAT_dates = {

            /**
             * Converts a given date to "YYYY/MM/DD" format.
             * @params {Date} date A given date to convert.
             * @function
             * @returns {String}
             */
            'YYYY/MM/DD': function (date) {
                return [date.year, addZero(date.month), addZero(date.day)].join('/');
            },

            /**
             * Converts a given date to "DD/MM/YYYY" format.
             * @params {Date} date A given date to convert.
             * @function
             * @returns {String}
             */
            'DD/MM/YYYY': function (date) {
                return [addZero(date.day), addZero(date.month), date.year].join('/');
            },

            /**
             * Converts a given date to "MM/DD/YYYY" format.
             * @params {Date} date A given date to convert.
             * @function
             * @returns {String}
             */
            'MM/DD/YYYY': function (date) {
                return [addZero(date.month), addZero(date.day), date.year].join('/');
            }
        },

        /**
         * Creates a JSON Object with reference to day, month and year, from a determinated date.
         * @function
         * @private
         * @returns {Object}
         */
        createDateObject = function (date) {

            // Uses date parameter or create a date from today
            date = (date === 'today') ? new Date() : new Date(date);

            /**
             * Returned custom Date object.
             * @type {Object}
             * @private
             */
            return {

                /**
                 * Reference to native Date object.
                 * @type {Date}
                 * @private
                 */
                'native': date,

                /**
                 * Number of day.
                 * @type {Number}
                 * @private
                 */
                'day': date.getDate(),

                /**
                 * Order of day in a week.
                 * @type {Number}
                 * @private
                 */
                'order': date.getDay(),

                /**
                 * Number of month.
                 * @type {Number}
                 * @private
                 */
                'month': date.getMonth() + 1,

                /**
                 * Number of full year.
                 * @type {Number}
                 * @private
                 */
                'year': date.getFullYear()
            };
        },

        parent = Calendar.super_.prototype;

    /**
     * The name of the component.
     * @memberof! ch.Calendar.prototype
     * @type {String}
     */
    Calendar.prototype.name = 'calendar';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Calendar.prototype
     * @function
     */
    Calendar.prototype.constructor = Calendar;

    /**
     * Configuration by default.
     * @type {Object}
     * @private
     */
    Calendar.prototype._defaults = {
        'monthsNames': ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
        'weekdays': ['Dom', 'Lun', 'Mar', 'Mie', 'Jue', 'Vie', 'Sab'],
        'format': 'DD/MM/YYYY'
    };

    /**
     * Initialize a new instance of Calendar and merge custom options with defaults options.
     * @memberof! ch.Calendar.prototype
     * @function
     * @private
     * @returns {calendar}
     */
    Calendar.prototype._init = function (el, options) {
        // Call to its parent init method
        parent._init.call(this, el, options);

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        // cloneNode(true) > parameters is required. Opera & IE throws and internal error. Opera mobile breaks.
        this._snippet = this._el.cloneNode(true);

        /**
         * Object to mange the date and its ranges.
         * @type {Object}
         * @private
         */
        this._dates = {
            'range': {}
        };

        this._dates.today = createDateObject('today');

        this._dates.current = this._dates.today;

        /**
         * Date of selected day.
         * @type {Object}
         * @private
         */
        this._dates.selected = (function () {

            // Get date from configuration or input value, if configured could be an Array with multiple selections
            var selected = that._options.selected;

            // Do it only if there are a "selected" parameter
            if (!selected) { return selected; }

            // Simple date selection
            if (!Array.isArray(selected)) {

                if (selected !== 'today') {
                    // Return date object and update currentDate
                    selected = that._dates.current = createDateObject(selected);

                } else {
                    selected = that._dates.today;
                }

            // Multiple date selection
            } else {
                selected.forEach(function (e, i){
                    // Simple date
                    if (!Array.isArray(e)) {
                        selected[i] = (selected[i] !== 'today') ? createDateObject(e) : that._dates.today;
                    // Range
                    } else {
                        selected[i][0] = (selected[i][0] !== 'today') ? createDateObject(e[0]) : that._dates.today;
                        selected[i][1] = (selected[i][1] !== 'today') ? createDateObject(e[1]) : that._dates.today;
                    }
                });
            }

            return selected;
        }());

        // Today's date object
        this._dates.today = createDateObject('today');

        // Minimum selectable date
        this._dates.range.from = (function () {

            // Only works when there are a "from" parameter on configuration
            if (that._options.from === undefined || !that._options.from) { return; }

            // Return date object
            return (that._options.from === 'today') ? that._dates.today : createDateObject(that._options.from);

        }());

        // Maximum selectable date
        this._dates.range.to = (function () {

            // Only works when there are a "to" parameter on configuration
            if (that._options.to === undefined || !that._options.to) { return; }

            // Return date object
            return (that._options.to === 'today') ? that._dates.today : createDateObject(that._options.to);

        }());

        /**
         * Template of previous arrow.
         * @type {HTMLDivElement}
         */
        this._prev = document.createElement('div');
        this._prev.setAttribute('aria-controls', 'ch-calendar-grid-' + this.uid);
        this._prev.setAttribute('role', 'button');
        this._prev.setAttribute('aria-hidden', 'false');
        tiny.addClass(this._prev, 'ch-calendar-prev');

        /**
         * Template of next arrow.
         * @type {HTMLDivElement}
         */
        this._next = document.createElement('div');
        this._next.setAttribute('aria-controls', 'ch-calendar-grid-' + this.uid);
        this._next.setAttribute('role', 'button');
        this._next.setAttribute('aria-hidden', 'false');
        tiny.addClass(this._next, 'ch-calendar-next');


        // Show or hide arrows depending on "from" and "to" limits
        tiny.on(this._prev, ch.onpointertap, function (event) {
            event.preventDefault();
            that.prevMonth();
        });
        tiny.on(this._next, ch.onpointertap, function (event) {
            event.preventDefault();
            that.nextMonth();
        });

        /**
         * The calendar container.
         * @type {HTMLElement}
         */
        this.container = this._el;
        this.container.insertBefore(this._prev, this.container.firstChild);
        this.container.insertBefore(this._next, this.container.firstChild);
        tiny.addClass(this.container, 'ch-calendar');
        this.container.insertAdjacentHTML('beforeend', this._createTemplate(this._dates.current));

        this._updateControls();

        // Avoid selection on the component
        that.container.setAttribute('unselectable', 'on');
        tiny.addClass(that.container, 'ch-user-no-select');

        return this;
    };

    /**
     * Checks if it has got a previous month to show depending on "from" limit.
     * @function
     * @private
     */
    Calendar.prototype._hasPrevMonth = function () {
        return this._dates.range.from === undefined || !(this._dates.range.from.month >= this._dates.current.month && this._dates.range.from.year >= this._dates.current.year);
    };

    /**
     * Checks if it has got a next month to show depending on "to" limits.
     * @function
     * @private
     */
    Calendar.prototype._hasNextMonth = function () {
        return this._dates.range.to === undefined || !(this._dates.range.to.month <= this._dates.current.month && this._dates.range.to.year <= this._dates.current.year);
    };

    /**
     * Refresh arrows visibility depending on "from" and "to" limits.
     * @function
     * @private
     */
    Calendar.prototype._updateControls = function () {

        // Show previous arrow when it's out of limit
        if (this._hasPrevMonth()) {
            tiny.removeClass(this._prev, 'ch-hide');
            this._prev.setAttribute('aria-hidden', 'false');

        // Hide previous arrow when it's out of limit
        } else {
            tiny.addClass(this._prev, 'ch-hide');
            this._prev.setAttribute('aria-hidden', 'true');
        }

        // Show next arrow when it's out of limit
        if (this._hasNextMonth()) {
            tiny.removeClass(this._next, 'ch-hide');
            this._next.setAttribute('aria-hidden', 'false');

        // Hide next arrow when it's out of limit
        } else {
            tiny.addClass(this._next, 'ch-hide');
            this._next.setAttribute('aria-hidden', 'true');
        }

        return this;
    };

    /**
     * Refresh the structure of Calendar's table with a new date.
     * @function
     * @private
     */
    Calendar.prototype._updateTemplate = function (date) {
        var month;

        // Update "currentDate" object
        this._dates.current = (typeof date === 'string') ? createDateObject(date) : date;

        // Delete old table
        month = this.container.querySelector('table');
        this.container.removeChild(month);

        // Append new table to content
        this.container.insertAdjacentHTML('beforeend', this._createTemplate(this._dates.current));

        // Refresh arrows
        this._updateControls();

        return this;
    };

    /**
     * Creates a complete month in a table.
     * @function
     * @private
     */
    Calendar.prototype._createTemplate = function (date) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            cell,
            positive,
            day,
            isSelected,
            thead = (function () {

                // Create thead structure
                var t = ['<thead><tr role="row">'],
                    dayIndex;

                // Add week names
                for (dayIndex = 0; dayIndex < 7; dayIndex += 1) {
                    t.push('<th role="columnheader">' + that._defaults.weekdays[dayIndex] + '</th>');
                }

                // Close thead structure
                t.push('</tr></thead>');

                // Join structure and return
                return t.join('');

            }()),

            table = [
                '<table class="ch-calendar-month" role="grid" id="ch-calendar-grid-' + that.uid + '">',
                '<caption>' + that._defaults.monthsNames[date.month - 1] + ' - ' + date.year + '</caption>',
                thead
            ],

            // Total amount of days into month
            cells = (function () {

                // Amount of days of current month
                var currentMonth = new Date(date.year, date.month, 0).getDate(),

                // Amount of days of previous month
                    prevMonth = new Date([date.year, date.month, '01'].join('/')).getDay(),

                // Merge amount of previous and current month
                    subtotal = prevMonth + currentMonth,

                // Amount of days into last week of month
                    latest = subtotal % 7,

                // Amount of days of next month
                    nextMonth = (latest > 0) ? 7 - latest : 0;

                return {
                    'previous': prevMonth,
                    'subtotal': subtotal,
                    'total': subtotal + nextMonth
                };

            }());

        table.push('<tbody><tr class="ch-calendar-week" role="row">');

        // Iteration of weekdays
        for (cell = 0; cell < cells.total; cell += 1) {

            // Push an empty cell on previous and next month
            if (cell < cells.previous || cell > cells.subtotal - 1) {
                table.push('<td role="gridcell" class="ch-calendar-other">X</td>');
            } else {

                // Positive number of iteration
                positive = cell + 1;

                // Day number
                day = positive - cells.previous;

                // Define if it's the day selected
                isSelected = this._isSelected(date.year, date.month, day);

                // Create cell
                table.push(
                    // Open cell structure including WAI-ARIA and classnames space opening
                    '<td role="gridcell"' + (isSelected ? ' aria-selected="true"' : '') + ' class="ch-calendar-day',

                    // Add Today classname if it's necesary
                    (date.year === that._dates.today.year && date.month === that._dates.today.month && day === that._dates.today.day) ? ' ch-calendar-today' : null,

                    // Add Selected classname if it's necesary
                    (isSelected ? ' ch-calendar-selected ' : null),

                    // From/to range. Disabling cells
                    (
                        // Disable cell if it's out of FROM range
                        (that._dates.range.from && day < that._dates.range.from.day && date.month === that._dates.range.from.month && date.year === that._dates.range.from.year) ||

                        // Disable cell if it's out of TO range
                        (that._dates.range.to && day > that._dates.range.to.day && date.month === that._dates.range.to.month && date.year === that._dates.range.to.year)

                    ) ? ' ch-calendar-disabled' : null,

                    // Close classnames attribute and print content closing cell structure
                    '">' + day + '</td>'
                );

                // Cut week if there are seven days
                if (positive % 7 === 0) {
                    table.push('</tr><tr class="ch-calendar-week" role="row">');
                }

            }

        }

        table.push('</tr></tbody></table>');

        // Return table object
        return table.join('');

    };

    /**
     * Checks if a given date is into 'from' and 'to' dates.
     * @function
     * @private
     */
    Calendar.prototype._isInRange = function (date) {
        var inRangeFrom = true,
            inRangeTo = true;

        if (this._dates.range.from) {
            inRangeFrom = (this._dates.range.from.native <= date.native);
        }

        if (this._dates.range.to) {
            inRangeTo = (this._dates.range.to.native >= date.native);
        }

        return inRangeFrom && inRangeTo;
    };

    /**
     * Indicates if an specific date is selected or not (including date ranges and simple dates).
     * @function
     * @private
     */
    Calendar.prototype._isSelected = function (year, month, day) {
        var yepnope;

        if (!this._dates.selected) { return; }

        yepnope = false;

        // Simple selection
        if (!Array.isArray(this._dates.selected)) {
            if (year === this._dates.selected.year && month === this._dates.selected.month && day === this._dates.selected.day) {
                yepnope = true;
                return yepnope;
            }

        // Multiple selection (ranges)
        } else {
            this._dates.selected.forEach(function (e) {
                // Simple date
                if (!Array.isArray(e)) {
                    if (year === e.year && month === e.month && day === e.day) {
                        yepnope = true;
                        return yepnope;
                    }
                // Range
                } else {
                    if (
                        (year >= e[0].year && month >= e[0].month && day >= e[0].day) &&
                            (year <= e[1].year && month <= e[1].month && day <= e[1].day)
                    ) {
                        yepnope = true;
                        return yepnope;
                    }
                }
            });
        }

        return yepnope;
    };

    /**
     * Selects a specific date or returns the selected date.
     * @memberof! ch.Calendar.prototype
     * @function
     * @param {String} [date] A given date to select. The format of the given date should be "YYYY/MM/DD".
     * @returns {calendar}
     * @example
     * // Returns the selected date.
     * calendar.select();
     * @example
     * // Select a specific date.
     * calendar.select('2014/05/28');
     */
    Calendar.prototype.select = function (date) {
        // Getter
        if (!date) {
            if (this._dates.selected === undefined) {
                return;
            }
            return FORMAT_dates[this._options.format](this._dates.selected);
        }

        // Setter
        var newDate = createDateObject(date);


        if (!this._isInRange(newDate)) {
            return this;
        }

        // Update selected date
        this._dates.selected = (date === 'today') ? this._dates.today : newDate;

        // Create a new table of selected month
        this._updateTemplate(this._dates.selected);

        /**
         * Event emitted when a date is selected.
         * @event ch.Calendar#select
         * @example
         * // Subscribe to "select" event.
         * calendar.on('select', function () {
         *     // Some code here!
         * });
         */
        this.emit('select');

        return this;
    };

    /**
     * Returns date of today
     * @memberof! ch.Calendar.prototype
     * @function
     * @returns {String} The date of today
     * @example
     * // Get the date of today.
     * var today = calendar.getToday();
     */
    Calendar.prototype.getToday = function () {
        return FORMAT_dates[this._options.format](this._dates.today);
    };

    /**
     * Moves to the next month.
     * @memberof! ch.Calendar.prototype
     * @function
     * @returns {calendar}
     * @example
     * // Moves to the next month.
     * calendar.nextMonth();
     */
    Calendar.prototype.nextMonth = function () {
        if (!this._enabled || !this._hasNextMonth()) {
            return this;
        }

        // Next year
        if (this._dates.current.month === 12) {
            this._dates.current.month = 0;
            this._dates.current.year += 1;
        }

        // Create a new table of selected month
        this._updateTemplate([this._dates.current.year, this._dates.current.month + 1, '01'].join('/'));

        /**
         * Event emitted when a next month is shown.
         * @event ch.Calendar#nextmonth
         * @example
         * // Subscribe to "nextmonth" event.
         * calendar.on('nextmonth', function () {
         *     // Some code here!
         * });
         */
        this.emit('nextmonth');

        return this;
    };

    /**
     * Move to the previous month.
     * @memberof! ch.Calendar.prototype
     * @function
     * @returns {calendar}
     * @example
     * // Moves to the prev month.
     * calendar.prevMonth();
     */
    Calendar.prototype.prevMonth = function () {

        if (!this._enabled || !this._hasPrevMonth()) {
            return this;
        }

        // Previous year
        if (this._dates.current.month === 1) {
            this._dates.current.month = 13;
            this._dates.current.year -= 1;
        }

        // Create a new table to the prev month
        this._updateTemplate([this._dates.current.year, this._dates.current.month - 1, '01'].join('/'));

        /**
         * Event emitted when a previous month is shown.
         * @event ch.Calendar#prevmonth
         * @example
         * // Subscribe to "prevmonth" event.
         * calendar.on('prevmonth', function () {
         *     // Some code here!
         * });
         */
        this.emit('prevmonth');

        return this;
    };

    /**
     * Move to the next year.
     * @memberof! ch.Calendar.prototype
     * @function
     * @returns {calendar}
     * @example
     * // Moves to the next year.
     * calendar.nextYear();
     */
    Calendar.prototype.nextYear = function () {

        if (!this._enabled || !this._hasNextMonth()) {
            return this;
        }

        // Create a new table of selected month
        this._updateTemplate([this._dates.current.year + 1, this._dates.current.month, '01'].join('/'));

        /**
         * Event emitted when a next year is shown.
         * @event ch.Calendar#nextyear
         * @example
         * // Subscribe to "nextyear" event.
         * calendar.on('nextyear', function () {
         *     // Some code here!
         * });
         */
        this.emit('nextyear');

        return this;
    };

    /**
     * Move to the previous year.
     * @memberof! ch.Calendar.prototype
     * @function
     * @returns {calendar}
     * @example
     * // Moves to the prev year.
     * calendar.prevYear();
     */
    Calendar.prototype.prevYear = function () {

        if (!this._enabled || !this._hasPrevMonth()) {
            return this;
        }

        // Create a new table to the prev year
        this._updateTemplate([this._dates.current.year - 1, this._dates.current.month, '01'].join('/'));

        /**
         * Event emitted when a previous year is shown.
         * @event ch.Calendar#prevyear
         * @example
         * // Subscribe to "prevyear" event.
         * calendar.on('prevyear', function () {
         *     // Some code here!
         * });
         */
        this.emit('prevyear');

        return this;
    };

    /**
     * Set a minimum selectable date.
     * @memberof! ch.Calendar.prototype
     * @function
     * @param {String} date A given date to set as minimum selectable date. The format of the given date should be "YYYY/MM/DD".
     * @returns {calendar}
     * @example
     * // Set a minimum selectable date.
     * calendar.setFrom('2010/05/28');
     */
    Calendar.prototype.setFrom = function (date) {
        // this from is a reference to the global form
        this._dates.range.from = (date === 'auto') ? undefined : createDateObject(date);
        this._updateTemplate(this._dates.current);

        return this;
    };

    /**
     * Set a maximum selectable date.
     * @memberof! ch.Calendar.prototype
     * @function
     * @param {String} date A given date to set as maximum selectable date. The format of the given date should be "YYYY/MM/DD".
     * @returns {calendar}
     * @example
     * // Set a maximum selectable date.
     * calendar.setTo('2014/05/28');
     */
    Calendar.prototype.setTo = function (date) {
        // this to is a reference to the global to
        this._dates.range.to = (date === 'auto') ? undefined : createDateObject(date);
        this._updateTemplate(this._dates.current);

        return this;
    };

    /**
     * Destroys a Calendar instance.
     * @memberof! ch.Calendar.prototype
     * @function
     * @example
     * // Destroy a calendar
     * calendar.destroy();
     * // Empty the calendar reference
     * calendar = undefined;
     */
    Calendar.prototype.destroy = function () {

        this._el.parentNode.replaceChild(this._snippet, this._el);

        tiny.trigger(window.document, ch.onlayoutchange);

        parent.destroy.call(this);

        return;
    };

    // Factorize
    ch.factory(Calendar, normalizeOptions);

}(this, this.ch));

(function (window, ch) {
    'use strict';

    /**
     * Dropdown shows a list of options for navigation.
     * @memberof ch
     * @constructor
     * @augments ch.Layer
     * @param {HTMLElement} el A HTMLElement to create an instance of ch.Dropdown.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.addClass] CSS class names that will be added to the container on the component initialization.
     * @param {String} [options.fx] Enable or disable UI effects. You must use: "slideDown", "fadeIn" or "none". Default: "none".
     * @param {String} [options.width] Set a width for the container. Default: "auto".
     * @param {String} [options.height] Set a height for the container. Default: "auto".
     * @param {String} [options.shownby] Determines how to interact with the trigger to show the container. You must use: "pointertap", "pointerenter" or "none". Default: "pointertap".
     * @param {String} [options.hiddenby] Determines how to hide the component. You must use: "button", "pointers", "pointerleave", "all" or "none". Default: "pointers".
     * @param {HTMLElement} [options.reference] It's a reference to position and size of element that will be considered to carry out the position. Default: the trigger element.
     * @param {String} [options.side] The side option where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "bottom".
     * @param {String} [options.align] The align options where the target element will be positioned. Its value can be: "left", "right", "top", "bottom" or "center". Default: "left".
     * @param {Number} [options.offsetX] The offsetX option specifies a distance to displace the target horizontally. Default: 0.
     * @param {Number} [options.offsetY] The offsetY option specifies a distance to displace the target vertically. Default: -1.
     * @param {String} [options.position] The position option specifies the type of positioning used. Its value must be "absolute" or "fixed". Default: "absolute".
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading. Default: '&lt;div class="ch-loading ch-loading-centered"&gt;&lt;/div&gt;'.
     * @param {Boolean} [options.skin] Sets a CSS class name to the trigger and container to get a variation of Dropdown. Default: false.
     * @param {Boolean} [options.shortcuts] Configures navigation shortcuts. Default: true.
     * @param {(String | HTMLElement)} [options.content] The content to be shown into the Dropdown container.
     * @returns {dropdown} Returns a new instance of Dropdown.
     * @example
     * // Create a new Dropdown.
     * var dropdown = new ch.Dropdown([el], [options]);
     * @example
     * // Create a new skinned Dropdown.
     * var dropdown = new ch.Dropdown({
     *     'skin': true
     * });
     */
    function Dropdown(el, options) {
        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Dropdown is created.
             * @memberof! ch.Dropdown.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Dropdown#ready
         * @example
         * // Subscribe to "ready" event.
         * dropdown.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Dropdown, ch.Layer);

    var parent = Dropdown.super_.prototype;

    /**
     * The name of the component.
     * @memberof! ch.Dropdown.prototype
     * @type {String}
     */
    Dropdown.prototype.name = 'dropdown';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Dropdown.prototype
     * @function
     */
    Dropdown.prototype.constructor = Dropdown;

    /**
     * Configuration by default.
     * @memberof! ch.Dropdown.prototype
     * @type {Object}
     * @private
     */
    Dropdown.prototype._defaults = tiny.extend(tiny.clone(parent._defaults), {
        '_className': 'ch-dropdown ch-box-lite',
        '_ariaRole': 'combobox',
        'fx': 'none',
        'shownby': 'pointertap',
        'hiddenby': 'pointers',
        'offsetY': -1,
        'skin': false,
        'shortcuts': true
    });

    /**
     * Initialize a new instance of Dropdown and merge custom options with defaults options.
     * @memberof! ch.Dropdown.prototype
     * @function
     * @private
     * @returns {dropdown}
     */
    Dropdown.prototype._init = function (el, options) {
        // Call to its parent init method
        parent._init.call(this, el, options);

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            // The second element of the HTML snippet (the dropdown content)
            content = tiny.next(this.trigger);

        /**
         * The dropdown trigger. It's the element that will show and hide the container.
         * @type {HTMLElement}
         */
        this.trigger.setAttribute('aria-activedescendant', 'ch-dropdown' + this.uid + '-selected');
        tiny.addClass(this.trigger, 'ch-dropdown-trigger');

        this.trigger.setAttribute('unselectable', 'on');
        tiny.addClass(this.trigger, 'ch-user-no-select');

        // Skinned dropdown
        if (this._options.skin) {
            tiny.addClass(this.trigger, 'ch-dropdown-trigger-skin');
            tiny.addClass(this.container, 'ch-dropdown-skin');
        // Default Skin
        } else {
            tiny.addClass(this.trigger, 'ch-btn-skin');
            tiny.addClass(this.trigger, 'ch-btn-small');
        }

        /**
         * A list of links with the navigation options of the component.
         * @type {NodeList}
         * @private
         */
        this._navigation = (function () {
            var items = content.querySelectorAll('a');
            Array.prototype.forEach.call(items, function (item, index) {
                item.setAttribute('role', 'option');
                tiny.on(item, ch.onpointerenter, function () {
                    that._navigation[that._selected = index].focus();
                });
            });
            return items;
        }());


        if (this._options.shortcuts && this._navigationShortcuts !== undefined) {
            this._navigationShortcuts();
        }

        this._options.content = content;

        /**
         * The original and entire element and its state, before initialization.
         * @private
         * @type {HTMLElement}
         */
        // cloneNode(true) > parameters is required. Opera & IE throws and internal error. Opera mobile breaks.
        this._snippet = this._options.content.cloneNode(true);

        return this;
    };

    /**
     * Shows the dropdown container.
     * @memberof! ch.Dropdown.prototype
     * @function
     * @param {(String | HTMLElement)} [content] The content that will be used by dropdown.
     * @param {Object} [options] A custom options to be used with content loaded by ajax.
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading.
     * @returns {dropdown}
     * @example
     * // Shows a basic dropdown.
     * dropdown.show();
     * @example
     * // Shows a dropdown with new content
     * dropdown.show('Some new content here!');
     * @example
     * // Shows a dropdown with a new content that will be loaded by ajax with some custom options
     * dropdown.show('http://domain.com/ajax/url', {
     *     'cache': false,
     *     'params': 'x-request=true'
     * });
     */
    Dropdown.prototype.show = function (content, options) {
        // Don't execute when it's disabled
        if (!this._enabled) {
            return this;
        }

        // Execute the original show()
        parent.show.call(this, content, options);

        this._selected = -1;

        return this;
    };

    /**
     * Destroys a Dropdown instance.
     * @memberof! ch.Dropdown.prototype
     * @function
     * @example
     * // Destroy a dropdown
     * dropdown.destroy();
     * // Empty the dropdown reference
     * dropdown = undefined;
     */
    Dropdown.prototype.destroy = function () {
        var trigger = this.trigger;

        [
            'ch-dropdown-trigger',
            'ch-dropdown-trigger-skin',
            'ch-user-no-select',
            'ch-btn-skin',
            'ch-btn-small'
        ].forEach(function(className){
            tiny.removeClass(trigger, className);
        });

        trigger.removeAttribute('unselectable');
        trigger.removeAttribute('aria-controls');

        trigger.insertAdjacentHTML('afterend', this._snippet);

        tiny.trigger(window.document, ch.onlayoutchange);

        parent.destroy.call(this);

        return;
    };

    ch.factory(Dropdown);

}(this, this.ch));

(function (ch) {
    'use strict';

    /**
     * Highlights the current option when navigates by keyboard.
     * @function
     * @private
     */
    ch.Dropdown.prototype._highlightOption = function (key) {

        var optionsLength = this._navigation.length;

        if (!this._shown) { return; }

        // Sets limits behavior
        if (this._selected === (key === ch.onkeydownarrow ? optionsLength - 1 : 0)) { return; }

        // Unselects current option
        if (this._selected !== -1) {
            this._navigation[this._selected].blur();
            this._navigation[this._selected].removeAttribute('id');
        }

        if (key === ch.onkeydownarrow) { this._selected += 1; } else { this._selected -= 1; }

        // Selects new current option
        this._navigation[this._selected].focus();
        this._navigation[this._selected].id = 'ch-dropdown' + this.uid + '-selected';
    };

    /**
     * Add handlers to manage the keyboard on Dropdown navigation.
     * @function
     * @private
     */
    ch.Dropdown.prototype._navigationShortcuts = function () {
        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        ch.shortcuts.add(ch.onkeyuparrow, this.uid, function (event) {
            // Prevent default behavior
            event.preventDefault();

            that._highlightOption(event.shortcut);
        });

        ch.shortcuts.add(ch.onkeydownarrow, this.uid, function (event) {
            // Prevent default behavior
            event.preventDefault();

            that._highlightOption(event.shortcut);
        });

        this.once('destroy', function () {
            ch.shortcuts.remove(ch.onkeyuparrow, that.uid);
            ch.shortcuts.remove(ch.onkeydownarrow, that.uid);
        });

        return this;
    };

}(this.ch));

(function (window, ch) {
    'use strict';

    /**
     * Tabs lets you create tabs for static and dynamic content.
     * @memberof ch
     * @constructor
     * @augments ch.Component
     * @requires ch.Expandable
     * @param {HTMLElement} el A HTMLElement to create an instance of ch.Tabs.
     * @param {Object} [options] Options to customize an instance.
     * @returns {tabs} Returns a new instance of Tabs.
     * @example
     * // Create a new Tabs.
     * var tabs = new ch.Tabs(el);
     */
    function Tabs(el, options) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Tabs is created.
             * @memberof! ch.Tabs.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Emits the event 'ready' when the component is ready to use.
         * @event ch.Tabs#ready
         * @example
         * // Subscribe to "ready" event.
         * tabs.on('ready',function () {
         *     this.show();
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Tabs, ch.Component);

    // Inheritance
    var parent = Tabs.super_.prototype,

        location = window.location,

        // Creates methods enable and disable into the prototype.
        methods = ['enable', 'disable'],
        len = methods.length,

        // Regular expresion to get hash
        hashRegExp = new RegExp('\\#!?\\/?(.[^\\?|\\&|\\s]+)');

    function createMethods(method) {
        Tabs.prototype[method] = function (tab) {
            var i;

            // Enables or disables an specifc tab panel
            if (tab !== undefined) {
                this.tabpanels[tab - 1][method]();

            // Enables or disables Tabs
            } else {

                i = this.tabpanels.length;

                while (i) {
                    this.tabpanels[i -= 1][method]();
                }

                // Executes parent method
                parent[method].call(this);

                // Updates "aria-disabled" attribute
                this._el.setAttribute('aria-disabled', !this._enabled);
            }

            return this;
        };
    }

    /**
     * The name of the component.
     * @memberof! ch.Tabs.prototype
     * @type {String}
     * @example
     * // You can reach the associated instance.
     * var tabs = $(selector).data('tabs');
     */
    Tabs.prototype.name = 'tabs';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Tabs.prototype
     * @function
     */
    Tabs.prototype.constructor = Tabs;

    /**
     * Initialize a new instance of Tabs and merge custom options with defaults options.
     * @memberof! ch.Tabs.prototype
     * @function
     * @private
     * @returns {tabs}
     */
    Tabs.prototype._init = function (el, options) {
        parent._init.call(this, el, options);

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        /**
        * The actual location hash, is used to know if there's a specific tab panel shwown.
        * @type {String}
        * @private
        */
        this._currentHash = (function () {
            var hash = location.hash.match(hashRegExp);
            return (hash !== null) ? hash[1] : '';
        }());

        // cloneNode(true) > parameters is required. Opera & IE throws and internal error. Opera mobile breaks.
        this._snippet = this._el.cloneNode(true);

        /**
         * The tabs container.
         * @type {HTMLElement}
         */
        this.container = this._el;
        tiny.addClass(this.container, 'ch-tabs');

        /**
         * The tabs triggers.
         * @type {HTMLElement}
         */
        this.triggers = this.container.children[0];
        this.triggers.setAttribute('role', 'tablist');
        tiny.addClass(this.triggers, 'ch-tabs-triggers');

        /**
         * A collection of tab panel.
         * @type {Array}
         */
        this.tabpanels = [];

        /**
         * The container of tab panels.
         * @type {HTMLElement}
         */
        this.panel = this.container.children[1];
        this.panel.setAttribute('role', 'presentation');
        tiny.addClass(this.panel, 'ch-tabs-panel');
        tiny.addClass(this.panel, 'ch-box-lite');


        /**
         * The tab panel's containers.
         * @type {HTMLElement}
         * @private
         */
        this._tabsPanels = this.panel.children;

        // Creates tab
        Array.prototype.forEach.call(this.triggers.getElementsByTagName('a'), function (el, index) {
            that._createTab(index, el);
        });

        // Set the default shown tab.
        this._shown = 1;

        // Checks if the url has a hash to shown the associated tab.
        this._hasHash();

        return this;
    };

    /**
     * Create tab panels.
     * @function
     * @private
     */
    Tabs.prototype._createTab = function (i, e) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            tab,

            panel = this._tabsPanels[i],

            // Create Tab panel's options
            options = {
                '_classNameIcon': null,
                '_classNameTrigger': 'ch-tab',
                '_classNameContainer': 'ch-tabpanel',
                'toggle': false
            };

        // Tab panel async configuration
        if (panel === undefined) {

            panel = document.createElement('div');
            panel.setAttribute('id', e.href.split('#')[1]);

            this.panel.appendChild(panel);

            options.content = e.href;
            options.waiting = this._options.waiting;
            options.cache = this._options.cache;
            options.method = this._options.method;
        }

        // Tab panel container configuration
        options.container = panel;

        // Creates new Tab panel
        tab = new ch.Expandable(e, options);

        // Creates tab's hash
        tab._hash = e.href.split('#')[1];

        // Add ARIA roles
        tab.trigger.setAttribute('role', 'tab');
        tab.container.setAttribute('role', 'tabpanel');

        // Binds show event
        tab.on('show', function () {
            that._updateShown(i + 1);
        });

        // Adds tab panel to the collection
        this.tabpanels.push(tab);

        return this;
    };

    /**
     * Checks if the url has a hash to shown the associated tab panel.
     * @function
     * @private
     */
    Tabs.prototype._hasHash = function () {

        /**
         * Event emitted when a tab hide a tab panel container.
         * @event ch.Tabs#hide
         * @example
         * // Subscribe to "hide" event.
         * tabs.on('hide', function () {
         *     // Some code here!
         * });
         */
        this.emit('hide', this._shown);

        var i = 0,
            // Shows the first tab panel if not hash or it's hash and it isn't from the current tab panel,
            l = this.tabpanels.length;

        // If hash open that tab panel
        for (i; i < l; i += 1) {
            if (this.tabpanels[i]._hash === this._currentHash) {
                this._shown = i + 1;
                break;
            }
        }

        this.tabpanels[this._shown - 1].show();

        /**
         * Event emitted when the tabs shows a tab panel container.
         * @event ch.Tabs#show
         * @ignore
         */
        this.emit('show', this._shown);

        return this;
    };

    /**
     * Shows a specific tab panel.
     * @memberof! ch.Tabs.prototype
     * @function
     * @param {Number} tab - A given number of tab panel.
     * @returns {tabs}
     * @example
     * // Shows the second tab panel.
     * tabs.show(2);
     */
    Tabs.prototype.show = function (tab) {

        // Shows the current tab
        this.tabpanels[tab - 1].show();

        return this;
    };

    /**
     * Updates the shown tab panel, hides the previous tab panel, changes window location and emits "show" event.
     * @memberof! ch.Tabs.prototype
     * @function
     * @private
     * @param {Number} tab - A given number of tab panel.
     */
    Tabs.prototype._updateShown = function (tab) {

        // If tab doesn't exist or if it's shown do nothing
        if (this._shown === tab) {
            return this;
        }

        /**
         * Event emitted when a tab hide a tab panel container.
         * @event ch.Tabs#hide
         * @example
         * // Subscribe to "hide" event.
         * tabs.on('hide', function () {
         *     // Some code here!
         * });
         */
        this.emit('hide', this._shown);

        // Hides the shown tab
        this.tabpanels[this._shown - 1].hide();

        /**
         * Get wich tab panel is shown.
         * @name ch.Tabs#_shown
         * @type {Number}
         * @private
         */
        this._shown = tab;

        // Update window location hash
        location.hash = this._currentHash = (this._currentHash === '')
            // If the current hash is empty, create it.
            ? '#!/' + this.tabpanels[this._shown - 1]._hash
            // update only the previous hash
            : location.hash.replace(location.hash.match(hashRegExp)[1], this.tabpanels[this._shown - 1]._hash);

        /**
         * Event emitted when the tabs shows a tab panel container.
         * @event ch.Tabs#show
         * @example
         * // Subscribe to "show" event.
         * tabs.on('show', function (shownTab) {
         *     // Some code here!
         * });
         */
        this.emit('show', this._shown);

        return this;
    };

    /**
     * Returns the number of the shown tab panel.
     * @memberof! ch.Tabs.prototype
     * @function
     * @returns {Boolean}
     * @example
     * if (tabs.getShown() === 1) {
     *     fn();
     * }
     */
    Tabs.prototype.getShown = function () {
        return this._shown;
    };

    /**
     * Allows to manage the tabs content.
     * @param {Number} tab A given tab to change its content.
     * @param {HTMLElement} content The content that will be used by a tabpanel.
     * @param {Object} [options] A custom options to be used with content loaded by ajax.
     * @param {String} [options.method] The type of request ("POST" or "GET") to load content by ajax. Default: "GET".
     * @param {String} [options.params] Params like query string to be sent to the server.
     * @param {Boolean} [options.cache] Force to cache the request by the browser. Default: true.
     * @param {Boolean} [options.async] Force to sent request asynchronously. Default: true.
     * @param {(String | HTMLElement)} [options.waiting] Temporary content to use while the ajax request is loading.
     * @example
     * // Updates the content of the second tab with some string.
     * tabs.content(2, 'http://ajax.com', {'cache': false});
     */
    Tabs.prototype.content = function (tab, content, options) {
        if (tab === undefined || typeof tab !== 'number') {
            throw new window.Error('Tabs.content(tab, content, options): Expected a number of tab.');
        }

        if (content === undefined) {
            return this.tab[tab - 1].content();
        }

        this.tabpanels[tab - 1].content(content, options);

        return this;
    };

    /**
     * Enables an instance of Tabs or a specific tab panel.
     * @memberof! ch.Tabs.prototype
     * @name enable
     * @function
     * @param {Number} [tab] - A given number of tab panel to enable.
     * @returns {tabs} Returns an instance of Tabs.
     * @example
     * // Enabling an instance of Tabs.
     * tabs.enable();
     * @example
     * // Enabling the second tab panel of a tabs.
     * tabs.enable(2);
     */

    /**
     * Disables an instance of Tabs or a specific tab panel.
     * @memberof! ch.Tabs.prototype
     * @name disable
     * @function
     * @param {Number} [tab] - A given number of tab panel to disable.
     * @returns {tabs} Returns an instance of Tabs.
     * @example
     * // Disabling an instance of Tabs.
     * tabs.disable();
     * @example
     * // Disabling the second tab panel.
     * tabs.disable(2);
     */
    while (len) {
        createMethods(methods[len -= 1]);
    }

    /**
     * Destroys a Tabs instance.
     * @memberof! ch.Tabs.prototype
     * @function
     * @example
     * // Destroying an instance of Tabs.
     * tabs.destroy();
     */
    Tabs.prototype.destroy = function () {

        this._el.parentNode.replaceChild(this._snippet, this._el);

        tiny.trigger(window.document, ch.onlayoutchange);

        parent.destroy.call(this);
    };

    /**
     * Factory
     */
    ch.factory(Tabs);

}(this, this.ch));

(function (window, ch) {
    'use strict';

    /**
     * A large list of elements. Some elements will be shown in a preset area, and others will be hidden waiting for the user interaction to show it.
     * @memberof ch
     * @constructor
     * @param {HTMLElement} el A HTMLElement to create an instance of ch.Carousel.
     * @param {Object} [options] Options to customize an instance.
     * @param {Number} [options.async] Defines the number of future asynchronous items to add to the component. Default: 0.
     * @param {Boolean} [options.arrows] Defines if the arrow-buttons must be created or not at initialization. Default: true.
     * @param {Boolean} [options.pagination] Defines if a pagination must be created or not at initialization. Default: false.
     * @param {Boolean} [options.fx] Enable or disable the slide effect. Default: true.
     * @param {Boolean} [options.autoHeight] Enable or disable the recalculation of item height on a proportional basis maintaining the proportions of an item. Default: true.
     * @param {Boolean} [options.autoMargin] Enable or disable the addition of a proportional margin to each item. Default: true.
     * @param {Number} [options.limitPerPage] Set the maximum amount of items to show in each page.
     * @returns {carousel} Returns a new instance of Carousel.
     * @example
     * // Create a new carousel.
     * var carousel = new ch.Carousel(el, [options]);
     * @example
     * // Create a new Carousel with disabled effects.
     * var carousel = new ch.Carousel(el, {
     *     'fx': false
     * });
     * @example
     * // Create a new Carousel with items asynchronously loaded.
     * var carousel = new ch.Carousel(el, {
     *     'async': 10
     * }).on('itemsadd', function (collection) {
     *     // Inject content into the added <li> elements
     *     $.each(collection, function (i, e) {
     *         e.innerHTML = 'Content into one of newly inserted <li> elements.';
     *     });
     * });
     */
    function Carousel(el, options) {
        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Carousel is created.
             * @memberof! ch.Carousel.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Carousel#ready
         * @example
         * // Subscribe to "ready" event.
         * carousel.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Carousel, ch.Component);

    var pointertap = ch.onpointertap,
        Math = window.Math,
        setTimeout = window.setTimeout,
        parent = Carousel.super_.prototype;

    /**
     * Reference to the vendor prefix of the current browser.
     *
     * @private
     * @constant
     * @type {String}
     * @link http://lea.verou.me/2009/02/find-the-vendor-prefix-of-the-current-browser
     * @example
     * VENDOR_PREFIX === 'webkit';
     */
    var VENDOR_PREFIX = (function () {

        var regex = /^(Webkit|Khtml|Moz|ms|O)(?=[A-Z])/,
            styleDeclaration = document.getElementsByTagName('script')[0].style,
            prop;

        for (prop in styleDeclaration) {
            if (regex.test(prop)) {
                return prop.match(regex)[0].toLowerCase();
            }
        }

        // Nothing found so far? Webkit does not enumerate over the CSS properties of the style object.
        // However (prop in style) returns the correct value, so we'll have to test for
        // the precence of a specific property
        if ('WebkitOpacity' in styleDeclaration) { return 'webkit'; }
        if ('KhtmlOpacity' in styleDeclaration) { return 'khtml'; }

        return '';
    }());

    /**
     * The name of the component.
     * @memberof! ch.Carousel.prototype
     * @type {String}
     */
    Carousel.prototype.name = 'carousel';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Carousel.prototype
     * @function
     */
    Carousel.prototype.constructor = Carousel;

    /**
     * Configuration by default.
     * @memberof! ch.Carousel.prototype
     * @type {Object}
     * @private
     */
    Carousel.prototype._defaults = {
        'async': 0,
        'arrows': true,
        'pagination': false,
        'fx': true,
        'autoHeight': true,
        'autoMargin': true
    };

    /**
     * Initialize a new instance of Carousel and merge custom options with defaults options.
     * @memberof! ch.Carousel.prototype
     * @function
     * @private
     * @returns {carousel}
     */
    Carousel.prototype._init = function (el, options) {
        // Call to its parents init method
        parent._init.call(this, el, options);

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        /**
         * The original and entire element and its state, before initialization.
         * @type {HTMLDivElement}
         * @private
         */
        // cloneNode(true) > parameters is required. Opera & IE throws and internal error. Opera mobile breaks.
        this._snippet = this._el.cloneNode(true);

        /**
         * Element that moves (slides) across the component (inside the mask).
         * @private
         * @type {HTMLElement}
         */
        this._list = this._el.children[0];

        tiny.addClass(this._el, 'ch-carousel');
        tiny.addClass(this._list, 'ch-carousel-list');

        /**
         * Collection of each child of the slider list.
         * @private
         * @type {HTMLCollection}
         */
        this._items = (function () {
            var collection = that._list.querySelectorAll('li');

            Array.prototype.forEach.call(collection, function (item) {
                tiny.addClass(item, 'ch-carousel-item');
            });

            return collection;
        }());

        /**
         * Element that wraps the list and denies its overflow.
         * @private
         * @type {HTMLDivElement}
         */
        this._mask = document.createElement('div');
        this._mask.setAttribute('role', 'tabpanel');
        this._mask.setAttribute('class','ch-carousel-mask');
        this._mask.appendChild(this._list);

        this._el.appendChild(this._mask);

        /**
         * Size of the mask (width). Updated in each refresh.
         * @private
         * @type {Number}
         */
        this._maskWidth = this._getOuterDimensions(this._mask).width;

        /**
         * The width of each item, including paddings, margins and borders. Ideal for make calculations.
         * @private
         * @type {Number}
         */
        this._itemWidth = this._getOuterDimensions(this._items[0]).width;

        /**
         * The width of each item, without paddings, margins or borders. Ideal for manipulate CSS width property.
         * @private
         * @type {Number}
         */
        this._itemOuterWidth = parseInt(tiny.css(this._items[0], 'width'));

        /**
         * The size added to each item to make it elastic/responsive.
         * @private
         * @type {Number}
         */
        this._itemExtraWidth = 0;

        /**
         * The height of each item, including paddings, margins and borders. Ideal for make calculations.
         * @private
         * @type {Number}
         */
        this._itemHeight = this._getOuterDimensions(this._items[0]).height;

        /**
         * The margin of all items. Updated in each refresh only if it's necessary.
         * @private
         * @type {Number}
         */
        this._itemMargin = 0;

        /**
         * Flag to control when arrows were created.
         * @private
         * @type {Boolean}
         */
        this._arrowsCreated = false;

        /**
         * Flag to control when pagination was created.
         * @private
         * @type {Boolean}
         */
        this._paginationCreated = false;

        /**
         * Amount of items in each page. Updated in each refresh.
         * @private
         * @type {Number}
         */
        this._limitPerPage = 0;

        /**
         * Page currently showed.
         * @private
         * @type {Number}
         */
        this._currentPage = 1;

        /**
         * Total amount of pages. Data updated in each refresh.
         * @private
         * @type {Number}
         */
        this._pages = 0;

        /**
         * Distance needed to move ONLY ONE PAGE. Data updated in each refresh.
         * @private
         * @type {Number}
         */
        this._pageWidth = 0;

        /**
         * List of items that should be loaded asynchronously on page movement.
         * @private
         * @type {Number}
         */
        this._async = this._options.async;

        /**
         * UI element of arrow that moves the Carousel to the previous page.
         * @private
         * @type {HTMLDivElement}
         */
        this._prevArrow = document.createElement('div');
        this._prevArrow.setAttribute('role', 'button');
        this._prevArrow.setAttribute('aria-hidden', 'true');
        this._prevArrow.setAttribute('class', 'ch-carousel-prev ch-carousel-disabled');
        tiny.on(this._prevArrow, pointertap, function () { that.prev(); }, false);

        /**
         * UI element of arrow that moves the Carousel to the next page.
         * @private
         * @type {HTMLDivElement}
         */
        this._nextArrow = document.createElement('div');
        this._nextArrow.setAttribute('role', 'button');
        this._nextArrow.setAttribute('aria-hidden', 'true');
        this._nextArrow.setAttribute('class', 'ch-carousel-next');
        tiny.on(this._nextArrow, pointertap, function () { that.next(); }, false);

        /**
         * UI element that contains all the thumbnails for pagination.
         * @private
         * @type {HTMLDivElement}
         */
        this._pagination = document.createElement('div');
        this._pagination.setAttribute('role', 'navigation');
        this._pagination.setAttribute('class', 'ch-carousel-pages');

        tiny.on(this._pagination, pointertap, function (event) {
            // Get the page from the element
            var page = event.target.getAttribute('data-page');
            // Allow interactions from a valid page of pagination
            if (page !== null) { that.select(window.parseInt(page, 10)); }
        }, false);

        // Refresh calculation when the viewport resizes
        ch.viewport.on('resize', function () { that.refresh(); });

        // If efects aren't needed, avoid transition on list
        if (!this._options.fx) { tiny.addClass(this._list, 'ch-carousel-nofx'); }

        // Position absolutelly the list when CSS transitions aren't supported
        if (!tiny.support.transition) {
            this._list.style.cssText += 'position:absolute;left:0;';
        }

        // If there is a parameter specifying a pagination, add it
        if (this._options.pagination) { this._addPagination(); }

        // Allow to render the arrows
        if (this._options.arrows !== undefined && this._options.arrows !== false) { this._addArrows(); }

        // Set WAI-ARIA properties to each item depending on the page in which these are
        this._updateARIA();

        // Calculate items per page and calculate pages, only when the amount of items was changed
        this._updateLimitPerPage();

        // Update the margin between items and its size
        this._updateDistribution();

        return this;
    };

    /**
     * Set accesibility properties to each item depending on the page in which these are.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     */
    Carousel.prototype._updateARIA = function () {
        /**
         * Reference to an internal component instance, saves all the information and configuration properties.
         * @type {Object}
         * @private
         */
        var that = this,
            // Amount of items when ARIA is updated
            total = this._items.length + this._async,
            // Page where each item is in
            page;

        // Update WAI-ARIA properties on all items
        Array.prototype.forEach.call(this._items, function (item, i) {
            // Update page where this item is in
            page = Math.floor(i / that._limitPerPage) + 1;
            // Update ARIA attributes
            item.setAttribute('aria-hidden', (page !== that._currentPage));
            item.setAttribute('aria-setsize', total);
            item.setAttribute('aria-posinset', (i + 1));
            item.setAttribute('aria-label', 'page' + page);
        });

    };

    /**
     * Adds items when page/pages needs to load it asynchronously.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     */
    Carousel.prototype._loadAsyncItems = function () {

        // Load only when there are items to load
        if (this._async === 0) { return; }

        // Amount of items from the beginning to current page
        var total = this._currentPage * this._limitPerPage,
            // How many items needs to add to items rendered to complete to this page
            amount = total - this._items.length,
            // The new width calculated from current width plus extraWidth
            width = (this._itemWidth + this._itemExtraWidth),
            // Get the height using new width and relation between width and height of item (ratio)
            height = ((width * this._itemHeight) / this._itemWidth).toFixed(3),
            // Generic <LI> HTML Element to be added to the Carousel
            item = [
                '<li',
                ' class="ch-carousel-item"',
                ' style="width:' + (width % 1 === 0 ? width : width.toFixed(4)) + 'px;',
                (this._options.autoHeight ? 'height:' + height + 'px;' : ''),
                (this._options.autoMargin ? 'margin-right:' + (this._itemMargin % 1 === 0 ? this._itemMargin : this._itemMargin.toFixed(4)) + 'px"' : '"'),
                '></li>'
            ].join(''),
            // It stores <LI> that will be added to the DOM collection
            items = '',
            // It stores the items that must be added, it helps to slice the items in the list
            counter = 0;

        // Load only when there are items to add
        if (amount < 1) { return; }

        // If next page needs less items than it support, then add that amount
        amount = (this._async < amount) ? this._async : amount;

        // Add the necessary amount of items
        while (amount) {
            items += item;
            amount -= 1;
            counter += 1;
        }

        // Add sample items to the list
        this._list.insertAdjacentHTML('beforeend', items);

        // Update items collection
        // uses querySelectorAll because it need a static collection
        this._items = this._list.querySelectorAll('li');

        // Set WAI-ARIA properties to each item
        this._updateARIA();

        // Update amount of items to add asynchronously
        this._async -= amount;

        /**
         * Event emitted when the component creates new asynchronous empty items.
         * @event ch.Carousel#itemsadd
         * @example
         * // Create a new Carousel with items asynchronously loaded.
         * var carousel = new ch.Carousel({
         *     'async': 10
         * }).on('itemsadd', function (collection) {
         *     // Inject content into the added <li> elements
         *     $.each(collection, function (i, e) {
         *         e.innerHTML = 'Content into one of newly inserted <li> elements.';
         *     });
         * });
         */
        this.emit('itemsadd', Array.prototype.slice.call(this._items, -counter));
    };

    /**
     * Creates the pagination of the component.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     */
    Carousel.prototype._addPagination = function () {
        // Remove the current pagination if it's necessary to create again
        if (this._paginationCreated) {
            this._removePagination();
        }

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            thumbs = [],
            page = that._pages,
            isSelected;

        // Generate a thumbnail for each page on Carousel
        while (page) {
            // Determine if this thumbnail is selected or not
            isSelected = (page === that._currentPage);
            // Add string to collection
            thumbs.unshift(
                '<span',
                ' role="button"',
                ' aria-selected="' + isSelected + '"',
                ' aria-controls="page' + page + '"',
                ' data-page="' + page + '"',
                ' class="' + (isSelected ? 'ch-carousel-selected' : '') + '"',
                '>' + page + '</span>'
            );

            page -= 1;
        }

        // Append thumbnails to pagination and append this to Carousel
        that._pagination.innerHTML = thumbs.join('');
        that._el.appendChild(that._pagination);

        // Avoid selection on the pagination
        that._pagination.setAttribute('unselectable', 'on');
        tiny.addClass(that._pagination, 'ch-user-no-select');

        // Check pagination as created
        that._paginationCreated = true;
    };

    /**
     * Deletes the pagination from the component.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     */
    Carousel.prototype._removePagination = function () {
        // Avoid to change something that not exists
        if (!this._paginationCreated) { return; }
        // Delete thumbnails
        this._pagination.innerHTML = '';
        // Check pagination as deleted
        this._paginationCreated = false;
    };

    /**
     * It stops the slide effect while the list moves.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     * @param {Function} callback A function to execute after disable the effects.
     */
    Carousel.prototype._standbyFX = function (callback) {
        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        // Do it if is required
        if (this._options.fx && tiny.support.transition) {
            // Delete efects on list to make changes instantly
            tiny.addClass(this._list, 'ch-carousel-nofx');
            // Execute the custom method
            callback.call(this);
            // Restore efects to list
            // Use a setTimeout to be sure to do this AFTER changes
            setTimeout(function () { tiny.removeClass(that._list, 'ch-carousel-nofx'); }, 0);
        // Avoid to add/remove classes if it hasn't effects
        } else {
            callback.call(this);
        }
    };

    /**
     * Calculates the total amount of pages and executes internal methods to load asynchronous items, update WAI-ARIA, update the arrows and update pagination.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     */
    Carousel.prototype._updatePages = function () {
        // Update the amount of total pages
        // The ratio between total amount of items and items in each page
        this._pages = Math.ceil((this._items.length + this._async) / this._limitPerPage);
        // Add items to the list, if it's necessary
        this._loadAsyncItems();
        // Set WAI-ARIA properties to each item
        this._updateARIA();
        // Update arrows (when pages === 1, there is no arrows)
        this._updateArrows();
        // Update pagination
        if (this._options.pagination) {
            this._addPagination();
        }
    };

    /**
     * Calculates the correct items per page and calculate pages, only when the amount of items was changed.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     */
    Carousel.prototype._updateLimitPerPage = function () {

        var max = this._options.limitPerPage,
            // Go to the current first item on the current page to restore if pages amount changes
            firstItemOnPage,
            // The width of each item into the width of the mask
            // Avoid zero items in a page
            limitPerPage = Math.floor(this._maskWidth / this._itemOuterWidth) || 1;

        // Limit amount of items when user set a limitPerPage amount
        if (max !== undefined && limitPerPage > max) { limitPerPage = max; }

        // Set data and calculate pages, only when the amount of items was changed
        if (limitPerPage === this._limitPerPage) { return; }

        // Restore if limitPerPage is NOT the same after calculations (go to the current first item page)
        firstItemOnPage = ((this._currentPage - 1) * this._limitPerPage) + 1;
        // Update amount of items into a single page (from conf or auto calculations)
        this._limitPerPage = limitPerPage;
        // Calculates the total amount of pages and executes internal methods
        this._updatePages();
        // Go to the current first item page
        this.select(Math.ceil(firstItemOnPage / limitPerPage));
    };

    /**
     * Calculates and set the size of the items and its margin to get an adaptive Carousel.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     */
    Carousel.prototype._updateDistribution = function () {
        var moreThanOne = this._limitPerPage > 1,
            // Total space to use as margin into mask
            // It's the difference between mask width and total width of all items
            freeSpace = this._maskWidth - (this._itemOuterWidth * this._limitPerPage),
            // Defines how to distribute the freeSpace.
            freeSpaceDistribution = this._options.autoMargin ? (freeSpace / this._limitPerPage / 2) : (freeSpace / this._limitPerPage),
            // Width to add to each item to get responsivity
            // When there are more than one item, get extra width for each one
            // When there are only one item, extraWidth must be just the freeSpace
            extraWidth = moreThanOne ? freeSpaceDistribution : freeSpace,
            // Amount of spaces to distribute the free space
            spaces,
            // The new width calculated from current width plus extraWidth
            width,
            // Styles to update the item element width, height & margin-right
            cssItemText;

        // Update ONLY IF margin changed from last refresh
        // If *new* and *old* extra width are 0, continue too
        if (extraWidth === this._itemExtraWidth && extraWidth > 0) { return; }

        // Update global value of width
        this._itemExtraWidth = extraWidth;

        // When there are 6 items on a page, there are 5 spaces between them
        // Except when there are only one page that NO exist spaces
        spaces = moreThanOne ? this._limitPerPage - 1 : 0;
        // The new width calculated from current width plus extraWidth
        width = this._itemWidth + extraWidth;

        // Free space for each space between items
        // Ceil to delete float numbers (not Floor, because next page is seen)
        // There is no margin when there are only one item in a page
        // Update global values
        this._itemMargin = this._options.autoMargin && moreThanOne ? (freeSpace / spaces / 2) : 0;

        // Update distance needed to move ONLY ONE page
        // The width of all items on a page, plus the width of all margins of items
        this._pageWidth = (this._itemOuterWidth + extraWidth + this._itemMargin) * this._limitPerPage;

        // Update the list width
        // Do it before item resizing to make space to all items
        // Delete efects on list to change width instantly
        this._standbyFX(function () {
            this._list.style.cssText = this._list.style.cssText + '; ' + 'width:' + (this._pageWidth * this._pages) + 'px;';
        });

        // Get the height using new width and relation between width and height of item (ratio)
        cssItemText = [
            'width:' + (width % 1 === 0 ? width : width.toFixed(4)) + 'px;',
            this._options.autoHeight ? 'height:' + ((width * this._itemHeight) / this._itemWidth).toFixed(4) + 'px;' : '',
            this._options.autoMargin ? 'margin-right:' + (this._itemMargin % 1 === 0 ? this._itemMargin : this._itemMargin.toFixed(4)) + 'px;' : ''
        ].join('');

        // Update element styles
        Array.prototype.forEach.call(this._items, function (item){
            item.setAttribute('style', cssItemText);
        });

        // Update the mask height with the list height
        this._mask.style.height = this._getOuterDimensions(this._list).height + 'px';

        // Suit the page in place
        this._standbyFX(function () {
            this._translate(-this._pageWidth * (this._currentPage - 1));
        });
    };

    /**
     * Adds arrows to the component.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     */
    Carousel.prototype._addArrows = function () {
        // Avoid selection on the arrows
        [this._prevArrow, this._nextArrow].forEach(function(el){
            el.setAttribute('unselectable', 'on');
            tiny.addClass(el, 'ch-user-no-select');
        });

        // Add arrows to DOM
        this._el.insertBefore(this._prevArrow, this._el.children[0]);
        this._el.appendChild(this._nextArrow);
        // Check arrows as created
        this._arrowsCreated = true;
    };

    /**
     * Set as disabled the arrows by adding a classname and a WAI-ARIA property.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     * @param {Boolean} prev Defines if the "previous" arrow must be disabled or not.
     * @param {Boolean} next Defines if the "next" arrow must be disabled or not.
     */
    Carousel.prototype._disableArrows = function (prev, next) {
        this._prevArrow.setAttribute('aria-disabled', prev);
        this._prevArrow.setAttribute('aria-hidden', prev);
        tiny[prev ? 'addClass' : 'removeClass'](this._prevArrow, 'ch-carousel-disabled');

        this._nextArrow.setAttribute('aria-disabled', next);
        this._nextArrow.setAttribute('aria-hidden', next);
        tiny[next ? 'addClass' : 'removeClass'](this._nextArrow, 'ch-carousel-disabled');
    };

    /**
     * Check for arrows behavior on first, last and middle pages, and update class name and WAI-ARIA values.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     */
    Carousel.prototype._updateArrows = function () {
        // Check arrows existency
        if (!this._arrowsCreated) {
            return;
        }
        // Case 1: Disable both arrows if there are ony one page
        if (this._pages === 1) {
            this._disableArrows(true, true);
        // Case 2: "Previous" arrow hidden on first page
        } else if (this._currentPage === 1) {
            this._disableArrows(true, false);
        // Case 3: "Next" arrow hidden on last page
        } else if (this._currentPage === this._pages) {
            this._disableArrows(false, true);
        // Case 4: Enable both arrows on Carousel's middle
        } else {
            this._disableArrows(false, false);
        }
    };

    /**
     * Moves the list corresponding to specified displacement.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     * @param {Number} displacement Distance to move the list.
     */
    Carousel.prototype._translate = (function () {
        // CSS property written as string to use on CSS movement
        var vendorTransformKey = VENDOR_PREFIX ? VENDOR_PREFIX + 'Transform' : null;

        // Use CSS transform to move
        if (tiny.support.transition) {
            return function (displacement) {
                // Firefox has only "transform", Safari only "webkitTransform",
                // Chrome has support for both. Applied required minimum
                if (vendorTransformKey) {
                    this._list.style[vendorTransformKey] = 'translateX(' + displacement + 'px)';
                }
                this._list.style.transform = 'translateX(' + displacement + 'px)';
            };
        }

        // Use left position to move
        return function (displacement) {
            this._list.style.left = displacement + 'px';
        };
    }());

    /**
     * Updates the selected page on pagination.
     * @memberof! ch.Carousel.prototype
     * @private
     * @function
     * @param {Number} from Page previously selected. It will be unselected.
     * @param {Number} to Page to be selected.
     */
    Carousel.prototype._switchPagination = function (from, to) {
        // Avoid to change something that not exists
        if (!this._paginationCreated) { return; }
        // Get all thumbnails of pagination element
        var children = this._pagination.children,
            fromItem = children[from - 1],
            toItem = children[to - 1];

        // Unselect the thumbnail previously selected
        fromItem.setAttribute('aria-selected', false);
        tiny.removeClass(fromItem, 'ch-carousel-selected');

        // Select the new thumbnail
        toItem.setAttribute('aria-selected', true);
        tiny.addClass(toItem, 'ch-carousel-selected');
    };

    /**
     * Get the current outer dimensions of an element.
     *
     * @memberof ch.Carousel.prototype
     * @param {HTMLElement} el A given HTMLElement.
     * @returns {Object}
     */
    Carousel.prototype._getOuterDimensions = function (el) {
        var obj = el.getBoundingClientRect();

        return {
            'width': (obj.right - obj.left),
            'height': (obj.bottom - obj.top)
        };
    };

    /**
     * Triggers all the necessary recalculations to be up-to-date.
     * @memberof! ch.Carousel.prototype
     * @function
     * @returns {carousel}
     */
    Carousel.prototype.refresh = function () {

        var that = this,
            maskWidth = this._getOuterDimensions(this._mask).width;

        // Check for changes on the width of mask, for the elastic carousel
        // Update the width of the mask
        if (maskWidth !== this._maskWidth) {
            // Update the global reference to the with of the mask
            this._maskWidth = maskWidth;
            // Calculate items per page and calculate pages, only when the amount of items was changed
            this._updateLimitPerPage();
            // Update the margin between items and its size
            this._updateDistribution();

            /**
             * Event emitted when the component makes all the necessary recalculations to be up-to-date.
             * @event ch.Carousel#refresh
             * @example
             * // Subscribe to "refresh" event.
             * carousel.on('refresh', function () {
             *     alert('Carousel was refreshed.');
             * });
             */
            this.emit('refresh');
        }

        // Check for a change in the total amount of items
        // Update items collection
        if (this._list.children.length !== this._items.length) {
            // Update the entire reference to items
            // uses querySelectorAll because it need a static collection
            this._items = this._list.querySelectorAll('li');
            // Calculates the total amount of pages and executes internal methods
            this._updatePages();
            // Go to the last page in case that the current page no longer exists
            if (this._currentPage > this._pages) {
                this._standbyFX(function () {
                    that.select(that._pages);
                });
            }

            /**
             * Event emitted when the component makes all the necessary recalculations to be up-to-date.
             * @event ch.Carousel#refresh
             * @ignore
             */
            this.emit('refresh');
        }

        return this;
    };

    /**
     * Moves the list to the specified page.
     * @memberof! ch.Carousel.prototype
     * @function
     * @param {Number} page Reference of page where the list has to move.
     * @returns {carousel}
     */
    Carousel.prototype.select = function (page) {
        // Getter
        if (page === undefined) {
            return this._currentPage;
        }

        // Avoid to move if it's disabled
        // Avoid to select the same page that is selected yet
        // Avoid to move beyond first and last pages
        if (!this._enabled || page === this._currentPage || page < 1 || page > this._pages) {
            return this;
        }

        // Perform these tasks in the following order:
        // Task 1: Move the list from 0 (zero), to page to move (page number beginning in zero)
        this._translate(-this._pageWidth * (page - 1));
        // Task 2: Update selected thumbnail on pagination
        this._switchPagination(this._currentPage, page);
        // Task 3: Update value of current page
        this._currentPage = page;
        // Task 4: Check for arrows behavior on first, last and middle pages
        this._updateArrows();
        // Task 5: Add items to the list, if it's necessary
        this._loadAsyncItems();

        /**
         * Event emitted when the component moves to another page.
         * @event ch.Carousel#select
         * @example
         * // Subscribe to "select" event.
         * carousel.on('select', function () {
         *     alert('Carousel was moved.');
         * });
         */
        this.emit('select');

        return this;
    };

    /**
     * Moves the list to the previous page.
     * @memberof! ch.Carousel.prototype
     * @function
     * @returns {carousel}
     */
    Carousel.prototype.prev = function () {

        this.select(this._currentPage - 1);

        /**
         * Event emitted when the component moves to the previous page.
         * @event ch.Carousel#prev
         * @example
         * carousel.on('prev', function () {
         *     alert('Carousel has moved to the previous page.');
         * });
         */
        this.emit('prev');

        return this;
    };

    /**
     * Moves the list to the next page.
     * @memberof! ch.Carousel.prototype
     * @function
     * @returns {carousel}
     */
    Carousel.prototype.next = function () {

        this.select(this._currentPage + 1);

        /**
         * Event emitted when the component moves to the next page.
         * @event ch.Carousel#next
         * @example
         * carousel.on('next', function () {
         *     alert('Carousel has moved to the next page.');
         * });
         */
        this.emit('next');

        return this;
    };

    /**
     * Enables a Carousel instance.
     * @memberof! ch.Carousel.prototype
     * @function
     * @returns {carousel}
     */
    Carousel.prototype.enable = function () {

        this._el.setAttribute('aria-disabled', false);

        this._disableArrows(false, false);

        parent.enable.call(this);

        return this;
    };

    /**
     * Disables a Carousel instance.
     * @memberof! ch.Carousel.prototype
     * @function
     * @returns {carousel}
     */
    Carousel.prototype.disable = function () {

        this._el.setAttribute('aria-disabled', true);

        this._disableArrows(true, true);

        parent.disable.call(this);

        return this;
    };

    /**
     * Destroys a Carousel instance.
     * @memberof! ch.Carousel.prototype
     * @function
     */
    Carousel.prototype.destroy = function () {

        this._el.parentNode.replaceChild(this._snippet, this._el);

        tiny.trigger(window.document, ch.onlayoutchange);

        parent.destroy.call(this);

        return;
    };

    ch.factory(Carousel);

}(this, this.ch));

(function (window, ch) {
    'use strict';

    function normalizeOptions(options) {
        var num = window.parseInt(options, 10);

        if (!window.isNaN(num)) {
            options = {
                'max': num
            };
        }

        return options;
    }

    /**
     * Countdown counts the maximum of characters that user can enter in a form control. Countdown could limit the possibility to continue inserting charset.
     * @memberof ch
     * @constructor
     * @augments ch.Component
     * @param {HTMLElement} el A HTMLElement to create an instance of ch.Countdown.
     * @param {Object} [options] Options to customize an instance.
     * @param {Number} [options.max] Number of the maximum amount of characters user can input in form control. Default: 500.
     * @param {String} [options.plural] Message of remaining amount of characters, when it's different to 1. The variable that represents the number to be replaced, should be a hash. Default: "# characters left.".
     * @param {String} [options.singular] Message of remaining amount of characters, when it's only 1. The variable that represents the number to be replaced, should be a hash. Default: "# character left.".
     * @returns {countdown} Returns a new instance of Countdown.
     * @example
     * // Create a new Countdown.
     * var countdown = new ch.Countdown([el], [options]);
     * @example
     * // Create a new Countdown with custom options.
     * var countdown = new ch.Countdown({
     *     'max': 250,
     *     'plural': 'Left: # characters.',
     *     'singular': 'Left: # character.'
     * });
     * @example
     * // Create a new Countdown using the shorthand way (max as parameter).
     * var countdown = new ch.Countdown({'max': 500});
     */
    function Countdown(el, options) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Countdown is created.
             * @memberof! ch.Countdown.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Countdown#ready
         * @example
         * // Subscribe to "ready" event.
         * countdown.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Countdown, ch.Component);

    var parent = Countdown.super_.prototype;

    /**
     * The name of the component.
     * @memberof! ch.Countdown.prototype
     * @type {String}
     */
    Countdown.prototype.name = 'countdown';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Countdown.prototype
     * @function
     */
    Countdown.prototype.constructor = Countdown;

    /**
     * Configuration by default.
     * @type {Object}
     * @private
     */
    Countdown.prototype._defaults = {
        'plural': '# characters left.',
        'singular': '# character left.',
        'max': 500
    };

    /**
     * Initialize a new instance of Countdown and merge custom options with defaults options.
     * @memberof! ch.Countdown.prototype
     * @function
     * @private
     * @returns {countdown}
     */
    Countdown.prototype._init = function (el, options) {
        // Call to its parent init method
        parent._init.call(this, el, options);

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,

            /**
             * Create the "id" attribute.
             * @type {String}
             * @private
             */
            messageID = 'ch-countdown-message-' + that.uid,

           /**
             * Singular or Plural message depending on amount of remaining characters.
             * @type {String}
             * @private
             */
            message;

        /**
         * The countdown trigger.
         * @type {HTMLTextAreaElement}
         * @example
         * // Gets the countdown trigger.
         * countdown.trigger;
         */
        this.trigger = this._el;
        'keyup keypress keydown input paste cut'.split(' ')
            .forEach(function(name) {
                tiny.on(that.trigger, name, function () { that._count(); });
            });

        /**
         * Amount of free characters until full the field.
         * @type {Number}
         * @private
         */
        that._remaining = that._options.max - that._contentLength();

        // Update the message
        message = ((that._remaining === 1) ? that._options.singular : that._options.plural);

        /**
         * The countdown container.
         * @type {HTMLParagraphElement}
         */
        that.container = (function () {
            var parent = tiny.parent(that._el);
            parent.insertAdjacentHTML('beforeend', '<span class="ch-countdown ch-form-hint" id="' + messageID + '">' + message.replace('#', that._remaining) + '</span>');

            return parent.querySelector('#' + messageID);
        }());

        this.on('disable', this._removeError);

        return this;
    };

    /**
     * Returns the length of value.
     * @function
     * @private
     * @returns {Number}
     */
    Countdown.prototype._contentLength = function () {
        return this._el.value.length;
    };

    /**
     * Process input of data on form control and updates remaining amount of characters or limits the content length. Also, change the visible message of remaining characters.
     * @function
     * @private
     * @returns {countdown}
     */
    Countdown.prototype._count = function () {

        if (!this._enabled) {
            return this;
        }

        var length = this._contentLength(),
            message;

        this._remaining = this._options.max - length;

        // Limit Count alert the user
        if (length <= this._options.max) {

            if (this._exceeded) {
                // Update exceeded flag
                this._exceeded = false;
                this._removeError();
            }

        } else if (length > this._options.max) {

            /**
             * Event emitted when the lenght of characters is exceeded.
             * @event ch.Countdown#exceed
             * @example
             * // Subscribe to "exceed" event.
             * countdown.on('exceed', function () {
             *     // Some code here!
             * });
             */
            this.emit('exceed');

            // Update exceeded flag
            this._exceeded = true;

            this.trigger.setAttribute('aria-invalid', 'true');
            tiny.addClass(this.trigger, 'ch-validation-error');

            tiny.addClass(this.container, 'ch-countdown-exceeded');
        }

        // Change visible message of remaining characters
        // Singular or Plural message depending on amount of remaining characters
        message = (this._remaining !== 1 ? this._options.plural : this._options.singular).replace(/\#/g, this._remaining);

        // Update DOM text
        this.container.innerText  = message;

        return this;

    };

     /**
     * Process input of data on form control and updates remaining amount of characters or limits the content length. Also, change the visible message of remaining characters.
     * @function
     * @private
     * @returns {countdown}
     */
    Countdown.prototype._removeError = function () {
        tiny.removeClass(this.trigger, 'ch-validation-error');
        this.trigger.setAttribute('aria-invalid', 'false');

        tiny.removeClass(this.container, 'ch-countdown-exceeded');

        return this;
    };

    /**
     * Destroys a Countdown instance.
     * @memberof! ch.Countdown.prototype
     * @function
     * @example
     * // Destroy a countdown
     * countdown.destroy();
     * // Empty the countdown reference
     * countdown = undefined;
     */
    Countdown.prototype.destroy = function () {
        var parentElement = tiny.parent(this.container);
        parentElement.removeChild(this.container);

        tiny.trigger(window.document, ch.onlayoutchange);

        parent.destroy.call(this);

        return;
    };

    // Factorize
    ch.factory(Countdown, normalizeOptions);

}(this, this.ch));

(function (window, ch) {
    'use strict';

    /**
     * Datepicker lets you select dates.
     * @memberof ch
     * @constructor
     * @augments ch.Component
     * @requires ch.Calendar
     * @param {HTMLElement} [el] A HTMLElement to create an instance of ch.Datepicker.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.format] Sets the date format. Default: "DD/MM/YYYY".
     * @param {String} [options.selected] Sets a date that should be selected by default. Default: "today".
     * @param {String} [options.from] Set a minimum selectable date. The format of the given date should be "YYYY/MM/DD".
     * @param {String} [options.to] Set a maximum selectable date. The format of the given date should be "YYYY/MM/DD".
     * @param {Array} [options.monthsNames] A collection of months names. Default: ["Enero", ... , "Diciembre"].
     * @param {Array} [options.weekdays] A collection of weekdays. Default: ["Dom", ... , "Sab"].
     * @param {Boolean} [options.hiddenby] Determines how to hide the component. You must use: "button", "pointers", "pointerleave", "all" or "none". Default: "pointers".
     * @param {HTMLElement} [options.context] It's a reference to position and size of element that will be considered to carry out the position.
     * @param {String} [options.side] The side option where the target element will be positioned. You must use: "left", "right", "top", "bottom" or "center". Default: "bottom".
     * @param {String} [options.align] The align options where the target element will be positioned. You must use: "left", "right", "top", "bottom" or "center". Default: "center".
     * @param {Number} [options.offsetX] Distance to displace the target horizontally.
     * @param {Number} [options.offsetY] Distance to displace the target vertically.
     * @param {String} [options.position] The type of positioning used. You must use: "absolute" or "fixed". Default: "absolute".
     * @returns {datepicker} Returns a new instance of Datepicker.
     * @example
     * // Create a new Datepicker.
     * var datepicker = new ch.Datepicker([selector], [options]);
     * @example
     * // Create a new Datepicker with custom options.
     * var datepicker = new ch.Datepicker({
     *     "format": "MM/DD/YYYY",
     *     "selected": "2011/12/25",
     *     "from": "2010/12/25",
     *     "to": "2012/12/25",
     *     "monthsNames": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
     *     "weekdays": ["Su", "Mo", "Tu", "We", "Thu", "Fr", "Sa"]
     * });
     */
    function Datepicker(selector, options) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(selector, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Datepicker is created.
             * @memberof! ch.Datepicker.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Datepicker#ready
         * @example
         * // Subscribe to "ready" event.
         * datepicker.on('ready', function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);
    }

    // Inheritance
    tiny.inherits(Datepicker, ch.Component);

    var parent = Datepicker.super_.prototype,
        // Creates methods enable and disable into the prototype.
        methods = ['enable', 'disable'],
        len = methods.length;

    function createMethods(method) {
        Datepicker.prototype[method] = function () {

            this._popover[method]();

            parent[method].call(this);

            return this;
        };
    }

    /**
     * The name of the component.
     * @memberof! ch.Datepicker.prototype
     * @type {String}
     * @example
     * // You can reach the associated instance.
     * var datepicker = $(selector).data('datepicker');
     */
    Datepicker.prototype.name = 'datepicker';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Datepicker.prototype
     * @function
     */
    Datepicker.prototype.constructor = Datepicker;

    /**
     * Configuration by default.
     * @type {Object}
     * @private
     */
    Datepicker.prototype._defaults = {
        'format': 'DD/MM/YYYY',
        'side': 'bottom',
        'align': 'center',
        'hiddenby': 'pointers'
    };

    /**
     * Initialize a new instance of Datepicker and merge custom options with defaults options.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @private
     * @returns {datepicker}
     */
    Datepicker.prototype._init = function (selector, options) {
        // Call to its parent init method
        parent._init.call(this, selector, options);

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        /**
         * The datepicker input field.
         * @type {HTMLElement}
         */
        this.field = this._el;
        this.field.insertAdjacentHTML('afterend', '<i role="button" class="ch-datepicker-trigger ch-icon-calendar"></i>');

        /**
         * The datepicker trigger.
         * @type {HTMLElement}
         */
        this.trigger = tiny.next(this.field);

        /**
         * Reference to the Calendar component instanced.
         * @type {ch.Calendar}
         * @private
         */
        this._calendar = new ch.Calendar(document.createElement('div'), options);

        /**
         * Reference to the Popover component instanced.
         * @type {ch.Popover}
         * @private
         */
        this._popover = new ch.Popover(this.trigger, {
            '_className': 'ch-datepicker ch-cone',
            '_ariaRole': 'tooltip',
            'content': this._calendar.container,
            'side': this._options.side,
            'align': this._options.align,
            'offsetX': 1,
            'offsetY': 10,
            'shownby': 'pointertap',
            'hiddenby': this._options.hiddenby
        });

        tiny.on(this._popover._content, ch.onpointertap, function (event) {
            var el = event.target;

            // Day selection
            if (el.nodeName === 'TD' && el.className.indexOf('ch-calendar-disabled') === -1 && el.className.indexOf('ch-calendar-other') === -1) {
                that.pick(el.innerHTML);
            }

        });

        this.field.setAttribute('aria-describedby', 'ch-popover-' + this._popover.uid);

        // Change type of input to "text"
        this.field.type = 'text';

        // Change value of input if there are a selected date
        this.field.value = (this._options.selected) ? this._calendar.select() : this.field.value;

        // Hide popover
        this.on('disable', this.hide);

        return this;
    };

    /**
     * Shows the datepicker.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @returns {datepicker}
     * @example
     * // Shows a datepicker.
     * datepicker.show();
     */
    Datepicker.prototype.show = function () {

        if (!this._enabled) {
            return this;
        }

        this._popover.show();

        /**
         * Event emitted when a datepicker is shown.
         * @event ch.Datepicker#show
         * @example
         * // Subscribe to "show" event.
         * datepicker.on('show', function () {
         *     // Some code here!
         * });
         */
        this.emit('show');

        return this;
    };

    /**
     * Hides the datepicker.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @returns {datepicker}
     * @example
     * // Shows a datepicker.
     * datepicker.hide();
     */
    Datepicker.prototype.hide = function () {
        this._popover.hide();

        /**
         * Event emitted when a datepicker is hidden.
         * @event ch.Datepicker#hide
         * @example
         * // Subscribe to "hide" event.
         * datepicker.on('hide', function () {
         *     // Some code here!
         * });
         */
        this.emit('hide');

        return this;
    };

    /**
     * Selects a specific day into current month and year.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @private
     * @param {(String | Number)} day A given day to select.
     * @returns {datepicker}
     * @example
     * // Select a specific day.
     * datepicker.pick(28);
     */
    Datepicker.prototype.pick = function (day) {

        // Select the day and update input value with selected date
        this.field.value = [this._calendar._dates.current.year, this._calendar._dates.current.month, day].join('/');

        // Hide float
        this._popover.hide();

        // Select a date
        this.select(this.field.value);

        return this;
    };

    /**
     * Selects a specific date or returns the selected date.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @param {String} [date] A given date to select. The format of the given date should be "YYYY/MM/DD".
     * @returns {(datepicker | String)}
     * @example
     * // Returns the selected date.
     * datepicker.select();
     * @example
     * // Select a specific date.
     * datepicker.select('2014/05/28');
     */
    Datepicker.prototype.select = function (date) {

       // Setter
       // Select the day and update input value with selected date
        if (date) {
            this._calendar.select(date);
            this.field.value = this._calendar.select();

            /**
             * Event emitted when a date is selected.
             * @event ch.Datepicker#select
             * @example
             * // Subscribe to "select" event.
             * datepicker.on('select', function () {
             *     // Some code here!
             * });
             */
            this.emit('select');

            return this;
        }

        // Getter
        return this._calendar.select();
    };

    /**
     * Returns date of today
     * @memberof! ch.Datepicker.prototype
     * @function
     * @returns {String} The date of today
     * @example
     * // Get the date of today.
     * var today = datepicker.getToday();
     */
    Datepicker.prototype.getToday = function () {
        return this._calendar.getToday();
    };

    /**
     * Moves to the next month.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @returns {datepicker}
     * @example
     * // Moves to the next month.
     * datepicker.nextMonth();
     */
    Datepicker.prototype.nextMonth = function () {
        this._calendar.nextMonth();

        /**
         * Event emitted when a next month is shown.
         * @event ch.Datepicker#nextmonth
         * @example
         * // Subscribe to "nextmonth" event.
         * datepicker.on('nextmonth', function () {
         *     // Some code here!
         * });
         */
        this.emit('nextmonth');

        return this;
    };

    /**
     * Move to the previous month.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @returns {datepicker}
     * @example
     * // Moves to the prev month.
     * datepicker.prevMonth();
     */
    Datepicker.prototype.prevMonth = function () {

        this._calendar.prevMonth();

        /**
         * Event emitted when a previous month is shown.
         * @event ch.Datepicker#prevmonth
         * @example
         * // Subscribe to "prevmonth" event.
         * datepicker.on('prevmonth', function () {
         *     // Some code here!
         * });
         */
        this.emit('prevmonth');

        return this;
    };

    /**
     * Move to the next year.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @returns {datepicker}
     * @example
     * // Moves to the next year.
     * datepicker.nextYear();
     */
    Datepicker.prototype.nextYear = function () {

        this._calendar.nextYear();

        /**
         * Event emitted when a next year is shown.
         * @event ch.Datepicker#nextyear
         * @example
         * // Subscribe to "nextyear" event.
         * datepicker.on('nextyear', function () {
         *     // Some code here!
         * });
         */
        this.emit('nextyear');

        return this;
    };

    /**
     * Move to the previous year.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @returns {datepicker}
     * @example
     * // Moves to the prev year.
     * datepicker.prevYear();
     */
    Datepicker.prototype.prevYear = function () {

        this._calendar.prevYear();

        /**
         * Event emitted when a previous year is shown.
         * @event ch.Datepicker#prevyear
         * @example
         * // Subscribe to "prevyear" event.
         * datepicker.on('prevyear', function () {
         *     // Some code here!
         * });
         */
        this.emit('prevyear');

        return this;
    };

    /**
     * Reset the Datepicker to date of today
     * @memberof! ch.Datepicker.prototype
     * @function
     * @returns {datepicker}
     * @example
     * // Resset the datepicker
     * datepicker.reset();
     */
    Datepicker.prototype.reset = function () {

        // Delete input value
        this.field.value = '';
        this._calendar.reset();

        /**
         * Event emitter when the datepicker is reseted.
         * @event ch.Datepicker#reset
         * @example
         * // Subscribe to "reset" event.
         * datepicker.on('reset', function () {
         *     // Some code here!
         * });
         */
        this.emit('reset');

        return this;
    };

    /**
     * Set a minimum selectable date.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @param {String} date A given date to set as minimum selectable date. The format of the given date should be "YYYY/MM/DD".
     * @returns {datepicker}
     * @example
     * // Set a minimum selectable date.
     * datepicker.setFrom('2010/05/28');
     */
    Datepicker.prototype.setFrom = function (date) {
        this._calendar.setFrom(date);

        return this;
    };

    /**
     * Set a maximum selectable date.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @param {String} date A given date to set as maximum selectable date. The format of the given date should be "YYYY/MM/DD".
     * @returns {datepicker}
     * @example
     * // Set a maximum selectable date.
     * datepicker.setTo('2014/05/28');
     */
    Datepicker.prototype.setTo = function (date) {
        this._calendar.setTo(date);

        return this;
    };

    /**
     * Enables an instance of Datepicker.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @returns {datepicker} Returns an instance of Datepicker.
     * @example
     * // Enabling an instance of Datepicker.
     * datepicker.enable();
     */

    /**
     * Disables an instance of Datepicker.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @returns {datepicker} Returns an instance of Datepicker.
     * @example
     * // Disabling an instance of Datepicker.
     * datepicker.disable();
     */
    while (len) {
        createMethods(methods[len -= 1]);
    }

    /**
     * Destroys a Datepicker instance.
     * @memberof! ch.Datepicker.prototype
     * @function
     * @example
     * // Destroying an instance of Datepicker.
     * datepicker.destroy();
     */
    Datepicker.prototype.destroy = function () {

        tiny.parent(this.trigger).removeChild(this.trigger);

        this._el.removeAttribute('aria-describedby');
        this._el.type = 'date';

        this._popover.destroy();

        parent.destroy.call(this);
    };

    // Factorize
    ch.factory(Datepicker);

}(this, this.ch));

(function (window, ch) {
    'use strict';


    function highlightSuggestion(target) {
        var posinset;

        Array.prototype.forEach.call(this._suggestionsList.childNodes, function(e) {
            if(e.contains(target)){
                posinset = parseInt(target.getAttribute('aria-posinset'), 10) - 1;
            }
        });

        this._highlighted = (typeof posinset === 'number') ? posinset : null;

        this._toogleHighlighted();

        return this;
    }

    var specialKeyCodeMap = {
        9: 'tab',
        27: 'esc',
        37: 'left',
        39: 'right',
        13: 'enter',
        38: 'up',
        40: 'down'
    };

    /**
     * Autocomplete Component shows a list of suggestions for a HTMLInputElement.
     * @memberof ch
     * @constructor
     * @augments ch.Component
     * @requires ch.Popover
     * @param {HTMLElement} [el] A HTMLElement to create an instance of ch.Autocomplete.
     * @param {Object} [options] Options to customize an instance.
     * @param {String} [options.loadingClass] Default: "ch-autocomplete-loading".
     * @param {String} [options.highlightedClass] Default: "ch-autocomplete-highlighted".
     * @param {String} [options.itemClass] Default: "ch-autocomplete-item".
     * @param {String} [options.addClass] CSS class names that will be added to the container on the component initialization. Default: "ch-box-lite ch-autocomplete".
     * @param {Number} [options.keystrokesTime] Default: 150.
     * @param {Boolean} [options.html] Default: false.
     * @param {String} [options.side] The side option where the target element will be positioned. You must use: "left", "right", "top", "bottom" or "center". Default: "bottom".
     * @param {String} [options.align] The align options where the target element will be positioned. You must use: "left", "right", "top", "bottom" or "center". Default: "left".
     * @param {Number} [options.offsetX] The offsetX option specifies a distance to displace the target horitontally.
     * @param {Number} [options.offsetY] The offsetY option specifies a distance to displace the target vertically.
     * @param {String} [options.positioned] The positioned option specifies the type of positioning used. You must use: "absolute" or "fixed". Default: "absolute".
     * @param {(Boolean | String)} [options.wrapper] Wrap the reference element and place the container into it instead of body. When value is a string it will be applied as additional wrapper class. Default: false.
     * @param {Number} [options.minChars] Number of characters required to begin to suggest. Default: 1.
     *
     * @returns {autocomplete}
     * @example
     * // Create a new AutoComplete.
     * var autocomplete = new AutoComplete([el], [options]);
     * @example
     * // Create a new AutoComplete with configuration.
     * var autocomplete = new AutoComplete('.my-autocomplete', {
     *  'loadingClass': 'custom-loading',
     *  'highlightedClass': 'custom-highlighted',
     *  'itemClass': 'custom-item',
     *  'addClass': 'carousel-cities',
     *  'keystrokesTime': 600,
     *  'html': true,
     *  'side': 'center',
     *  'align': 'center',
     *  'offsetX': 0,
     *  'offsetY': 0,
     *  'positioned': 'fixed'
     * });
     */
    function Autocomplete(el, options) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        this._init(el, options);

        if (this.initialize !== undefined) {
            /**
             * If you define an initialize method, it will be executed when a new Autocomplete is created.
             * @memberof! ch.Autocomplete.prototype
             * @function
             */
            this.initialize();
        }

        /**
         * Event emitted when the component is ready to use.
         * @event ch.Autocomplete#ready
         * @example
         * // Subscribe to "ready" event.
         * autocomplete.on('ready',function () {
         *     // Some code here!
         * });
         */
        window.setTimeout(function () { that.emit('ready'); }, 50);

        return this;
    }

    // Inheritance
    tiny.inherits(Autocomplete, ch.Component);

    var parent = Autocomplete.super_.prototype,
        // there is no mouseenter to highlight the item, so it happens when the user do mousedown
        highlightEvent = (tiny.support.touch) ? ch.onpointerdown : 'mouseover';

    /**
     * The name of the component.
     * @type {String}
     */
    Autocomplete.prototype.name = 'autocomplete';

    /**
     * Returns a reference to the constructor function.
     * @memberof! ch.Autocomplete.prototype
     * @function
     */
    Autocomplete.prototype.constructor = Autocomplete;

    /**
     * Configuration by default.
     * @type {Object}
     * @private
     */
    Autocomplete.prototype._defaults = {
        'loadingClass': 'ch-autocomplete-loading',
        'highlightedClass': 'ch-autocomplete-highlighted',
        'itemClass': 'ch-autocomplete-item',
        'addClass': 'ch-box-lite ch-autocomplete',
        'side': 'bottom',
        'align': 'left',
        'html': false,
        '_hiddenby': 'none',
        'keystrokesTime': 150,
        '_itemTemplate': '<li class="{{itemClass}}"{{suggestedData}}>{{term}}<i class="ch-icon-arrow-up" data-js="ch-autocomplete-complete-query"></i></li>',
        'wrapper': false,
        'minChars': 1
    };

    /**
     * Initialize a new instance of Autocomplete and merge custom options with defaults options.
     * @memberof! ch.Autocomplete.prototype
     * @function
     * @private
     * @returns {autocomplete}
     */
    Autocomplete.prototype._init = function (el, options) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        // Call to its parent init method
        parent._init.call(this, el, options);

        // creates the basic item template for this instance
        this._options._itemTemplate = this._options._itemTemplate.replace('{{itemClass}}', this._options.itemClass);

        if (this._options.html) {
            // remove the suggested data space when html is configured
            this._options._itemTemplate = this._options._itemTemplate.replace('{{suggestedData}}', '');
        }

        // The component who shows and manage the suggestions.
        this._popover = new ch.Popover({
            'reference': this._el,
            'content': this._suggestionsList,
            'side': this._options.side,
            'align': this._options.align,
            'addClass': this._options.addClass,
            'hiddenby': this._options._hiddenby,
            'width': this._el.getBoundingClientRect().width + 'px',
            'fx': this._options.fx,
            'wrapper': this._options.wrapper
        });

        /**
         * The autocomplete container.
         * @type {HTMLDivElement}
         * @example
         * // Gets the autocomplete container to append or prepend content.
         * autocomplete.container.appendChild(document.createElement('div'));
         */
        this.container = this._popover.container;

        this.container.setAttribute('aria-hidden', 'true');

        /**
         * The autocomplete suggestion list.
         * @type {HTMLUListElement}
         * @private
         */
        this._suggestionsList = document.createElement('ul');
        tiny.addClass(this._suggestionsList, 'ch-autocomplete-list');

        this.container.appendChild(this._suggestionsList);

        /**
         * Selects the items
         * @memberof! ch.Autocomplete.prototype
         * @function
         * @private
         * @returns {autocomplete}
         */

        this._highlightSuggestion = function (event) {
            var target = event.target || event.srcElement,
                item = (target.nodeName === 'LI') ? target : (target.parentNode.nodeName === 'LI') ? target.parentNode : null;

            if (item !== null) {
                highlightSuggestion.call(that, item);
            }

        };

        tiny.on(this.container, highlightEvent, this._highlightSuggestion);


        tiny.on(this.container, ch.onpointertap, function itemEvents(event) {
            var target = event.target || event.srcElement;

            // completes the value, it is a shortcut to avoid write the complete word
            if (target.nodeName === 'I' && !that._options.html) {
                event.preventDefault();
                that._el.value = that._suggestions[that._highlighted];
                that.emit('type', that._el.value);
                return;
            }

            if ((target.nodeName === 'LI' && target.className.indexOf(that._options.itemClass) !== -1) || (target.parentElement.nodeName === 'LI' && target.parentElement.className.indexOf(that._options.itemClass) !== -1)) {
                that._selectSuggestion();
            }
        });

        /**
         * The autocomplete trigger.
         * @type {HTMLElement}
         */
        this.trigger = this._el;

        this.trigger.setAttribute('aria-autocomplete', 'list');
        this.trigger.setAttribute('aria-haspopup', 'true');
        this.trigger.setAttribute('aria-owns', this.container.getAttribute('id'));
        this.trigger.setAttribute('autocomplete', 'off');

        tiny.on(this.trigger, 'focus', function turnon() { that._turn('on'); });
        tiny.on(this.trigger, 'blur', function turnoff() {that._turn('off'); });

        // Turn on when the input element is already has focus
        if (this._el === document.activeElement && !this._enabled) {
            this._turn('on');
        }

        // The number of the selected item or null when no selected item is.
        this._highlighted = null;

        // Collection of suggestions to be shown.
        this._suggestions = [];

        // Used to show when the user cancel the suggestions
        this._originalQuery = this._currentQuery = this._el.value;

        if (this._configureShortcuts !== undefined) {
            this._configureShortcuts();
        }

        return this;
    };

    /**
     * Turns on the ability off listen the keystrokes
     * @memberof! ch.Autocomplete.prototype
     * @function
     * @private
     * @returns {autocomplete}
     */
    Autocomplete.prototype._turn = function (turn) {
        var that = this;

        if (!this._enabled) {
            return this;
        }


        function turnOn() {
            that._currentQuery = that._el.value.trim();
            // when the user writes
            window.clearTimeout(that._stopTyping);
            if (that._currentQuery.length >= that._options.minChars) {
                that._stopTyping = window.setTimeout(function() {

                    tiny.addClass(that.trigger, that._options.loadingClass);
                    /**
                     * Event emitted when the user is typing.
                     * @event ch.Autocomplete#type
                     * @example
                     * // Subscribe to "type" event with ajax call
                     * autocomplete.on('type', function (userInput) {
                     *      $.ajax({
                     *          'url': '/countries?q=' + userInput,
                     *          'dataType': 'json',
                     *          'success': function (response) {
                     *              autocomplete.suggest(response);
                     *          }
                     *      });
                     * });
                     * @example
                     * // Subscribe to "type" event with jsonp
                     * autocomplete.on('type', function (userInput) {
                     *       $.ajax({
                     *           'url': '/countries?q='+ userInput +'&callback=parseResults',
                     *           'dataType': 'jsonp',
                     *           'cache': false,
                     *           'global': true,
                     *           'context': window,
                     *           'jsonp': 'parseResults',
                     *           'crossDomain': true
                     *       });
                     * });
                     */
                    that.emit('type', that._currentQuery);
                }, that._options.keystrokesTime);
            } else {
                that.suggest([]);
            }
        }

        function turnOnFallback(e) {
            if (specialKeyCodeMap[e.which || e.keyCode]) {
                return;
            }
            // When keydown is fired that.trigger still has an old value
            setTimeout(turnOn, 1);
        }

        this._originalQuery = this._el.value;

        // IE8 don't support the input event at all
        // IE9 is the only browser that doesn't fire the input event when characters are removed
        var ua = navigator.userAgent;
        var MSIE = (/(msie|trident)/i).test(ua) ?
            ua.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;

        if (turn === 'on') {
            if (!MSIE || MSIE > 9) {
                tiny.on(this.trigger, ch.onkeyinput, turnOn);
            } else {
                'keydown cut paste'.split(' ').forEach(function(evtName) {
                    tiny.on(that.trigger, evtName, turnOnFallback);
                });
            }
        } else if (turn === 'off') {
            this.hide();
            if (!MSIE || MSIE > 9) {
                tiny.off(this.trigger, ch.onkeyinput, turnOn);
            } else {
                'keydown cut paste'.split(' ').forEach(function(evtName) {
                    tiny.off(that.trigger, evtName, turnOnFallback);
                });
            }
        }

        return this;

    };

    /**
     * It sets to the HTMLInputElement the selected query and it emits a 'select' event.
     * @memberof! ch.Autocomplete.prototype
     * @function
     * @private
     * @returns {autocomplete}
     */
    Autocomplete.prototype._selectSuggestion = function () {

        window.clearTimeout(this._stopTyping);

        if (this._highlighted === null) {
            return this;
        }

        if (!this._options.html) {
            this._el.value = this._suggestions[this._highlighted];
        }

        this._el.blur();

        /**
         * Event emitted when a suggestion is selected.
         * @event ch.Autocomplete#select
         * @example
         * // Subscribe to "select" event.
         * autocomplete.on('select', function () {
         *     // Some code here!
         * });
         */
        this.emit('select');

        return this;
    };

    /**
     * It highlights the item adding the "ch-autocomplete-highlighted" class name or the class name that you configured as "highlightedClass" option.
     * @memberof! ch.Autocomplete.prototype
     * @function
     * @private
     * @returns {autocomplete}
     */
    Autocomplete.prototype._toogleHighlighted = function () {
        // null is when is not a selected item but,
        // increments 1 _highlighted because aria-posinset starts in 1 instead 0 as the collection that stores the data
        var current = (this._highlighted === null) ? null : (this._highlighted + 1),
            currentItem = this.container.querySelector('[aria-posinset="' + current + '"]'),
            selectedItem = this.container.querySelector('[aria-posinset].' + this._options.highlightedClass);

        if (selectedItem !== null) {
            // background the highlighted item
            tiny.removeClass(selectedItem, this._options.highlightedClass);
        }

        if (currentItem !== null) {
            // highlight the selected item
            tiny.addClass(currentItem, this._options.highlightedClass);
        }

        return this;
    };

    /**
     * Add suggestions to be shown.
     * @memberof! ch.Autocomplete.prototype
     * @function
     * @returns {autocomplete}
     * @example
     * // The suggest method needs an Array of strings to work with default configuration
     * autocomplete.suggest(['Aruba','Armenia','Argentina']);
     * @example
     * // To work with html configuration, it needs an Array of strings. Each string must to be as you wish you watch it
     * autocomplete.suggest([
     *  '<strong>Ar</strong>uba <i class="flag-aruba"></i>',
     *  '<strong>Ar</strong>menia <i class="flag-armenia"></i>',
     *  '<strong>Ar</strong>gentina <i class="flag-argentina"></i>'
     * ]);
     */
    Autocomplete.prototype.suggest = function (suggestions) {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this,
            items = [],
            matchedRegExp = new RegExp('(' + this._currentQuery.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1') + ')', 'ig'),
            totalItems,
            itemDOMCollection,
            itemTemplate = this._options._itemTemplate,
            suggestedItem,
            term,
            suggestionsLength = suggestions.length,
            el,
            itemSelected = this.container.querySelector('.' + this._options.highlightedClass);

        // hide the loading feedback
        tiny.removeClass(this.trigger, that._options.loadingClass);

        // hides the suggestions list
        if (suggestionsLength === 0) {
            this._popover.hide();

            return this;
        }

        // shows the suggestions list when the is closed and the element is withs focus
        if (!this._popover.isShown() && window.document.activeElement === this._el) {
            this._popover.show();
        }

        // remove the class from the extra added items
        if (itemSelected !== null) {
            tiny.removeClass(itemSelected, this._options.highlightedClass);
        }

        // add each suggested item to the suggestion list
        for (suggestedItem = 0; suggestedItem < suggestionsLength; suggestedItem += 1) {
            // get the term to be replaced
            term = suggestions[suggestedItem];

            // for the html configured component doesn't highlight the term matched it must be done by the user
            if (!that._options.html) {
                term = term.replace(matchedRegExp, '<strong>$1</strong>');
                itemTemplate = this._options._itemTemplate.replace('{{suggestedData}}', ' data-suggested="' + suggestions[suggestedItem] + '"');
            }

            items.push(itemTemplate.replace('{{term}}', term));
        }

        this._suggestionsList.innerHTML = items.join('');

        itemDOMCollection = this.container.querySelectorAll('.' + this._options.itemClass);

        // with this we set the aria-setsize value that counts the total
        totalItems = itemDOMCollection.length;

        // Reset suggestions collection.
        this._suggestions.length = 0;

        for (suggestedItem = 0; suggestedItem < totalItems; suggestedItem += 1) {
            el = itemDOMCollection[suggestedItem];

            // add the data to the suggestions collection
            that._suggestions.push(el.getAttribute('data-suggested'));

            el.setAttribute('aria-posinset', that._suggestions.length);
            el.setAttribute('aria-setsize', totalItems);
        }

        this._highlighted = null;

        this._suggestionsQuantity = this._suggestions.length;

        return this;
    };

    /**
     * Hides component's container.
     * @memberof! ch.Autocomplete.prototype
     * @function
     * @returns {autocomplete}
     * @example
     * // Hides the autocomplete.
     * autocomplete.hide();
     */
    Autocomplete.prototype.hide = function () {

        if (!this._enabled) {
            return this;
        }

        this._popover.hide();

        /**
         * Event emitted when the Autocomplete container is hidden.
         * @event ch.Autocomplete#hide
         * @example
         * // Subscribe to "hide" event.
         * autocomplete.on('hide', function () {
         *  // Some code here!
         * });
         */
        this.emit('hide');

        return this;
    };

    /**
     * Returns a Boolean if the component's core behavior is shown. That means it will return 'true' if the component is on and it will return false otherwise.
     * @memberof! ch.Autocomplete.prototype
     * @function
     * @returns {Boolean}
     * @example
     * // Execute a function if the component is shown.
     * if (autocomplete.isShown()) {
     *     fn();
     * }
     */
    Autocomplete.prototype.isShown = function () {
        return this._popover.isShown();
    };

    Autocomplete.prototype.disable = function () {
        if (this.isShown()) {
            this.hide();
            this._el.blur();
        }

        parent.disable.call(this);

        return this;
    };

    /**
     * Destroys an Autocomplete instance.
     * @memberof! ch.Autocomplete.prototype
     * @function
     * @example
     * // Destroying an instance of Autocomplete.
     * autocomplete.destroy();
     */
    Autocomplete.prototype.destroy = function () {

        tiny.off(this.container, highlightEvent, this._highlightSuggestion);

        this.trigger.removeAttribute('autocomplete');
        this.trigger.removeAttribute('aria-autocomplete');
        this.trigger.removeAttribute('aria-haspopup');
        this.trigger.removeAttribute('aria-owns');

        this._popover.destroy();

        parent.destroy.call(this);

        return;
    };

    ch.factory(Autocomplete);

}(this, this.ch));

(function (Autocomplete, ch) {
    'use strict';
    /**
     * Congfigure shortcuts to navigate and set values, or cancel the typed text
     * @memberof! ch.Autocomplete.prototype
     * @function
     * @private
     * @returns {autocomplete}
     */
    Autocomplete.prototype._configureShortcuts = function () {

        /**
         * Reference to context of an instance.
         * @type {Object}
         * @private
         */
        var that = this;

        // Shortcuts
        ch.shortcuts.add(ch.onkeyenter, this.uid, function (event) {
            event.preventDefault();
            that._selectSuggestion();
        });

        ch.shortcuts.add(ch.onkeyesc, this.uid, function () {
            that.hide();
            that._el.value = that._originalQuery;
        });

        ch.shortcuts.add(ch.onkeyuparrow, this.uid, function (event) {
            event.preventDefault();

            var value;

            // change the selected value & stores the future HTMLInputElement value
            if (that._highlighted === null) {

                that._highlighted = that._suggestionsQuantity - 1;
                value = that._suggestions[that._highlighted];

            } else if (that._highlighted <= 0) {

                this._prevHighlighted = this._currentHighlighted = null;
                value = that._currentQuery;

            } else {

                that._highlighted -= 1;
                value = that._suggestions[that._highlighted];

            }

            that._toogleHighlighted();

            if (!that._options.html) {
                that._el.value = value;
            }

        });

        ch.shortcuts.add(ch.onkeydownarrow, this.uid, function () {
            var value;

            // change the selected value & stores the future HTMLInputElement value
            if (that._highlighted === null) {

                that._highlighted = 0;

                value = that._suggestions[that._highlighted];

            } else if (that._highlighted >= that._suggestionsQuantity - 1) {

                that._highlighted = null;
                value = that._currentQuery;

            } else {

                that._highlighted += 1;
                value = that._suggestions[that._highlighted];

            }

            that._toogleHighlighted();

            if (!that._options.html) {
                that._el.value = value;
            }

        });

        // Activate the shortcuts for this instance
        this._popover.on('beforeshow', function () { ch.shortcuts.on(that.uid); });

        // Deactivate the shortcuts for this instance
        this._popover.on('beforehide', function () { ch.shortcuts.off(that.uid); });

        this.on('destroy', function () {
            ch.shortcuts.remove(this.uid);
        });

        return this;
    };

}(this.ch.Autocomplete, this.ch));

/*! jQuery v3.1.1 | (c) jQuery Foundation | jquery.org/license */
!function(a,b){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){"use strict";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement("script");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q="3.1.1",r=function(a,b){return new r.fn.init(a,b)},s=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=r.isArray(d)))?(e?(e=!1,f=c&&r.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:"jQuery"+(q+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===r.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return("number"===b||"string"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||"[object Object]"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,"constructor")&&b.constructor,"function"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?j[k.call(a)]||"object":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,"ms-").replace(u,v)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(s,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,"string"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if("string"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),"function"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){j["[object "+b+"]"]=b.toLowerCase()});function w(a){var b=!!a&&"length"in a&&a.length,c=r.type(a);return"function"!==c&&!r.isWindow(a)&&("array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",M="\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+L+"))|)"+K+"*\\]",N=":("+L+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+M+")*)|.*)\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ca=function(a,b){return b?"\0"===a?"\ufffd":a.slice(0,-1)+"\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&("form"in a||"label"in a)},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"form"in b?b.parentNode&&b.disabled===!1?"label"in b?"label"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:"label"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&"HTML"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode("id"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode("id"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if("undefined"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!='']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:!b||(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b&&(e===c||e.slice(0,c.length+1)===c+"-"))}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m="function"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){if(!c)return a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){if(!c&&"input"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[":"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext,B=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,C=/^.[^:#\[\.,]*$/;function D(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):"string"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):C.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if("string"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(D(this,a||[],!1))},not:function(a){return this.pushStack(D(this,a||[],!0))},is:function(a){return!!D(this,"string"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var E,F=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,G=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||E,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:F.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),B.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};G.prototype=r.fn,E=r(d);var H=/^(?:parents|prev(?:Until|All))/,I={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g="string"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function J(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,"parentNode")},parentsUntil:function(a,b,c){return y(a,"parentNode",c)},next:function(a){return J(a,"nextSibling")},prev:function(a){return J(a,"previousSibling")},nextAll:function(a){return y(a,"nextSibling")},prevAll:function(a){return y(a,"previousSibling")},nextUntil:function(a,b,c){return y(a,"nextSibling",c)},prevUntil:function(a,b,c){return y(a,"previousSibling",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return a.contentDocument||r.merge([],a.childNodes)}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=r.filter(d,e)),this.length>1&&(I[a]||r.uniqueSort(e),H.test(a)&&e.reverse()),this.pushStack(e)}});var K=/[^\x20\t\r\n\f]+/g;function L(a){var b={};return r.each(a.match(K)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a="string"==typeof a?L(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function M(a){return a}function N(a){throw a}function O(a,b,c){var d;try{a&&r.isFunction(d=a.promise)?d.call(a).done(b).fail(c):a&&r.isFunction(d=a.then)?d.call(a,b,c):b.call(void 0,a)}catch(a){c.call(void 0,a)}}r.extend({Deferred:function(b){var c=[["notify","progress",r.Callbacks("memory"),r.Callbacks("memory"),2],["resolve","done",r.Callbacks("once memory"),r.Callbacks("once memory"),0,"resolved"],["reject","fail",r.Callbacks("once memory"),r.Callbacks("once memory"),1,"rejected"]],d="pending",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},"catch":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+"With"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError("Thenable self-resolution");j=a&&("object"==typeof a||"function"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,M,e),g(f,c,N,e)):(f++,j.call(a,g(f,c,M,e),g(f,c,N,e),g(f,c,M,c.notifyWith))):(d!==M&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==N&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:M,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:M)),c[2][3].add(g(0,a,r.isFunction(d)?d:N))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+"With"](this===f?void 0:this,arguments),this},f[b[0]+"With"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(O(a,g.done(h(c)).resolve,g.reject),"pending"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)O(e[c],h(c),g.reject);return g.promise()}});var P=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&P.test(b.name)&&a.console.warn("jQuery.Deferred exception: "+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var Q=r.Deferred();r.fn.ready=function(a){return Q.then(a)["catch"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,holdReady:function(a){a?r.readyWait++:r.ready(!0)},ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||Q.resolveWith(d,[r]))}}),r.ready.then=Q.then;function R(){d.removeEventListener("DOMContentLoaded",R),
a.removeEventListener("load",R),r.ready()}"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener("DOMContentLoaded",R),a.addEventListener("load",R));var S=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===r.type(c)){e=!0;for(h in c)S(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},T=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function U(){this.expando=r.expando+U.uid++}U.uid=1,U.prototype={cache:function(a){var b=a[this.expando];return b||(b={},T(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&"string"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){r.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(K)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var V=new U,W=new U,X=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Y=/[A-Z]/g;function Z(a){return"true"===a||"false"!==a&&("null"===a?null:a===+a+""?+a:X.test(a)?JSON.parse(a):a)}function $(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Y,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c=Z(c)}catch(e){}W.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return W.hasData(a)||V.hasData(a)},data:function(a,b,c){return W.access(a,b,c)},removeData:function(a,b){W.remove(a,b)},_data:function(a,b,c){return V.access(a,b,c)},_removeData:function(a,b){V.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=W.get(f),1===f.nodeType&&!V.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=r.camelCase(d.slice(5)),$(f,d,e[d])));V.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){W.set(this,a)}):S(this,function(b){var c;if(f&&void 0===b){if(c=W.get(f,a),void 0!==c)return c;if(c=$(f,a),void 0!==c)return c}else this.each(function(){W.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){W.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=V.get(a,b),c&&(!d||r.isArray(c)?d=V.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return V.get(a,c)||V.access(a,c,{empty:r.Callbacks("once memory").add(function(){V.remove(a,[b+"queue",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=V.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var _=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,aa=new RegExp("^(?:([+-])=|)("+_+")([a-z%]*)$","i"),ba=["Top","Right","Bottom","Left"],ca=function(a,b){return a=b||a,"none"===a.style.display||""===a.style.display&&r.contains(a.ownerDocument,a)&&"none"===r.css(a,"display")},da=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function ea(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,"")},i=h(),j=c&&c[3]||(r.cssNumber[b]?"":"px"),k=(r.cssNumber[b]||"px"!==j&&+i)&&aa.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var fa={};function ga(a){var b,c=a.ownerDocument,d=a.nodeName,e=fa[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,"display"),b.parentNode.removeChild(b),"none"===e&&(e="block"),fa[d]=e,e)}function ha(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?("none"===c&&(e[f]=V.get(d,"display")||null,e[f]||(d.style.display="")),""===d.style.display&&ca(d)&&(e[f]=ga(d))):"none"!==c&&(e[f]="none",V.set(d,"display",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ha(this,!0)},hide:function(){return ha(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){ca(this)?r(this).show():r(this).hide()})}});var ia=/^(?:checkbox|radio)$/i,ja=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,ka=/^$|\/(?:java|ecma)script/i,la={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};la.optgroup=la.option,la.tbody=la.tfoot=la.colgroup=la.caption=la.thead,la.th=la.td;function ma(a,b){var c;return c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[],void 0===b||b&&r.nodeName(a,b)?r.merge([a],c):c}function na(a,b){for(var c=0,d=a.length;c<d;c++)V.set(a[c],"globalEval",!b||V.get(b[c],"globalEval"))}var oa=/<|&#?\w+;/;function pa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if("object"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(oa.test(f)){g=g||l.appendChild(b.createElement("div")),h=(ja.exec(f)||["",""])[1].toLowerCase(),i=la[h]||la._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=ma(l.appendChild(f),"script"),j&&na(g),c){k=0;while(f=g[k++])ka.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var qa=d.documentElement,ra=/^key/,sa=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ta=/^([^.]*)(?:\.(.+)|)/;function ua(){return!0}function va(){return!1}function wa(){try{return d.activeElement}catch(a){}}function xa(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)xa(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=va;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=V.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(qa,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return"undefined"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(K)||[""],j=b.length;while(j--)h=ta.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=V.hasData(a)&&V.get(a);if(q&&(i=q.events)){b=(b||"").match(K)||[""],j=b.length;while(j--)if(h=ta.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\.)"+o.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&V.remove(a,"handle events")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(V.get(this,"events")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!("click"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&("click"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+" ",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==wa()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===wa()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&r.nodeName(this,"input"))return this.click(),!1},_default:function(a){return r.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?ua:va,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:va,isPropagationStopped:va,isImmediatePropagationStopped:va,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=ua,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=ua,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=ua,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&ra.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&sa.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return xa(this,a,b,c,d)},one:function(a,b,c,d){return xa(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=va),this.each(function(){r.event.remove(this,a,c,b)})}});var ya=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,za=/<script|<style|<link/i,Aa=/checked\s*(?:[^=]|=\s*.checked.)/i,Ba=/^true\/(.*)/,Ca=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Da(a,b){return r.nodeName(a,"table")&&r.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a:a}function Ea(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function Fa(a){var b=Ba.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ga(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(V.hasData(a)&&(f=V.access(a),g=V.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}W.hasData(a)&&(h=W.access(a),i=r.extend({},h),W.set(b,i))}}function Ha(a,b){var c=b.nodeName.toLowerCase();"input"===c&&ia.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function Ia(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&"string"==typeof q&&!o.checkClone&&Aa.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ia(f,b,c,d)});if(m&&(e=pa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(ma(e,"script"),Ea),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,ma(j,"script"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Fa),l=0;l<i;l++)j=h[l],ka.test(j.type||"")&&!V.access(j,"globalEval")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Ca,""),k))}return a}function Ja(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(ma(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&na(ma(d,"script")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(ya,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=ma(h),f=ma(a),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);if(b)if(c)for(f=f||ma(a),g=g||ma(h),d=0,e=f.length;d<e;d++)Ga(f[d],g[d]);else Ga(a,h);return g=ma(h,"script"),g.length>0&&na(g,!i&&ma(a,"script")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(T(c)){if(b=c[V.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[V.expando]=void 0}c[W.expando]&&(c[W.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ja(this,a,!0)},remove:function(a){return Ja(this,a)},text:function(a){return S(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ia(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Da(this,a);b.appendChild(a)}})},prepend:function(){return Ia(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Da(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ia(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ia(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(ma(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return S(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!za.test(a)&&!la[(ja.exec(a)||["",""])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(ma(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ia(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(ma(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var Ka=/^margin/,La=new RegExp("^("+_+")(?!px)[a-z%]+$","i"),Ma=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",i.innerHTML="",qa.appendChild(h);var b=a.getComputedStyle(i);c="1%"!==b.top,g="2px"===b.marginLeft,e="4px"===b.width,i.style.marginRight="50%",f="4px"===b.marginRight,qa.removeChild(h),i=null}}var c,e,f,g,h=d.createElement("div"),i=d.createElement("div");i.style&&(i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",o.clearCloneStyle="content-box"===i.style.backgroundClip,h.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Na(a,b,c){var d,e,f,g,h=a.style;return c=c||Ma(a),c&&(g=c.getPropertyValue(b)||c[b],""!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&La.test(g)&&Ka.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function Oa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Pa=/^(none|table(?!-c[ea]).+)/,Qa={position:"absolute",visibility:"hidden",display:"block"},Ra={letterSpacing:"0",fontWeight:"400"},Sa=["Webkit","Moz","ms"],Ta=d.createElement("div").style;function Ua(a){if(a in Ta)return a;var b=a[0].toUpperCase()+a.slice(1),c=Sa.length;while(c--)if(a=Sa[c]+b,a in Ta)return a}function Va(a,b,c){var d=aa.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Wa(a,b,c,d,e){var f,g=0;for(f=c===(d?"border":"content")?4:"width"===b?1:0;f<4;f+=2)"margin"===c&&(g+=r.css(a,c+ba[f],!0,e)),d?("content"===c&&(g-=r.css(a,"padding"+ba[f],!0,e)),"margin"!==c&&(g-=r.css(a,"border"+ba[f]+"Width",!0,e))):(g+=r.css(a,"padding"+ba[f],!0,e),"padding"!==c&&(g+=r.css(a,"border"+ba[f]+"Width",!0,e)));return g}function Xa(a,b,c){var d,e=!0,f=Ma(a),g="border-box"===r.css(a,"boxSizing",!1,f);if(a.getClientRects().length&&(d=a.getBoundingClientRect()[b]),d<=0||null==d){if(d=Na(a,b,f),(d<0||null==d)&&(d=a.style[b]),La.test(d))return d;e=g&&(o.boxSizingReliable()||d===a.style[b]),d=parseFloat(d)||0}return d+Wa(a,b,c||(g?"border":"content"),e,f)+"px"}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Na(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=a.style;return b=r.cssProps[h]||(r.cssProps[h]=Ua(h)||h),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=aa.exec(c))&&e[1]&&(c=ea(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(r.cssNumber[h]?"":"px")),o.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b);return b=r.cssProps[h]||(r.cssProps[h]=Ua(h)||h),g=r.cssHooks[b]||r.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Na(a,b,d)),"normal"===e&&b in Ra&&(e=Ra[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each(["height","width"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Pa.test(r.css(a,"display"))||a.getClientRects().length&&a.getBoundingClientRect().width?Xa(a,b,d):da(a,Qa,function(){return Xa(a,b,d)})},set:function(a,c,d){var e,f=d&&Ma(a),g=d&&Wa(a,b,d,"border-box"===r.css(a,"boxSizing",!1,f),f);return g&&(e=aa.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=r.css(a,b)),Va(a,c,g)}}}),r.cssHooks.marginLeft=Oa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Na(a,"marginLeft"))||a.getBoundingClientRect().left-da(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px"}),r.each({margin:"",padding:"",border:"Width"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];d<4;d++)e[a+ba[d]+b]=f[d]||f[d-2]||f[0];return e}},Ka.test(a)||(r.cssHooks[a+b].set=Va)}),r.fn.extend({css:function(a,b){return S(this,function(a,b,c){var d,e,f={},g=0;if(r.isArray(b)){for(d=Ma(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function Ya(a,b,c,d,e){return new Ya.prototype.init(a,b,c,d,e)}r.Tween=Ya,Ya.prototype={constructor:Ya,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?"":"px")},cur:function(){var a=Ya.propHooks[this.prop];return a&&a.get?a.get(this):Ya.propHooks._default.get(this)},run:function(a){var b,c=Ya.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ya.propHooks._default.set(this),this}},Ya.prototype.init.prototype=Ya.prototype,Ya.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},Ya.propHooks.scrollTop=Ya.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},r.fx=Ya.prototype.init,r.fx.step={};var Za,$a,_a=/^(?:toggle|show|hide)$/,ab=/queueHooks$/;function bb(){$a&&(a.requestAnimationFrame(bb),r.fx.tick())}function cb(){return a.setTimeout(function(){Za=void 0}),Za=r.now()}function db(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ba[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function eb(a,b,c){for(var d,e=(hb.tweeners[b]||[]).concat(hb.tweeners["*"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function fb(a,b,c){var d,e,f,g,h,i,j,k,l="width"in b||"height"in b,m=this,n={},o=a.style,p=a.nodeType&&ca(a),q=V.get(a,"fxshow");c.queue||(g=r._queueHooks(a,"fx"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,"fx").length||g.empty.fire()})}));for(d in b)if(e=b[d],_a.test(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=V.get(a,"display")),k=r.css(a,"display"),"none"===k&&(j?k=j:(ha([a],!0),j=a.style.display||j,k=r.css(a,"display"),ha([a]))),("inline"===k||"inline-block"===k&&null!=j)&&"none"===r.css(a,"float")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j="none"===k?"":k)),o.display="inline-block")),c.overflow&&(o.overflow="hidden",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?"hidden"in q&&(p=q.hidden):q=V.access(a,"fxshow",{display:j}),f&&(q.hidden=!p),p&&ha([a],!0),m.done(function(){p||ha([a]),V.remove(a,"fxshow");for(d in n)r.style(a,d,n[d])})),i=eb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function gb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],r.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function hb(a,b,c){var d,e,f=0,g=hb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Za||cb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:Za||cb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(gb(k,j.opts.specialEasing);f<g;f++)if(d=hb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,eb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}r.Animation=r.extend(hb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return ea(c.elem,a,aa.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=["*"]):a=a.match(K);for(var c,d=0,e=a.length;d<e;d++)c=a[d],hb.tweeners[c]=hb.tweeners[c]||[],hb.tweeners[c].unshift(b)},prefilters:[fb],prefilter:function(a,b){b?hb.prefilters.unshift(a):hb.prefilters.push(a)}}),r.speed=function(a,b,c){var e=a&&"object"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off||d.hidden?e.duration=0:"number"!=typeof e.duration&&(e.duration in r.fx.speeds?e.duration=r.fx.speeds[e.duration]:e.duration=r.fx.speeds._default),null!=e.queue&&e.queue!==!0||(e.queue="fx"),e.old=e.complete,e.complete=function(){r.isFunction(e.old)&&e.old.call(this),e.queue&&r.dequeue(this,e.queue)},e},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(ca).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=hb(this,r.extend({},a),f);(e||V.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=r.timers,g=V.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&ab.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=V.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each(["toggle","show","hide"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(db(b,!0),a,d,e)}}),r.each({slideDown:db("show"),slideUp:db("hide"),slideToggle:db("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(Za=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),Za=void 0},r.fx.timer=function(a){r.timers.push(a),a()?r.fx.start():r.timers.pop()},r.fx.interval=13,r.fx.start=function(){$a||($a=a.requestAnimationFrame?a.requestAnimationFrame(bb):a.setInterval(r.fx.tick,r.fx.interval))},r.fx.stop=function(){a.cancelAnimationFrame?a.cancelAnimationFrame($a):a.clearInterval($a),$a=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",o.checkOn=""!==a.value,o.optSelected=c.selected,a=d.createElement("input"),a.value="t",a.type="radio",o.radioValue="t"===a.value}();var ib,jb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return S(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?ib:void 0)),
void 0!==c?null===c?void r.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&"radio"===b&&r.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(K);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),ib={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\w+/g),function(a,b){var c=jb[b]||r.find.attr;jb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=jb[g],jb[g]=e,e=null!=c(a,b,d)?g:null,jb[g]=f),e}});var kb=/^(?:input|select|textarea|button)$/i,lb=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return S(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,"tabindex");return b?parseInt(b,10):kb.test(a.nodeName)||lb.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){r.propFix[this.toLowerCase()]=this});function mb(a){var b=a.match(K)||[];return b.join(" ")}function nb(a){return a.getAttribute&&a.getAttribute("class")||""}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,nb(this)))});if("string"==typeof a&&a){b=a.match(K)||[];while(c=this[i++])if(e=nb(c),d=1===c.nodeType&&" "+mb(e)+" "){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=mb(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,nb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(K)||[];while(c=this[i++])if(e=nb(c),d=1===c.nodeType&&" "+mb(e)+" "){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=mb(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,nb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=r(this),f=a.match(K)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=nb(this),b&&V.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":V.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+mb(nb(c))+" ").indexOf(b)>-1)return!0;return!1}});var ob=/\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e="":"number"==typeof e?e+="":r.isArray(e)&&(e=r.map(e,function(a){return null==a?"":a+""})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(ob,""):null==c?"":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,"value");return null!=b?b:mb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g="select-one"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!r.nodeName(c.parentNode,"optgroup"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each(["radio","checkbox"],function(){r.valHooks[this]={set:function(a,b){if(r.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var pb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,"type")?b.type:b,q=l.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!pb.test(p+r.event.triggered)&&(p.indexOf(".")>-1&&(q=p.split("."),p=q.shift(),q.sort()),k=p.indexOf(":")<0&&"on"+p,b=b[r.expando]?b:new r.Event(p,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,pb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(V.get(h,"events")||{})[b.type]&&V.get(h,"handle"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&T(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!T(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin="onfocusin"in a,o.focusin||r.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=V.access(d,b);e||d.addEventListener(a,c,!0),V.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=V.access(d,b)-1;e?V.access(d,b,e):(d.removeEventListener(a,c,!0),V.remove(d,b))}}});var qb=a.location,rb=r.now(),sb=/\?/;r.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||r.error("Invalid XML: "+b),c};var tb=/\[\]$/,ub=/\r?\n/g,vb=/^(?:submit|button|image|reset|file)$/i,wb=/^(?:input|select|textarea|keygen)/i;function xb(a,b,c,d){var e;if(r.isArray(b))r.each(b,function(b,e){c||tb.test(a)?d(a,e):xb(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==r.type(b))d(a,b);else for(e in b)xb(a+"["+e+"]",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(null==c?"":c)};if(r.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)xb(c,a[c],b,e);return d.join("&")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,"elements");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(":disabled")&&wb.test(this.nodeName)&&!vb.test(a)&&(this.checked||!ia.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:r.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(ub,"\r\n")}}):{name:b.name,value:c.replace(ub,"\r\n")}}).get()}});var yb=/%20/g,zb=/#.*$/,Ab=/([?&])_=[^&]*/,Bb=/^(.*?):[ \t]*([^\r\n]*)$/gm,Cb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Db=/^(?:GET|HEAD)$/,Eb=/^\/\//,Fb={},Gb={},Hb="*/".concat("*"),Ib=d.createElement("a");Ib.href=qb.href;function Jb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(K)||[];if(r.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Kb(a,b,c,d){var e={},f=a===Gb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Lb(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Mb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Nb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:qb.href,type:"GET",isLocal:Cb.test(qb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Hb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Lb(Lb(a,r.ajaxSettings),b):Lb(r.ajaxSettings,a)},ajaxPrefilter:Jb(Fb),ajaxTransport:Jb(Gb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks("once memory"),u=o.statusCode||{},v={},w={},x="canceled",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Bb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||qb.href)+"").replace(Eb,qb.protocol+"//"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||"*").toLowerCase().match(K)||[""],null==o.crossDomain){j=d.createElement("a");try{j.href=o.url,j.href=j.href,o.crossDomain=Ib.protocol+"//"+Ib.host!=j.protocol+"//"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&"string"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Kb(Fb,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger("ajaxStart"),o.type=o.type.toUpperCase(),o.hasContent=!Db.test(o.type),f=o.url.replace(zb,""),o.hasContent?o.data&&o.processData&&0===(o.contentType||"").indexOf("application/x-www-form-urlencoded")&&(o.data=o.data.replace(yb,"+")):(n=o.url.slice(f.length),o.data&&(f+=(sb.test(f)?"&":"?")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Ab,"$1"),n=(sb.test(f)?"&":"?")+"_="+rb++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader("If-Modified-Since",r.lastModified[f]),r.etag[f]&&y.setRequestHeader("If-None-Match",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader("Content-Type",o.contentType),y.setRequestHeader("Accept",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+("*"!==o.dataTypes[0]?", "+Hb+"; q=0.01":""):o.accepts["*"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x="abort",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Kb(Gb,o,c,y)){if(y.readyState=1,l&&q.trigger("ajaxSend",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort("timeout")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,"No Transport");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||"",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Mb(o,y,d)),v=Nb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader("Last-Modified"),w&&(r.lastModified[f]=w),w=y.getResponseHeader("etag"),w&&(r.etag[f]=w)),204===b||"HEAD"===o.type?x="nocontent":304===b?x="notmodified":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x="error",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+"",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?"ajaxSuccess":"ajaxError",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger("ajaxComplete",[y,o]),--r.active||r.event.trigger("ajaxStop")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,"json")},getScript:function(a,b){return r.get(a,void 0,b,"script")}}),r.each(["get","post"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not("body").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Ob={0:200,1223:204},Pb=r.ajaxSettings.xhr();o.cors=!!Pb&&"withCredentials"in Pb,o.ajax=Pb=!!Pb,r.ajaxTransport(function(b){var c,d;if(o.cors||Pb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Ob[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),r.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Qb=[],Rb=/(=)\?(?=&|$)|\?\?/;r.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Qb.pop()||r.expando+"_"+rb++;return this[a]=!0,a}}),r.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Rb.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Rb.test(b.data)&&"data");if(h||"jsonp"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Rb,"$1"+e):b.jsonp!==!1&&(b.url+=(sb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||r.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Qb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),"script"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument("").body;return a.innerHTML="<form></form><form></form>",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if("string"!=typeof a)return[];"boolean"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(""),e=b.createElement("base"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=B.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=pa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=mb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&r.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?r("<div>").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length};function Sb(a){return r.isWindow(a)?a:9===a.nodeType&&a.defaultView}r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,"position"),l=r(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=r.css(a,"top"),i=r.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),d.width||d.height?(e=f.ownerDocument,c=Sb(e),b=e.documentElement,{top:d.top+c.pageYOffset-b.clientTop,left:d.left+c.pageXOffset-b.clientLeft}):d):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===r.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),r.nodeName(a[0],"html")||(d=a.offset()),d={top:d.top+r.css(a[0],"borderTopWidth",!0),left:d.left+r.css(a[0],"borderLeftWidth",!0)}),{top:b.top-d.top-r.css(c,"marginTop",!0),left:b.left-d.left-r.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===r.css(a,"position"))a=a.offsetParent;return a||qa})}}),r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;r.fn[a]=function(d){return S(this,function(a,d,e){var f=Sb(a);return void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each(["top","left"],function(a,b){r.cssHooks[b]=Oa(o.pixelPosition,function(a,c){if(c)return c=Na(a,b),La.test(c)?r(a).position()[b]+"px":c})}),r.each({Height:"height",Width:"width"},function(a,b){r.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||"boolean"!=typeof e),h=c||(e===!0||f===!0?"margin":"border");return S(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf("outer")?b["inner"+a]:b.document.documentElement["client"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body["scroll"+a],f["scroll"+a],b.body["offset"+a],f["offset"+a],f["client"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),r.parseJSON=JSON.parse,"function"==typeof define&&define.amd&&define("jquery",[],function(){return r});var Tb=a.jQuery,Ub=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Ub),b&&a.jQuery===r&&(a.jQuery=Tb),r},b||(a.jQuery=a.$=r),r});

(function() {
  'use strict';

  function initializePage(){
    setCarousel();
    getProduct();
  };

  function getProduct(){
      $.ajax('http://localhost:3000/api/product.json').then(alert('hey'));
  }

  function setCarousel(){
    new ch.Carousel(ch('.related-products-slider')[0], { pagination: true });
  }

  initializePage();
  
})();

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRpbnkuanMiLCJjaGljby5qcyIsImpxdWVyeS5taW4uanMiLCJtYWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzU0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoibWFpbi5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHRpbnkuanMgdjAuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBNZXJjYWRvTGlicmUuY29tXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vbWVyY2Fkb2xpYnJlL3RpbnkuanMvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG59LHt9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG59LHt9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdChleCkge1xuICAgIHJldHVybiBleCAmJiAodHlwZW9mIGV4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihleCkpID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZXggPyBleFsnZGVmYXVsdCddIDogZXg7XG59XG5cbnZhciBpbmhlcml0cyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdpbmhlcml0cycpKTtcbnZhciBFdmVudEVtaXR0ZXIgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZXZlbnRzJykpO1xuXG5mdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcIm9ialwiIHBhcmFtZXRlciBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvcHkgPSB7fSxcbiAgICAgICAgcHJvcCA9IHZvaWQgMDtcblxuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9ialtwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gICAgLy8gTm90IHBsYWluIG9iamVjdHM6XG4gICAgLy8gLSBudWxsXG4gICAgLy8gLSB1bmRlZmluZWRcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyAtIEFueSBvYmplY3Qgb3IgdmFsdWUgd2hvc2UgaW50ZXJuYWwgW1tDbGFzc11dIHByb3BlcnR5IGlzIG5vdCBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgLy8gLSBET00gbm9kZXNcbiAgICAvLyAtIHdpbmRvd1xuICAgIGlmICgodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgIT09ICdvYmplY3QnIHx8IG9iai5ub2RlVHlwZSB8fCBvYmogPT09IG9iai53aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvYmouY29uc3RydWN0b3IgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCAnaXNQcm90b3R5cGVPZicpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZnVuY3Rpb24gaGFzbid0IHJldHVybmVkIGFscmVhZHksIHdlJ3JlIGNvbmZpZGVudCB0aGF0XG4gICAgLy8gfG9ianwgaXMgYSBwbGFpbiBvYmplY3QsIGNyZWF0ZWQgYnkge30gb3IgY29uc3RydWN0ZWQgd2l0aCBuZXcgT2JqZWN0XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZvaWQgMCxcbiAgICAgICAgbmFtZSA9IHZvaWQgMCxcbiAgICAgICAgc3JjID0gdm9pZCAwLFxuICAgICAgICBjb3B5ID0gdm9pZCAwLFxuICAgICAgICBjb3B5SXNBcnJheSA9IHZvaWQgMCxcbiAgICAgICAgY2xvbmUgPSB2b2lkIDAsXG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGRlZXAgPSBmYWxzZTtcblxuICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGRlZXAgPSB0YXJnZXQ7XG5cbiAgICAgICAgLy8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV0gfHwge307XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcbiAgICBpZiAoKHR5cGVvZiB0YXJnZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRhcmdldCkpICE9PSAnb2JqZWN0JyAmJiAhKHR5cGVvZiB0YXJnZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRhcmdldCkpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRhcmdldCA9IHt9O1xuICAgIH1cblxuICAgIC8vIE5vdGhpbmcgdG8gZXh0ZW5kLCByZXR1cm4gb3JpZ2luYWwgb2JqZWN0XG4gICAgaWYgKGxlbmd0aCA8PSBpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gICAgICAgIGlmICgob3B0aW9ucyA9IGFyZ3VtZW50c1tpXSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgICAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbbmFtZV07XG5cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gY29weSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcbiAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBjb3B5ICYmIChpc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29weSkpKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3B5SXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gZXh0ZW5kKGRlZXAsIGNsb25lLCBjb3B5KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb3B5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gYWpheCh1cmwsIHNldHRpbmdzKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIG9wdHMgPSB2b2lkIDA7XG5cbiAgICBzZXR0aW5ncyA9IGFyZ3MubGVuZ3RoID09PSAxID8gYXJnc1swXSA6IGFyZ3NbMV07XG5cbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgdXJsOiBhcmdzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgdXJsID09PSAnc3RyaW5nJyA/IHVybCA6ICcuJyxcbiAgICAgICAgY2FjaGU6IHRydWUsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgICBkYXRhVHlwZTogJ3RleHQnLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBjcmVkZW50aWFsczogJ29taXQnLFxuICAgICAgICBzdWNjZXNzOiBub29wLFxuICAgICAgICBlcnJvcjogbm9vcCxcbiAgICAgICAgY29tcGxldGU6IG5vb3BcbiAgICB9O1xuXG4gICAgb3B0cyA9IGV4dGVuZChkZWZhdWx0cywgc2V0dGluZ3MgfHwge30pO1xuXG4gICAgdmFyIG1pbWVUeXBlcyA9IHtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnanNvbicsXG4gICAgICAgICd0ZXh0L2h0bWwnOiAnaHRtbCcsXG4gICAgICAgICd0ZXh0L3BsYWluJzogJ3RleHQnXG4gICAgfTtcblxuICAgIHZhciBkYXRhVHlwZXMgPSB7fTtcbiAgICBmb3IgKHZhciB0eXBlIGluIG1pbWVUeXBlcykge1xuICAgICAgICBpZiAobWltZVR5cGVzLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICAgICAgICBkYXRhVHlwZXNbbWltZVR5cGVzW3R5cGVdXSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW9wdHMuY2FjaGUpIHtcbiAgICAgICAgb3B0cy51cmwgPSBvcHRzLnVybCArICh+b3B0cy51cmwuaW5kZXhPZignPycpID8gJyYnIDogJz8nKSArICduYz0nICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOWU5KTtcbiAgICB9XG5cbiAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZShzdGF0dXMsIHhocikge1xuICAgICAgICBvcHRzLmNvbXBsZXRlLmNhbGwob3B0cy5jb250ZXh0LCB4aHIsIHN0YXR1cyk7XG4gICAgfTtcblxuICAgIHZhciBzdWNjZXNzID0gZnVuY3Rpb24gc3VjY2VzcyhkYXRhLCB4aHIpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9ICdzdWNjZXNzJztcbiAgICAgICAgb3B0cy5zdWNjZXNzLmNhbGwob3B0cy5jb250ZXh0LCBkYXRhLCBzdGF0dXMsIHhocik7XG4gICAgICAgIGNvbXBsZXRlKHN0YXR1cywgeGhyKTtcbiAgICB9O1xuXG4gICAgdmFyIGVycm9yID0gZnVuY3Rpb24gZXJyb3IoX2Vycm9yLCBzdGF0dXMsIHhocikge1xuICAgICAgICBvcHRzLmVycm9yLmNhbGwob3B0cy5jb250ZXh0LCB4aHIsIHN0YXR1cywgX2Vycm9yKTtcbiAgICAgICAgY29tcGxldGUoc3RhdHVzLCB4aHIpO1xuICAgIH07XG5cbiAgICAvLyB0b1N0cmluZyBzaG9ydGN1dCBmb3IgRFJZXG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIHZhciBub3JtYWxpemVSZXF1ZXN0RGF0YSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVJlcXVlc3REYXRhKGRhdGEsIGhlYWRlcnMsIGNvcnMpIHtcbiAgICAgICAgdmFyIGNoYXJzZXQgPSAnY2hhcnNldD1VVEYtOCc7XG4gICAgICAgIHZhciBmb3JtVXJsRW5jb2RlZCA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7ICcgKyBjaGFyc2V0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSB8fCAvXlxcW29iamVjdFxccyhBcnJheUJ1ZmZlcnxGaWxlfEJsb2IpXFxdJC8udGVzdCh0b1N0cmluZy5jYWxsKGRhdGEpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyB8fCB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSBmb3JtVXJsRW5jb2RlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhICE9PSBudWxsICYmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0YSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ycykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29udGVudCB0eXBlIG9mIGEgQ09SUyByZXF1ZXN0IGlzIGxpbWl0ZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkLCBtdWx0aXBhcnQvZm9ybS1kYXRhLCBvciB0ZXh0L3BsYWluXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gZm9ybVVybEVuY29kZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbjsgICcgKyBjaGFyc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgbWV0aG9kIG5hbWVcbiAgICBvcHRzLm1ldGhvZCA9IG9wdHMubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAvLyBTZXQgdGhlIGNyb3NzIGRvbWFpbiBvcHRpb25cbiAgICAvLyBUbyBhdm9pZCB0aGUgcHJlZmxpZ2h0IHJlcXVlc3RzIHBsZWFzZSB1c2UgdGhlIFwic2ltcGxlXCIgcmVxdWVzdHMgb25seVxuICAgIC8vIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2NvcnMvI3Jlc291cmNlLXJlcXVlc3RzXG4gICAgdmFyIHRlc3RBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgdmFyIG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbiAgICB0cnkge1xuICAgICAgICB0ZXN0QW5jaG9yLmhyZWYgPSBvcHRzLnVybDtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSBsdGUgMTFcbiAgICAgICAgLy8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gb3B0cy51cmwgaXMgcmVsYXRpdmVcbiAgICAgICAgdGVzdEFuY2hvci5ocmVmID0gdGVzdEFuY2hvci5ocmVmO1xuICAgICAgICBvcHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgJy8vJyArIG9yaWdpbkFuY2hvci5ob3N0ICE9PSB0ZXN0QW5jaG9yLnByb3RvY29sICsgJy8vJyArIHRlc3RBbmNob3IuaG9zdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG9wdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHZhciB1c2VYRFIgPSBvcHRzLmNyb3NzRG9tYWluICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSAmJiAnWERvbWFpblJlcXVlc3QnIGluIHdpbmRvdztcblxuICAgIGlmICh1c2VYRFIpIHtcbiAgICAgICAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGluc3RlYWQgb2YgWE1MSHR0cFJlcXVlc3QgZm9yIElFPD05IGFuZCB3aGVuIENPUlMgaXMgcmVxdWVzdGVkXG4gICAgICAgIHhociA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1pbWUgPSB4aHIuY29udGVudFR5cGU7XG4gICAgICAgICAgICB2YXIgZGF0YVR5cGUgPSBtaW1lICYmIG1pbWVUeXBlc1ttaW1lWzFdXSA/IG1pbWVUeXBlc1ttaW1lWzFdXS50b0xvd2VyQ2FzZSgpIDogJ2pzb24nO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKGRhdGFUeXBlID09PSAnanNvbicpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWNjZXNzKHJlc3VsdCwgeGhyKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGlsbCBjYW5ub3QgdXNlIHhoci5vbmxvYWQgZm9yIG5vcm1hbCB4aHIgZHVlIHRvIHJlcXVpcmVkIHN1cHBvcnQgb2YgSUU4IHdoaWNoXG4gICAgICAgIC8vIGhhcyBubyBgb25sb2FkYCBldmVudCBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM1ODc0KHY9dnMuODUpLmFzcHgjZXZlbnRzXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cztcblxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWltZSA9IC8oW1xcL2Etel0rKSg7fFxcc3wkKS8uZXhlYyh4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFUeXBlID0gbWltZSAmJiBtaW1lVHlwZXNbbWltZVsxXV0gPyBtaW1lVHlwZXNbbWltZVsxXV0udG9Mb3dlckNhc2UoKSA6ICd0ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geGhyLnJlc3BvbnNlVGV4dDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT09ICdqc29uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MocmVzdWx0LCB4aHIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKG5ldyBFcnJvcih4aHIuc3RhdHVzVGV4dCksICdlcnJvcicsIHhociwgb3B0cyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBlcnJvcihuZXcgRXJyb3IoeGhyLnN0YXR1c1RleHQgfHwgJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSwgJ2Vycm9yJywgeGhyLCBvcHRzKTtcbiAgICB9O1xuXG4gICAgaWYgKChvcHRzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgb3B0cy5tZXRob2QgPT09ICdIRUFEJykgJiYgdHlwZW9mIG9wdHMuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0cy51cmwgKz0gKH5vcHRzLnVybC5pbmRleE9mKCc/JykgPyAnJicgOiAnPycpICsgb3B0cy5kYXRhO1xuICAgIH1cblxuICAgIHhoci5vcGVuKG9wdHMubWV0aG9kLCBvcHRzLnVybCk7XG5cbiAgICBpZiAob3B0cy5kYXRhVHlwZSAmJiBkYXRhVHlwZXNbb3B0cy5kYXRhVHlwZS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICBvcHRzLmhlYWRlcnMuQWNjZXB0ID0gZGF0YVR5cGVzW29wdHMuZGF0YVR5cGUudG9Mb3dlckNhc2UoKV0gKyAnLCAqLyo7IHE9MC4wMSc7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBcIlgtUmVxdWVzdGVkLVdpdGhcIiBoZWFkZXIgb25seSBpZiBpdCBpcyBub3QgYWxyZWFkeSBzZXRcbiAgICBpZiAoIW9wdHMuY3Jvc3NEb21haW4gJiYgIW9wdHMuaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddKSB7XG4gICAgICAgIG9wdHMuaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIG9wdHMuZGF0YSA9IG5vcm1hbGl6ZVJlcXVlc3REYXRhKG9wdHMuZGF0YSwgb3B0cy5oZWFkZXJzLCBvcHRzLmNyb3NzRG9tYWluKTtcblxuICAgIGlmICghdXNlWERSKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0cy5oZWFkZXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgeGhyLnNlbmQob3B0cy5kYXRhKTtcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuLy8gZG9jdW1lbnQuaGVhZCBpcyBub3QgYXZhaWxhYmxlIGluIElFPDlcbnZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblxudmFyIGpzb25wQ291bnQgPSAwO1xuXG4vKipcbiAqIEpTT05QIGhhbmRsZXJcbiAqXG4gKiBAbWVtYmVyb2YgdGlueVxuICogQG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBPcHRpb25hbCBvcHRzLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLnByZWZpeF0gQ2FsbGJhY2sgcHJlZml4LiBEZWZhdWx0OiBgX19qc29ucGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5wYXJhbV0gUVMgcGFyYW1ldGVyLiBEZWZhdWx0OiBgY2FsbGJhY2tgXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW29wdHMubmFtZV0gVGhlIG5hbWUgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXRcbiAqICAgcmVjZWl2ZXMgdGhlIHJlc3VsdC4gRGVmYXVsdDogYG9wdHMucHJlZml4JHtpbmNyZW1lbnR9YFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLnRpbWVvdXRdIEhvdyBsb25nIGFmdGVyIHRoZSByZXF1ZXN0IHVudGlsIGEgdGltZW91dFxuICogICBlcnJvciB3aWxsIG9jY3VyLiBEZWZhdWx0OiAxNTAwMFxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNhbmNlbCBmdW5jdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgY2FuY2VsID0gdGlueS5qc29ucCgnaHR0cDovL3N1Z2dlc3Rnei5tbGFwcHMuY29tL3NpdGVzL01MQS9hdXRvc3VnZ2VzdD9xPXNtYXJ0cGhvbmUmdj0xJywge3RpbWVvdXQ6IDUwMDB9KTtcbiAqIGlmIChzb21ldGhpbmcpIHtcbiAqICAgY2FuY2VsKCk7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGpzb25wKHVybCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgaWQgPSB2b2lkIDAsXG4gICAgICAgIHNjcmlwdCA9IHZvaWQgMCxcbiAgICAgICAgdGltZXIgPSB2b2lkIDAsXG4gICAgICAgIGNsZWFudXAgPSB2b2lkIDAsXG4gICAgICAgIGNhbmNlbCA9IHZvaWQgMDtcblxuICAgIHZhciBvcHRzID0gZXh0ZW5kKHtcbiAgICAgICAgcHJlZml4OiAnX19qc29ucCcsXG4gICAgICAgIHBhcmFtOiAnY2FsbGJhY2snLFxuICAgICAgICB0aW1lb3V0OiAxNTAwMCxcbiAgICAgICAgc3VjY2Vzczogbm9vcCxcbiAgICAgICAgZXJyb3I6IG5vb3BcbiAgICB9LCBzZXR0aW5ncyk7XG5cbiAgICAvLyBHZW5lcmF0ZSBhbiB1bmlxdWUgaWQgZm9yIHRoZSByZXF1ZXN0LlxuICAgIGpzb25wQ291bnQrKztcbiAgICBpZCA9IG9wdHMubmFtZSA/IHR5cGVvZiBvcHRzLm5hbWUgPT09ICdmdW5jdGlvbicgPyBvcHRzLm5hbWUob3B0cy5wcmVmaXgsIGpzb25wQ291bnQpIDogb3B0cy5uYW1lIDogb3B0cy5wcmVmaXggKyBqc29ucENvdW50Kys7XG5cbiAgICBjbGVhbnVwID0gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzY3JpcHQgdGFnLlxuICAgICAgICBpZiAoc2NyaXB0ICYmIHNjcmlwdC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgZGVsZXRlIHRoZSBqc29ucCBoYW5kbGVyIGZyb20gd2luZG93IHRvIG5vdCBnZW5lcmF0ZSBhbiBlcnJvclxuICAgICAgICAvLyB3aGVuIHNjcmlwdCB3aWxsIGJlIGxvYWRlZCBhZnRlciBjbGVhbmluZ1xuICAgICAgICB3aW5kb3dbaWRdID0gbm9vcDtcblxuICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG9wdHMudGltZW91dCkge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgb3B0cy5lcnJvcihuZXcgRXJyb3IoJ1NjcmlwdCBsb2FkaW5nIHRpbWVvdXQnKSk7XG4gICAgICAgIH0sIG9wdHMudGltZW91dCk7XG4gICAgfVxuXG4gICAgd2luZG93W2lkXSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgb3B0cy5zdWNjZXNzKGRhdGEpO1xuICAgIH07XG5cbiAgICAvLyBBZGQgcXVlcnlzdHJpbmcgY29tcG9uZW50XG4gICAgdXJsICs9ICh+dXJsLmluZGV4T2YoJz8nKSA/ICcmJyA6ICc/JykgKyBvcHRzLnBhcmFtICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKTtcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgnPyYnLCAnPycpO1xuXG4gICAgLy8gQ3JlYXRlIHNjcmlwdCBlbGVtZW50XG4gICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBvcHRzLmVycm9yKG5ldyBFcnJvcihlLm1lc3NhZ2UgfHwgJ1NjcmlwdCBFcnJvcicpKTtcbiAgICB9O1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuICAgIGNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHdpbmRvd1tpZF0pIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gY2FuY2VsO1xufVxuXG4vLyBCYXNlZCBvbiB0aGUgaHR0cHM6Ly9naXRodWIuY29tL3BhYmxvbW9yZXR0aS9qY29ycy1sb2FkZXIgd3JpdHRlbiBieSBQYWJsbyBNb3JldHRpXG5cbi8qIHByaXZhdGUgKi9cblxudmFyIGRvY3VtZW50JDEgPSB3aW5kb3cuZG9jdW1lbnQ7XG52YXIgbm9kZV9jcmVhdGVFbGVtZW50U2NyaXB0ID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbnZhciBub2RlX2VsZW1lbnRTY3JpcHQgPSBkb2N1bWVudCQxLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbnZhciBidWZmZXIgPSBbXTtcbnZhciBsYXN0QnVmZmVySW5kZXggPSAwO1xudmFyIGNyZWF0ZUNPUlNSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB4aHIgPSB2b2lkIDAsXG4gICAgICAgIENPUlNSZXF1ZXN0ID0gdm9pZCAwO1xuICAgIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgeGhyID0gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICBDT1JTUmVxdWVzdCA9IGZ1bmN0aW9uIENPUlNSZXF1ZXN0KHVybCkge1xuICAgICAgICAgICAgICAgIHhociA9IG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICB4aHIub3BlbignZ2V0JywgdXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgICAgIENPUlNSZXF1ZXN0ID0gZnVuY3Rpb24gQ09SU1JlcXVlc3QodXJsKSB7XG4gICAgICAgICAgICAgICAgeGhyID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIHhoci5vcGVuKCdnZXQnLCB1cmwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB4aHI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENPUlNSZXF1ZXN0O1xufSgpO1xuZnVuY3Rpb24gZXhlY3V0ZShzY3JpcHQpIHtcbiAgICBpZiAodHlwZW9mIHNjcmlwdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGcgPSBub2RlX2NyZWF0ZUVsZW1lbnRTY3JpcHQuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgZy50ZXh0ID0gc2NyaXB0O1xuICAgICAgICBub2RlX2VsZW1lbnRTY3JpcHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZywgbm9kZV9lbGVtZW50U2NyaXB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzY3JpcHQuYXBwbHkod2luZG93KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNhdmVJbkJ1ZmZlcihpbmRleCwgc2NyaXB0KSB7XG4gICAgYnVmZmVyW2luZGV4XSA9IHNjcmlwdDtcbn1cblxuZnVuY3Rpb24gZmluaXNoZWRUYXNrKGluZGV4KSB7XG4gICAgc2F2ZUluQnVmZmVyKGluZGV4LCBudWxsKTtcbiAgICBsYXN0QnVmZmVySW5kZXggPSBpbmRleCArIDE7XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVCdWZmZXIoKSB7XG4gICAgdmFyIGRlcCA9IHRydWUsXG4gICAgICAgIHNjcmlwdCA9IHZvaWQgMCxcbiAgICAgICAgaW5kZXggPSBsYXN0QnVmZmVySW5kZXgsXG4gICAgICAgIGxlbiA9IGJ1ZmZlci5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW4gJiYgZGVwKSB7XG4gICAgICAgIHNjcmlwdCA9IGJ1ZmZlcltpbmRleF07XG4gICAgICAgIGlmIChzY3JpcHQgIT09IHVuZGVmaW5lZCAmJiBzY3JpcHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGV4ZWN1dGUoc2NyaXB0KTtcbiAgICAgICAgICAgIGZpbmlzaGVkVGFzayhpbmRleCk7XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvYWRzQW5kRXhlY3V0ZVNjcmlwdHNPbkNoYWluKCkge1xuICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2NyID0gYnVmZmVyLnBvcCgpLFxuICAgICAgICAgICAgICAgIHNjcmlwdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG5vZGVfY3JlYXRlRWxlbWVudFNjcmlwdC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5zcmMgPSBzY3I7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NyaXB0LnJlYWR5U3RhdGUgfHwgL2xvYWRlZHxjb21wbGV0ZS8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBtZW1vcnkgbGVhayBpbiBJRVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVyZWZlcmVuY2UgdGhlIHNjcmlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZHNBbmRFeGVjdXRlU2NyaXB0c09uQ2hhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbm9kZV9lbGVtZW50U2NyaXB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgbm9kZV9lbGVtZW50U2NyaXB0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NyLmFwcGx5KHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgbG9hZHNBbmRFeGVjdXRlU2NyaXB0c09uQ2hhaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9ubG9hZENPUlNIYW5kbGVyKHJlcXVlc3QsIGluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2F2ZUluQnVmZmVyKGluZGV4LCByZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIGV4ZWN1dGVCdWZmZXIoKTtcbiAgICAgICAgLy8gRGVyZWZlcmVuY2UgdGhlIHNjcmlwdFxuICAgICAgICByZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGxvYWRXaXRoQ09SUygpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHJlcXVlc3Q7XG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCArPSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2luZGV4XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlcXVlc3QgPSBjcmVhdGVDT1JTUmVxdWVzdChhcmd1bWVudHNbaW5kZXhdKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gb25sb2FkQ09SU0hhbmRsZXIocmVxdWVzdCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICBzYXZlSW5CdWZmZXIoYnVmZmVyLmxlbmd0aCwgbnVsbCk7XG4gICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNhdmVJbkJ1ZmZlcihidWZmZXIubGVuZ3RoLCBhcmd1bWVudHNbaW5kZXhdKTtcbiAgICAgICAgICAgIGV4ZWN1dGVCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbG9hZFdpdGhvdXRDT1JTKCkge1xuICAgIGJ1ZmZlci5wdXNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkucmV2ZXJzZSgpKTtcbiAgICBsb2Fkc0FuZEV4ZWN1dGVTY3JpcHRzT25DaGFpbigpO1xufVxuXG52YXIgamNvcnMgPSBjcmVhdGVDT1JTUmVxdWVzdCA/IGxvYWRXaXRoQ09SUyA6IGxvYWRXaXRob3V0Q09SUztcblxudmFyIHN1cHBvcnQgPSB7XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IHRoYXQgQ1NTIFRyYW5zaXRpb25zIGFyZSBzdXBwb3J0ZWQgKG9yIGFueSBvZiBpdHMgYnJvd3Nlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtCb29sZWFufE9iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlmICh0aW55LnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH1cbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uRW5kKCksXG5cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgdGhhdCBDU1MgQW5pbWF0aW9ucyBhcmUgc3VwcG9ydGVkIChvciBhbnkgb2YgaXRzIGJyb3dzZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbnxPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpZiAodGlueS5zdXBwb3J0LmFuaW1hdGlvbikge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH1cbiAgICAgKi9cbiAgICBhbmltYXRpb246IGFuaW1hdGlvbkVuZCgpLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlzIHRoZSBVc2VyIEFnZW50IHN1cHBvcnRzIHRvdWNoIGV2ZW50cy5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlmICh0aW55LnN1cHBvcnQudG91Y2gpIHtcbiAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9XG4gICAgICovXG4gICAgdG91Y2g6ICdvbnRvdWNoZW5kJyBpbiBkb2N1bWVudCxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpcyB0aGUgVXNlciBBZ2VudCBzdXBwb3J0cyBjdXN0b20gZXZlbnRzLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogaWYgKHRpbnkuc3VwcG9ydC5jdXN0b21FdmVudCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH1cbiAgICAgKi9cbiAgICBjdXN0b21FdmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPOiBmaW5kIGJldHRlciBzb2x1dGlvbiBmb3IgQ3VzdG9tRXZlbnQgY2hlY2tcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIElFOCBoYXMgbm8gc3VwcG9ydCBmb3IgQ3VzdG9tRXZlbnQsIGluIElFIGd0ZSA5IGl0IGNhbm5vdCBiZVxuICAgICAgICAgICAgLy8gaW5zdGFudGlhdGVkIGJ1dCBleGlzdFxuICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHt9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KClcbn07XG5cbi8qKlxuICogQ2hlY2tzIGZvciB0aGUgQ1NTIFRyYW5zaXRpb25zIHN1cHBvcnQgKGh0dHA6Ly93d3cubW9kZXJuaXpyLmNvbS8pXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cmFuc2l0aW9uRW5kKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RpbnknKTtcblxuICAgIHZhciB0cmFuc0VuZEV2ZW50TmFtZXMgPSB7XG4gICAgICAgIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICAgTW96VHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgICBPVHJhbnNpdGlvbjogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcbiAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXG4gICAgfTtcblxuICAgIGZvciAodmFyIF9uYW1lIGluIHRyYW5zRW5kRXZlbnROYW1lcykge1xuICAgICAgICBpZiAodHJhbnNFbmRFdmVudE5hbWVzLmhhc093blByb3BlcnR5KF9uYW1lKSAmJiBlbC5zdHlsZVtfbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbmQ6IHRyYW5zRW5kRXZlbnROYW1lc1tfbmFtZV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGZvciB0aGUgQ1NTIEFuaW1hdGlvbnMgc3VwcG9ydFxuICpcbiAqIEBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYW5pbWF0aW9uRW5kKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RpbnknKTtcblxuICAgIHZhciBhbmltRW5kRXZlbnROYW1lcyA9IHtcbiAgICAgICAgV2Via2l0QW5pbWF0aW9uOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcbiAgICAgICAgTW96QW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJyxcbiAgICAgICAgT0FuaW1hdGlvbjogJ29BbmltYXRpb25FbmQgb2FuaW1hdGlvbmVuZCcsXG4gICAgICAgIGFuaW1hdGlvbjogJ2FuaW1hdGlvbmVuZCdcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX25hbWUyIGluIGFuaW1FbmRFdmVudE5hbWVzKSB7XG4gICAgICAgIGlmIChhbmltRW5kRXZlbnROYW1lcy5oYXNPd25Qcm9wZXJ0eShfbmFtZTIpICYmIGVsLnN0eWxlW19uYW1lMl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbmQ6IGFuaW1FbmRFdmVudE5hbWVzW19uYW1lMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbnZhciBpc0NsYXNzTGlzdCA9ICEhdGVzdEVsLmNsYXNzTGlzdDtcblxuLyoqXG4gKiBBZGRzIHRoZSBzcGVjaWZpZWQgY2xhc3MgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSBlbCB7SFRNTEVsZW1lbnR9XG4gKiBAcGFyYW0gY2xhc3NOYW1lIHtTdHJpbmd9XG4gKlxuICogQGV4YW1wbGVcbiAqIHRpbnkuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3RpbnktZXhhbXBsZScpO1xuICovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGlzQ2xhc3NMaXN0KSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpICsgJyAnICsgY2xhc3NOYW1lKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgc2luZ2xlIGNsYXNzIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSBlbCB7SFRNTEVsZW1lbnR9XG4gKiBAcGFyYW0gY2xhc3NOYW1lIHtTdHJpbmd9XG4gKlxuICogQGV4YW1wbGVcbiAqIHRpbnkucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3RpbnktZXhhbXBsZScpO1xuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGlzQ2xhc3NMaXN0KSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZWwuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgnKF58XFxcXGIpJyArIGNsYXNzTmFtZS5zcGxpdCgnICcpLmpvaW4oJ3wnKSArICcoXFxcXGJ8JCknLCAnZ2knKSwgJyAnKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIGlzIHRoZSBnaXZlbiBjbGFzcyBpcyBhc3NpZ25lZCB0byBhbiBlbGVtZW50XG4gKiBAcGFyYW0gZWwge0hUTUxFbGVtZW50fVxuICogQHBhcmFtIGNsYXNzTmFtZSB7U3RyaW5nfVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKlxuICogQGV4YW1wbGVcbiAqIHRpbnkuaGFzQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3RpbnktZXhhbXBsZScpO1xuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgdmFyIGV4aXN0O1xuICAgIGlmIChpc0NsYXNzTGlzdCkge1xuICAgICAgICBleGlzdCA9IGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0ID0gbmV3IFJlZ0V4cCgnKF58ICknICsgY2xhc3NOYW1lICsgJyggfCQpJywgJ2dpJykudGVzdChlbC5jbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZXhpc3Q7XG59XG5cbnZhciBjbGFzc0xpc3QgPSB7XG4gICAgYWRkQ2xhc3M6IGFkZENsYXNzLFxuICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgICBoYXNDbGFzczogaGFzQ2xhc3Ncbn07XG5cbi8qKlxuICogR2V0IHRoZSBwYXJlbnQgb2YgYW4gZWxlbWVudCwgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBhIHRhZ1xuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFnbmFtZVxuICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICpcbiAqIEBleGFtcGxlXG4gKiB0aW55LnBhcmVudChlbCwgJ2RpdicpO1xuICovXG5mdW5jdGlvbiBwYXJlbnQoZWwsIHRhZ25hbWUpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGVsLnBhcmVudE5vZGU7XG4gICAgdmFyIHRhZyA9IHRhZ25hbWUgPyB0YWduYW1lLnRvVXBwZXJDYXNlKCkgOiB0YWduYW1lO1xuXG4gICAgaWYgKHBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudE5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudChwYXJlbnROb2RlLCB0YWcpO1xuICAgIH1cblxuICAgIGlmICh0YWduYW1lICE9PSB1bmRlZmluZWQgJiYgcGFyZW50Tm9kZS50YWdOYW1lID09PSB0YWcpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gICAgfSBlbHNlIGlmICh0YWduYW1lICE9PSB1bmRlZmluZWQgJiYgcGFyZW50Tm9kZS50YWdOYW1lICE9PSB0YWcpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudChwYXJlbnROb2RlLCB0YWcpO1xuICAgIH0gZWxzZSBpZiAodGFnbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBJRTggc2FmZSBtZXRob2QgdG8gZ2V0IHRoZSBuZXh0IGVsZW1lbnQgc2libGluZ1xuICpcbiAqIEBtZW1iZXJvZiB0aW55XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBBIGdpdmVuIEhUTUxFbGVtZW50LlxuICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICpcbiAqIEBleGFtcGxlXG4gKiB0aW55Lm5leHQoZWwpO1xuICovXG5mdW5jdGlvbiBuZXh0KGVsZW1lbnQpIHtcbiAgICBmdW5jdGlvbiBuZXh0KGVsKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7XG4gICAgICAgIH0gd2hpbGUgKGVsICYmIGVsLm5vZGVUeXBlICE9PSAxKTtcblxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nIHx8IG5leHQoZWxlbWVudCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhIGNvbXB1dGVkIHN0eWxlIGZvciB0aGUgZmlyc3QgZWxlbWVudCBpbiBzZXQgb2ZcbiAqIG1hdGNoZWQgZWxlbWVudHMgb3Igc2V0IG9uZSBvciBtb3JlIENTUyBwcm9wZXJ0aWVzIGZvciBldmVyeSBtYXRjaGVkIGVsZW1lbnQuXG4gKlxuICogQG1lbWJlcm9mIHRpbnlcbiAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fSBlbGVtIENTUyBzZWxlY3RvciBvciBhbiBIVE1MIEVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IEEgQ1NTIHByb3BlcnR5IG9yIGEgbWFwIG9mIDxwcm9wZXJ0eSwgdmFsdWU+IHdoZW4gdXNlZCBhcyBzZXR0ZXIuXG4gKiBAcGFyYW0ge1NyZWluZ30gdmFsdWUgQSB2YWx1ZSB0byBzZXQgZm9yIHRoZSBwcm9wZXJ0eVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd8Vm9pZH1cbiAqL1xuZnVuY3Rpb24gY3NzKGVsZW0sIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgZWxlbWVudHMgPSBnZXRFbGVtZW50cyhlbGVtKSxcbiAgICAgICAgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoLFxuICAgICAgICBzZXR0ZXI7XG5cbiAgICAvLyBHZXQgYXR0cmlidXRlXG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggPT09IDAgPyAnJyA6IGdldEVsU3R5bGUoZWxlbWVudHNbMF0sIGtleSk7XG4gICAgfVxuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXNcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgc2V0dGVyID0gZnVuY3Rpb24gc2V0dGVyKGVsKSB7XG4gICAgICAgICAgICBlbC5zdHlsZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoa2V5KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcihlbCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoa2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNldHRlcihlbGVtZW50c1tpXSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbFN0eWxlKGVsLCBwcm9wKSB7XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcbiAgICAgICAgLy8gSUVcbiAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHVybiBzdHlsZSBuYW1lIGludG8gY2FtZWwgbm90YXRpb25cbiAgICAgICAgICAgIHByb3AgPSBwcm9wLnJlcGxhY2UoL1xcLShcXHcpL2csIGZ1bmN0aW9uIChzdHIsICQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbC5jdXJyZW50U3R5bGVbcHJvcF07XG4gICAgICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudHMoZWwpIHtcbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbm9kZUxpc3RUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWwpKTtcbiAgICB9IGVsc2UgaWYgKC9eXFxbb2JqZWN0IChIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdHxPYmplY3QpXFxdJC8udGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWwpKSAmJiAodHlwZW9mIGVsLmxlbmd0aCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsLCAnbGVuZ3RoJykpICYmIGVsLmxlbmd0aCA+IDAgJiYgZWxbMF0ubm9kZVR5cGUgPiAwKSB7XG5cbiAgICAgICAgcmV0dXJuIG5vZGVMaXN0VG9BcnJheShlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtlbF07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub2RlTGlzdFRvQXJyYXkoZWxlbWVudHMpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aCxcbiAgICAgICAgYXJyID0gW107XG5cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyci5wdXNoKGVsZW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBwb3NpdGlvbnMgb2YgdGhlIHNjcm9sbCBiYXJzLlxuICpcbiAqIEBtZW1iZXJvZiB0aW55XG4gKiBAcmV0dXJucyB7e2xlZnQ6IChOdW1iZXIpLCB0b3A6IChOdW1iZXIpfX1cbiAqXG4gKiBAZXhhbXBsZVxuICogdGlueS5zY3JvbGwoKS50b3A7XG4gKi9cbmZ1bmN0aW9uIHNjcm9sbCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAnbGVmdCc6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCAwLFxuICAgICAgICAndG9wJzogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgMFxuICAgIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IG9mZnNldCBvZiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEEgZ2l2ZW4gSFRNTEVsZW1lbnQuXG4gKiBAcmV0dXJucyB7e2xlZnQ6IE51bWJlciwgdG9wOiBOdW1iZXJ9fVxuICpcbiAqIEBleGFtcGxlXG4gKiB0aW55Lm9mZnNldChlbCk7XG4gKi9cbmZ1bmN0aW9uIG9mZnNldChlbCkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGZpeGVkUGFyZW50ID0gZ2V0Rml4ZWRQYXJlbnQoZWwpLFxuICAgICAgICBjdXJyZW50U2Nyb2xsID0gc2Nyb2xsKCksXG4gICAgICAgIG9mZnNldCA9IHtcbiAgICAgICAgJ2xlZnQnOiByZWN0LmxlZnQsXG4gICAgICAgICd0b3AnOiByZWN0LnRvcFxuICAgIH07XG5cbiAgICBpZiAoY3NzKGVsLCAncG9zaXRpb24nKSAhPT0gJ2ZpeGVkJyAmJiBmaXhlZFBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICBvZmZzZXQubGVmdCArPSBjdXJyZW50U2Nyb2xsLmxlZnQ7XG4gICAgICAgIG9mZnNldC50b3AgKz0gY3VycmVudFNjcm9sbC50b3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgcGFyZW50Tm9kZSB3aXRoIHRoZSAnZml4ZWQnIHBvc2l0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBBIGdpdmVuIEhUTUxFbGVtZW50LlxuICpcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0Rml4ZWRQYXJlbnQoZWwpIHtcbiAgICB2YXIgY3VycmVudFBhcmVudCA9IGVsLm9mZnNldFBhcmVudCxcbiAgICAgICAgcGFyZW50ID0gdm9pZCAwO1xuXG4gICAgd2hpbGUgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjc3MoY3VycmVudFBhcmVudCwgJ3Bvc2l0aW9uJykgIT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50Lm9mZnNldFBhcmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50O1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgZXhwaXJlczogJycsIC8vIEVtcHR5IHN0cmluZyBmb3Igc2Vzc2lvbiBjb29raWVzXG4gICAgcGF0aDogJy8nLFxuICAgIHNlY3VyZTogZmFsc2UsXG4gICAgZG9tYWluOiAnJ1xufTtcblxudmFyIGRheSA9IDYwICogNjAgKiAyNDtcblxuZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBjb2xsZWN0aW9uID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7ICcpLFxuICAgICAgICB2YWx1ZSA9IG51bGwsXG4gICAgICAgIGwgPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgIGlmICghbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnRzID0gY29sbGVjdGlvbltpXS5zcGxpdCgnPScpLFxuICAgICAgICAgICAgX25hbWUzID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzLnNoaWZ0KCkpO1xuXG4gICAgICAgIGlmIChrZXkgPT09IF9uYW1lMykge1xuICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQocGFydHMuam9pbignPScpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBUaGVuIGBrZXlgIGNvbnRhaW5zIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBmb3IgY29va2llcywgYHZhbHVlYCBjb250YWlucyB0aGUgb3B0aW9ucyBvYmplY3QuXG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdGlvbnMpKSA9PT0gJ29iamVjdCcgPyBvcHRpb25zIDogeyBleHBpcmVzOiBvcHRpb25zIH07XG5cbiAgICB2YXIgZXhwaXJlcyA9IG9wdGlvbnMuZXhwaXJlcyAhPSBudWxsID8gb3B0aW9ucy5leHBpcmVzIDogZGVmYXVsdHMuZXhwaXJlcztcblxuICAgIGlmICh0eXBlb2YgZXhwaXJlcyA9PT0gJ3N0cmluZycgJiYgZXhwaXJlcyAhPT0gJycpIHtcbiAgICAgICAgZXhwaXJlcyA9IG5ldyBEYXRlKGV4cGlyZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cGlyZXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGV4cGlyZXMgPSBuZXcgRGF0ZSgrbmV3IERhdGUoKSArIDEwMDAgKiBkYXkgKiBleHBpcmVzKTtcbiAgICB9XG5cbiAgICBpZiAoZXhwaXJlcyAmJiAndG9HTVRTdHJpbmcnIGluIGV4cGlyZXMpIHtcbiAgICAgICAgZXhwaXJlcyA9ICc7ZXhwaXJlcz0nICsgZXhwaXJlcy50b0dNVFN0cmluZygpO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gJztwYXRoPScgKyAob3B0aW9ucy5wYXRoIHx8IGRlZmF1bHRzLnBhdGgpO1xuXG4gICAgdmFyIGRvbWFpbiA9IG9wdGlvbnMuZG9tYWluIHx8IGRlZmF1bHRzLmRvbWFpbjtcbiAgICBkb21haW4gPSBkb21haW4gPyAnO2RvbWFpbj0nICsgZG9tYWluIDogJyc7XG5cbiAgICB2YXIgc2VjdXJlID0gb3B0aW9ucy5zZWN1cmUgfHwgZGVmYXVsdHMuc2VjdXJlID8gJztzZWN1cmUnIDogJyc7XG5cbiAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRvY3VtZW50LmNvb2tpZSA9IGVuY29kZUNvb2tpZShrZXkpICsgJz0nICsgZW5jb2RlQ29va2llKHZhbHVlKSArIGV4cGlyZXMgKyBwYXRoICsgZG9tYWluICsgc2VjdXJlO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG4gICAgc2V0KGtleSwgJycsIC0xKTtcbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICAgIGlmIChuYXZpZ2F0b3IuY29va2llRW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzZXQoJ19fJywgJ18nKTtcbiAgICB2YXIgZXhpc3QgPSBnZXQoJ19fJykgPT09ICdfJztcbiAgICByZW1vdmUoJ19fJyk7XG5cbiAgICByZXR1cm4gZXhpc3Q7XG59XG5cbnZhciBjb29raWVzID0ge1xuICAgIGdldDogZ2V0LFxuICAgIHNldDogc2V0LFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIGlzRW5hYmxlZDogaXNFbmFibGVkXG59O1xuXG4vKlxuICogRXNjYXBlcyBvbmx5IGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGFsbG93ZWQgaW4gY29va2llc1xuICovXG5mdW5jdGlvbiBlbmNvZGVDb29raWUodmFsdWUpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKS5yZXBsYWNlKC9bLDtcIlxcXFw9XFxzJV0vZywgZnVuY3Rpb24gKGNoYXJhY3Rlcikge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGNoYXJhY3Rlcik7XG4gICAgfSk7XG59XG5cbnZhciBET01fRVZFTlRTID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBhdHRyIGluIGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChhdHRyLnN1YnN0cmluZygwLCAyKSA9PT0gJ29uJykge1xuICAgICAgICAgICAgdmFyIGV2dCA9IGF0dHIucmVwbGFjZSgnb24nLCAnJyk7XG4gICAgICAgICAgICBldmVudHMucHVzaChldnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG59KCk7XG5cbnZhciBNT1VTRV9FVkVOVFMgPSBET01fRVZFTlRTLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAoL14oPzpjbGlja3xkYmxjbGlja3xtb3VzZSg/OmRvd258dXB8b3Zlcnxtb3ZlfG91dCkpJC8udGVzdChuYW1lKVxuICAgICk7XG59KTtcblxudmFyIGlzU3RhbmRhcmQgPSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyID8gdHJ1ZSA6IGZhbHNlO1xuXG52YXIgYWRkSGFuZGxlciA9IGlzU3RhbmRhcmQgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAnYXR0YWNoRXZlbnQnO1xuXG52YXIgcmVtb3ZlSGFuZGxlciA9IGlzU3RhbmRhcmQgPyAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgOiAnZGV0YWNoRXZlbnQnO1xuXG52YXIgZGlzcGF0Y2ggPSBpc1N0YW5kYXJkID8gJ2Rpc3BhdGNoRXZlbnQnIDogJ2ZpcmVFdmVudCc7XG5cbmlmICghRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod2luZG93LkV2ZW50LnByb3RvdHlwZSwge1xuICAgICAgICBidWJibGVzOiB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbGFibGU6IHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcHBlZFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcHBlZEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRzJDEoZWwpIHtcbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbm9kZUxpc3RUb0FycmF5JDEoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbCkpO1xuICAgIH0gZWxzZSBpZiAoL15cXFtvYmplY3QgKEhUTUxDb2xsZWN0aW9ufE5vZGVMaXN0fE9iamVjdClcXF0kLy50ZXN0KE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbCkpICYmICh0eXBlb2YgZWwubGVuZ3RoID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWwsICdsZW5ndGgnKSkpIHtcbiAgICAgICAgaWYgKGVsLmxlbmd0aCA9PT0gMCB8fCBlbFswXS5ub2RlVHlwZSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlTGlzdFRvQXJyYXkkMShlbCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVsKSkge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2VsXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vZGVMaXN0VG9BcnJheSQxKGVsZW1lbnRzKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGgsXG4gICAgICAgIGFyciA9IFtdO1xuXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhcnIucHVzaChlbGVtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gaW5pdEV2ZW50KG5hbWUsIHByb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICBwcm9wcyA9IG5hbWU7XG4gICAgICAgIG5hbWUgPSBwcm9wcy50eXBlO1xuICAgIH1cbiAgICB2YXIgZXZlbnQgPSB2b2lkIDAsXG4gICAgICAgIGlzRG9tRXZlbnQgPSBET01fRVZFTlRTLmluZGV4T2YobmFtZSkgIT09IC0xLFxuICAgICAgICBpc01vdXNlRXZlbnQgPSBpc0RvbUV2ZW50ICYmIE1PVVNFX0VWRU5UUy5pbmRleE9mKG5hbWUpICE9PSAtMTtcblxuICAgIHZhciBkYXRhID0gZXh0ZW5kKHtcbiAgICAgICAgYnViYmxlczogaXNEb21FdmVudCxcbiAgICAgICAgY2FuY2VsYWJsZTogaXNEb21FdmVudCxcbiAgICAgICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgICB9LCBwcm9wcyk7XG5cbiAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChpc01vdXNlRXZlbnQgJiYgd2luZG93Lk1vdXNlRXZlbnQgPyAnTW91c2VFdmVudHMnIDogJ0V2ZW50cycpO1xuICAgICAgICBldmVudC5pbml0RXZlbnQobmFtZSwgZGF0YS5idWJibGVzLCBkYXRhLmNhbmNlbGFibGUsIGRhdGEuZGV0YWlsKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KSB7XG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3Qod2luZG93LmV2ZW50KTtcbiAgICAgICAgaWYgKGlzTW91c2VFdmVudCkge1xuICAgICAgICAgICAgZXZlbnQuYnV0dG9uID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEuYnViYmxlcykge1xuICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldmVudDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnROYW1lKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnN1YnN0cigwLCAyKSA9PT0gJ29uJykge1xuICAgICAgICByZXR1cm4gaXNTdGFuZGFyZCA/IGV2ZW50LnN1YnN0cigyKSA6IGV2ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc1N0YW5kYXJkID8gZXZlbnQgOiAnb24nICsgZXZlbnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIENyb3NzYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiB7SFRNTEVsZW1lbnR9LmFkZEV2ZW50TGlzdGVuZXIuXG4gKlxuICogQG1lbWJlcm9mIHRpbnlcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSBlbGVtIEFuIEhUTUxFbGVtZW50IG9yIGEgQ1NTIHNlbGVjdG9yIHRvIGFkZCBsaXN0ZW5lciB0b1xuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IEV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIFdoZXRoZXIgb3Igbm90IHRvIGJlIHByb3BhZ2F0ZWQgdG8gb3V0ZXIgZWxlbWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIHRpbnkub24oZG9jdW1lbnQsICdjbGljaycsIGZ1bmN0aW9uKGUpe30sIGZhbHNlKTtcbiAqXG4gKiB0aW55Lm9uKCdwID4gYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24oZSl7fSwgZmFsc2UpO1xuICovXG5mdW5jdGlvbiBvbihlbGVtLCBldmVudCwgaGFuZGxlciwgYnViYmxlcykge1xuICAgIGdldEVsZW1lbnRzJDEoZWxlbSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWxbYWRkSGFuZGxlcl0obm9ybWFsaXplRXZlbnROYW1lKGV2ZW50KSwgaGFuZGxlciwgYnViYmxlcyB8fCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQXR0YWNoIGEgaGFuZGxlciB0byBhbiBldmVudCBmb3IgdGhlIHtIVE1MRWxlbWVudH0gdGhhdCBleGVjdXRlcyBvbmx5XG4gKiBvbmNlLlxuICpcbiAqIEBtZW1iZXJvZiBjaC5FdmVudFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IGVsZW0gQW4gSFRNTEVsZW1lbnQgb3IgYSBDU1Mgc2VsZWN0b3IgdG8gYWRkIGxpc3RlbmVyIHRvXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgRXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJ1YmJsZXMgV2hldGhlciBvciBub3QgdG8gYmUgcHJvcGFnYXRlZCB0byBvdXRlciBlbGVtZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogdGlueS5vbmNlKGRvY3VtZW50LCAnY2xpY2snLCBmdW5jdGlvbihlKXt9LCBmYWxzZSk7XG4gKi9cbmZ1bmN0aW9uIG9uY2UoZWxlbSwgZXZlbnQsIF9oYW5kbGVyLCBidWJibGVzKSB7XG4gICAgZ2V0RWxlbWVudHMkMShlbGVtKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgb3JpZ0hhbmRsZXIgPSBfaGFuZGxlcjtcblxuICAgICAgICBfaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgb2ZmKGVsLCBlLnR5cGUsIF9oYW5kbGVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIG9yaWdIYW5kbGVyLmFwcGx5KGVsLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGVsW2FkZEhhbmRsZXJdKG5vcm1hbGl6ZUV2ZW50TmFtZShldmVudCksIF9oYW5kbGVyLCBidWJibGVzIHx8IGZhbHNlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDcm9zc2Jyb3dzZXIgaW1wbGVtZW50YXRpb24gb2Yge0hUTUxFbGVtZW50fS5yZW1vdmVFdmVudExpc3RlbmVyLlxuICpcbiAqIEBtZW1iZXJvZiBjaC5FdmVudFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IGVsZW0gQW4gSFRNTEVsZW1lbnQgb3IgYSBDU1Mgc2VsZWN0b3IgdG8gcmVtb3ZlIGxpc3RlbmVyIGZyb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBFdmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gdG8gcmVtb3ZlXG4gKlxuICogQGV4YW1wbGVcbiAqIHRpbnkub2ZmKGRvY3VtZW50LCAnY2xpY2snLCBmbik7XG4gKi9cbmZ1bmN0aW9uIG9mZihlbGVtLCBldmVudCwgaGFuZGxlcikge1xuICAgIGdldEVsZW1lbnRzJDEoZWxlbSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWxbcmVtb3ZlSGFuZGxlcl0obm9ybWFsaXplRXZlbnROYW1lKGV2ZW50KSwgaGFuZGxlcik7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ3Jvc3Nicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIHtIVE1MRWxlbWVudH0ucmVtb3ZlRXZlbnRMaXN0ZW5lci5cbiAqXG4gKiBAbWVtYmVyb2YgdGlueVxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbSBBbiBIVE1MRWxlbWVudCBvciBhIENTUyBzZWxlY3RvciB0byBkaXNwYXRjaCBldmVudCB0b1xuICogQHBhcmFtIHtTdHJpbmd8RXZlbnR9IGV2ZW50IEV2ZW50IG5hbWUgb3IgYW4gZXZlbnQgb2JqZWN0XG4gKlxuICogQGV4YW1wbGVcbiAqIHRpbnkudHJpZ2dlcignLmJ0bicsICdjbGljaycpO1xuICovXG5mdW5jdGlvbiB0cmlnZ2VyKGVsZW0sIGV2ZW50LCBwcm9wcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycgPyBldmVudCA6IGV2ZW50LnR5cGU7XG4gICAgZXZlbnQgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnIHx8IGlzUGxhaW5PYmplY3QoZXZlbnQpID8gaW5pdEV2ZW50KGV2ZW50LCBwcm9wcykgOiBldmVudDtcblxuICAgIGdldEVsZW1lbnRzJDEoZWxlbSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgLy8gaGFuZGxlIGZvY3VzKCksIGJsdXIoKSBieSBjYWxsaW5nIHRoZW0gZGlyZWN0bHlcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgaW4gZm9jdXMgJiYgdHlwZW9mIF90aGlzW2V2ZW50LnR5cGVdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF90aGlzW2V2ZW50LnR5cGVdKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc1N0YW5kYXJkID8gZWxbZGlzcGF0Y2hdKGV2ZW50KSA6IGVsW2Rpc3BhdGNoXShub3JtYWxpemVFdmVudE5hbWUobmFtZSksIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG52YXIgRE9NRXZlbnRzID0ge1xuICAgIG9uOiBvbixcbiAgICBvbmNlOiBvbmNlLFxuICAgIG9mZjogb2ZmLFxuICAgIHRyaWdnZXI6IHRyaWdnZXJcbn07XG5cbi8qKlxuICogUG9seWZpbGwgZm9yIHN1cHBvcnRpbmcgcG9pbnRlciBldmVudHMgb24gZXZlcnkgYnJvd3NlclxuICpcbiAqIEBzZWUgQmFzZWQgb246IDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZGVsdGFrb3NoL2hhbmRqc1wiIHRhcmdldD1cIl9ibGFua1wiPkhhbmQuanM8L2E+XG4gKi9cbihmdW5jdGlvbiAod2luZG93KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFBPSU5URVJfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG4gICAgdmFyIFBPSU5URVJfVFlQRV9QRU4gPSAncGVuJztcbiAgICB2YXIgUE9JTlRFUl9UWVBFX01PVVNFID0gJ21vdXNlJztcblxuICAgIC8vIElmIHRoZSB1c2VyIGFnZW50IGFscmVhZHkgc3VwcG9ydHMgUG9pbnRlciBFdmVudHMsIGRvIG5vdGhpbmdcbiAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRHVlIHRvIHBvbHlmaWxsIElFOCBjYW4gaGFzIGRvY3VtZW50LmNyZWF0ZUV2ZW50IGJ1dCBpdCBoYXMgbm8gc3VwcG9ydCBmb3JcbiAgICAvLyBjdXN0b20gTW91c2UgRXZlbnRzXG4gICAgdmFyIHN1cHBvcnRzTW91c2VFdmVudHMgPSAhIXdpbmRvdy5Nb3VzZUV2ZW50O1xuXG4gICAgaWYgKCFzdXBwb3J0c01vdXNlRXZlbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgbGlzdCBvZiBzdGFuZGFyZGl6ZWQgcG9pbnRlciBldmVudHMgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy9cbiAgICB2YXIgdXBwZXJDYXNlRXZlbnRzTmFtZXMgPSBbJ1BvaW50ZXJEb3duJywgJ1BvaW50ZXJVcCcsICdQb2ludGVyTW92ZScsICdQb2ludGVyT3ZlcicsICdQb2ludGVyT3V0JywgJ1BvaW50ZXJDYW5jZWwnLCAnUG9pbnRlckVudGVyJywgJ1BvaW50ZXJMZWF2ZSddO1xuICAgIHZhciBzdXBwb3J0ZWRFdmVudHNOYW1lcyA9IHVwcGVyQ2FzZUV2ZW50c05hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgdmFyIHByZXZpb3VzVGFyZ2V0cyA9IHt9O1xuXG4gICAgdmFyIGNoZWNrUHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBjaGVja1ByZXZlbnREZWZhdWx0KG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgIW5vZGUuY2hfZm9yY2VQcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFub2RlIHx8IHdpbmRvdy5jaF9mb3JjZVByZXZlbnREZWZhdWx0O1xuICAgIH07XG5cbiAgICAvLyBUb3VjaCBldmVudHNcbiAgICB2YXIgZ2VuZXJhdGVUb3VjaENsb25lZEV2ZW50ID0gZnVuY3Rpb24gZ2VuZXJhdGVUb3VjaENsb25lZEV2ZW50KHNvdXJjZUV2ZW50LCBuZXdOYW1lLCBjYW5CdWJibGUsIHRhcmdldCwgcmVsYXRlZFRhcmdldCkge1xuICAgICAgICAvLyBDb25zaWRlcmluZyB0b3VjaCBldmVudHMgYXJlIGFsbW9zdCBsaWtlIHN1cGVyIG1vdXNlIGV2ZW50c1xuICAgICAgICB2YXIgZXZPYmo7XG5cbiAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50ICYmIHN1cHBvcnRzTW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgIGV2T2JqID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlICdpbml0TW91c2VFdmVudCcgd2l0aCAnbmV3IE1vdXNlRXZlbnQnXG4gICAgICAgICAgICBldk9iai5pbml0TW91c2VFdmVudChuZXdOYW1lLCBjYW5CdWJibGUsIHRydWUsIHdpbmRvdywgMSwgc291cmNlRXZlbnQuc2NyZWVuWCwgc291cmNlRXZlbnQuc2NyZWVuWSwgc291cmNlRXZlbnQuY2xpZW50WCwgc291cmNlRXZlbnQuY2xpZW50WSwgc291cmNlRXZlbnQuY3RybEtleSwgc291cmNlRXZlbnQuYWx0S2V5LCBzb3VyY2VFdmVudC5zaGlmdEtleSwgc291cmNlRXZlbnQubWV0YUtleSwgc291cmNlRXZlbnQuYnV0dG9uLCByZWxhdGVkVGFyZ2V0IHx8IHNvdXJjZUV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZPYmogPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuICAgICAgICAgICAgZXZPYmouc2NyZWVuWCA9IHNvdXJjZUV2ZW50LnNjcmVlblg7XG4gICAgICAgICAgICBldk9iai5zY3JlZW5ZID0gc291cmNlRXZlbnQuc2NyZWVuWTtcbiAgICAgICAgICAgIGV2T2JqLmNsaWVudFggPSBzb3VyY2VFdmVudC5jbGllbnRYO1xuICAgICAgICAgICAgZXZPYmouY2xpZW50WSA9IHNvdXJjZUV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICBldk9iai5jdHJsS2V5ID0gc291cmNlRXZlbnQuY3RybEtleTtcbiAgICAgICAgICAgIGV2T2JqLmFsdEtleSA9IHNvdXJjZUV2ZW50LmFsdEtleTtcbiAgICAgICAgICAgIGV2T2JqLnNoaWZ0S2V5ID0gc291cmNlRXZlbnQuc2hpZnRLZXk7XG4gICAgICAgICAgICBldk9iai5tZXRhS2V5ID0gc291cmNlRXZlbnQubWV0YUtleTtcbiAgICAgICAgICAgIGV2T2JqLmJ1dHRvbiA9IHNvdXJjZUV2ZW50LmJ1dHRvbjtcbiAgICAgICAgICAgIGV2T2JqLnJlbGF0ZWRUYXJnZXQgPSByZWxhdGVkVGFyZ2V0IHx8IHNvdXJjZUV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2Zmc2V0c1xuICAgICAgICBpZiAoZXZPYmoub2Zmc2V0WCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlRXZlbnQub2Zmc2V0WCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgT3BlcmEgd2hpY2ggY3JlYXRlcyByZWFkb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdCAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZPYmosICdvZmZzZXRYJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldk9iaiwgJ29mZnNldFknLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBldk9iai5vZmZzZXRYID0gc291cmNlRXZlbnQub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICBldk9iai5vZmZzZXRZID0gc291cmNlRXZlbnQub2Zmc2V0WTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2T2JqLCAnb2Zmc2V0WCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VGFyZ2V0ICYmIHRoaXMuY3VycmVudFRhcmdldC5vZmZzZXRMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUV2ZW50LmNsaWVudFggLSB0aGlzLmN1cnJlbnRUYXJnZXQub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VFdmVudC5jbGllbnRYO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2T2JqLCAnb2Zmc2V0WScsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VGFyZ2V0ICYmIHRoaXMuY3VycmVudFRhcmdldC5vZmZzZXRUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlRXZlbnQuY2xpZW50WSAtIHRoaXMuY3VycmVudFRhcmdldC5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlRXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VFdmVudC5sYXllclggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV2T2JqLm9mZnNldFggPSBzb3VyY2VFdmVudC5sYXllclggLSBzb3VyY2VFdmVudC5jdXJyZW50VGFyZ2V0Lm9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgZXZPYmoub2Zmc2V0WSA9IHNvdXJjZUV2ZW50LmxheWVyWSAtIHNvdXJjZUV2ZW50LmN1cnJlbnRUYXJnZXQub2Zmc2V0VG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkaW5nIG1pc3NpbmcgcHJvcGVydGllc1xuXG4gICAgICAgIGlmIChzb3VyY2VFdmVudC5pc1ByaW1hcnkgIT09IHVuZGVmaW5lZCkgZXZPYmouaXNQcmltYXJ5ID0gc291cmNlRXZlbnQuaXNQcmltYXJ5O2Vsc2UgZXZPYmouaXNQcmltYXJ5ID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc291cmNlRXZlbnQucHJlc3N1cmUpIGV2T2JqLnByZXNzdXJlID0gc291cmNlRXZlbnQucHJlc3N1cmU7ZWxzZSB7XG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gMDtcblxuICAgICAgICAgICAgaWYgKHNvdXJjZUV2ZW50LndoaWNoICE9PSB1bmRlZmluZWQpIGJ1dHRvbiA9IHNvdXJjZUV2ZW50LndoaWNoO2Vsc2UgaWYgKHNvdXJjZUV2ZW50LmJ1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uID0gc291cmNlRXZlbnQuYnV0dG9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZPYmoucHJlc3N1cmUgPSBidXR0b24gPT09IDAgPyAwIDogMC41O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZUV2ZW50LnJvdGF0aW9uKSBldk9iai5yb3RhdGlvbiA9IHNvdXJjZUV2ZW50LnJvdGF0aW9uO2Vsc2UgZXZPYmoucm90YXRpb24gPSAwO1xuXG4gICAgICAgIC8vIFRpbWVzdGFtcFxuICAgICAgICBpZiAoc291cmNlRXZlbnQuaHdUaW1lc3RhbXApIGV2T2JqLmh3VGltZXN0YW1wID0gc291cmNlRXZlbnQuaHdUaW1lc3RhbXA7ZWxzZSBldk9iai5od1RpbWVzdGFtcCA9IDA7XG5cbiAgICAgICAgLy8gVGlsdHNcbiAgICAgICAgaWYgKHNvdXJjZUV2ZW50LnRpbHRYKSBldk9iai50aWx0WCA9IHNvdXJjZUV2ZW50LnRpbHRYO2Vsc2UgZXZPYmoudGlsdFggPSAwO1xuXG4gICAgICAgIGlmIChzb3VyY2VFdmVudC50aWx0WSkgZXZPYmoudGlsdFkgPSBzb3VyY2VFdmVudC50aWx0WTtlbHNlIGV2T2JqLnRpbHRZID0gMDtcblxuICAgICAgICAvLyBXaWR0aCBhbmQgSGVpZ2h0XG4gICAgICAgIGlmIChzb3VyY2VFdmVudC5oZWlnaHQpIGV2T2JqLmhlaWdodCA9IHNvdXJjZUV2ZW50LmhlaWdodDtlbHNlIGV2T2JqLmhlaWdodCA9IDA7XG5cbiAgICAgICAgaWYgKHNvdXJjZUV2ZW50LndpZHRoKSBldk9iai53aWR0aCA9IHNvdXJjZUV2ZW50LndpZHRoO2Vsc2UgZXZPYmoud2lkdGggPSAwO1xuXG4gICAgICAgIC8vIHByZXZlbnREZWZhdWx0XG4gICAgICAgIGV2T2JqLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZUV2ZW50LnByZXZlbnREZWZhdWx0ICE9PSB1bmRlZmluZWQpIHNvdXJjZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3RvcFByb3BhZ2F0aW9uXG4gICAgICAgIGlmIChldk9iai5zdG9wUHJvcGFnYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBldk9iai5zdG9wUHJvcGFnYXRpb247XG4gICAgICAgICAgICBldk9iai5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbiAhPT0gdW5kZWZpbmVkKSBzb3VyY2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9pbnRlciB2YWx1ZXNcbiAgICAgICAgZXZPYmoucG9pbnRlcklkID0gc291cmNlRXZlbnQucG9pbnRlcklkO1xuICAgICAgICBldk9iai5wb2ludGVyVHlwZSA9IHNvdXJjZUV2ZW50LnBvaW50ZXJUeXBlO1xuXG4gICAgICAgIHN3aXRjaCAoZXZPYmoucG9pbnRlclR5cGUpIHsvLyBPbGQgc3BlYyB2ZXJzaW9uIGNoZWNrXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZXZPYmoucG9pbnRlclR5cGUgPSBQT0lOVEVSX1RZUEVfVE9VQ0g7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgZXZPYmoucG9pbnRlclR5cGUgPSBQT0lOVEVSX1RZUEVfUEVOO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGV2T2JqLnBvaW50ZXJUeXBlID0gUE9JTlRFUl9UWVBFX01PVVNFO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyZSBldmVudFxuICAgICAgICBpZiAodGFyZ2V0KSB0YXJnZXQuZGlzcGF0Y2hFdmVudChldk9iaik7ZWxzZSBpZiAoc291cmNlRXZlbnQudGFyZ2V0ICYmIHN1cHBvcnRzTW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgIHNvdXJjZUV2ZW50LnRhcmdldC5kaXNwYXRjaEV2ZW50KGV2T2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZUV2ZW50LnNyY0VsZW1lbnQuZmlyZUV2ZW50KCdvbicgKyBnZXRNb3VzZUVxdWl2YWxlbnRFdmVudE5hbWUobmV3TmFtZSksIGV2T2JqKTsgLy8gV2UgbXVzdCBmYWxsYmFjayB0byBtb3VzZSBldmVudCBmb3IgdmVyeSBvbGQgYnJvd3NlcnNcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZ2VuZXJhdGVNb3VzZVByb3h5ID0gZnVuY3Rpb24gZ2VuZXJhdGVNb3VzZVByb3h5KGV2dCwgZXZlbnROYW1lLCBjYW5CdWJibGUsIHRhcmdldCwgcmVsYXRlZFRhcmdldCkge1xuICAgICAgICBldnQucG9pbnRlcklkID0gMTtcbiAgICAgICAgZXZ0LnBvaW50ZXJUeXBlID0gUE9JTlRFUl9UWVBFX01PVVNFO1xuICAgICAgICBnZW5lcmF0ZVRvdWNoQ2xvbmVkRXZlbnQoZXZ0LCBldmVudE5hbWUsIGNhbkJ1YmJsZSwgdGFyZ2V0LCByZWxhdGVkVGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgdmFyIGdlbmVyYXRlVG91Y2hFdmVudFByb3h5ID0gZnVuY3Rpb24gZ2VuZXJhdGVUb3VjaEV2ZW50UHJveHkobmFtZSwgdG91Y2hQb2ludCwgdGFyZ2V0LCBldmVudE9iamVjdCwgY2FuQnViYmxlLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgIHZhciB0b3VjaFBvaW50SWQgPSB0b3VjaFBvaW50LmlkZW50aWZpZXIgKyAyOyAvLyBKdXN0IHRvIG5vdCBvdmVycmlkZSBtb3VzZSBpZFxuXG4gICAgICAgIHRvdWNoUG9pbnQucG9pbnRlcklkID0gdG91Y2hQb2ludElkO1xuICAgICAgICB0b3VjaFBvaW50LnBvaW50ZXJUeXBlID0gUE9JTlRFUl9UWVBFX1RPVUNIO1xuICAgICAgICB0b3VjaFBvaW50LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgaWYgKGV2ZW50T2JqZWN0LnByZXZlbnREZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvdWNoUG9pbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRPYmplY3QucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBnZW5lcmF0ZVRvdWNoQ2xvbmVkRXZlbnQodG91Y2hQb2ludCwgbmFtZSwgY2FuQnViYmxlLCB0YXJnZXQsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIH07XG5cbiAgICB2YXIgY2hlY2tFdmVudFJlZ2lzdHJhdGlvbiA9IGZ1bmN0aW9uIGNoZWNrRXZlbnRSZWdpc3RyYXRpb24obm9kZSwgZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBub2RlLl9fY2hHbG9iYWxSZWdpc3RlcmVkRXZlbnRzICYmIG5vZGUuX19jaEdsb2JhbFJlZ2lzdGVyZWRFdmVudHNbZXZlbnROYW1lXTtcbiAgICB9O1xuICAgIHZhciBmaW5kRXZlbnRSZWdpc3RlcmVkTm9kZSA9IGZ1bmN0aW9uIGZpbmRFdmVudFJlZ2lzdGVyZWROb2RlKG5vZGUsIGV2ZW50TmFtZSkge1xuICAgICAgICB3aGlsZSAobm9kZSAmJiAhY2hlY2tFdmVudFJlZ2lzdHJhdGlvbihub2RlLCBldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9aWYgKG5vZGUpIHJldHVybiBub2RlO2Vsc2UgaWYgKGNoZWNrRXZlbnRSZWdpc3RyYXRpb24od2luZG93LCBldmVudE5hbWUpKSByZXR1cm4gd2luZG93O1xuICAgIH07XG5cbiAgICB2YXIgZ2VuZXJhdGVUb3VjaEV2ZW50UHJveHlJZlJlZ2lzdGVyZWQgPSBmdW5jdGlvbiBnZW5lcmF0ZVRvdWNoRXZlbnRQcm94eUlmUmVnaXN0ZXJlZChldmVudE5hbWUsIHRvdWNoUG9pbnQsIHRhcmdldCwgZXZlbnRPYmplY3QsIGNhbkJ1YmJsZSwgcmVsYXRlZFRhcmdldCkge1xuICAgICAgICAvLyBDaGVjayBpZiB1c2VyIHJlZ2lzdGVyZWQgdGhpcyBldmVudFxuICAgICAgICBpZiAoZmluZEV2ZW50UmVnaXN0ZXJlZE5vZGUodGFyZ2V0LCBldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBnZW5lcmF0ZVRvdWNoRXZlbnRQcm94eShldmVudE5hbWUsIHRvdWNoUG9pbnQsIHRhcmdldCwgZXZlbnRPYmplY3QsIGNhbkJ1YmJsZSwgcmVsYXRlZFRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldE1vdXNlRXF1aXZhbGVudEV2ZW50TmFtZSA9IGZ1bmN0aW9uIGdldE1vdXNlRXF1aXZhbGVudEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ3BvaW50ZXInLCAnbW91c2UnKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFByZWZpeEV2ZW50TmFtZSA9IGZ1bmN0aW9uIGdldFByZWZpeEV2ZW50TmFtZShwcmVmaXgsIGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgdXBwZXJDYXNlSW5kZXggPSBzdXBwb3J0ZWRFdmVudHNOYW1lcy5pbmRleE9mKGV2ZW50TmFtZSk7XG4gICAgICAgIHZhciBuZXdFdmVudE5hbWUgPSBwcmVmaXggKyB1cHBlckNhc2VFdmVudHNOYW1lc1t1cHBlckNhc2VJbmRleF07XG5cbiAgICAgICAgcmV0dXJuIG5ld0V2ZW50TmFtZTtcbiAgICB9O1xuXG4gICAgdmFyIHJlZ2lzdGVyT3JVbnJlZ2lzdGVyRXZlbnQgPSBmdW5jdGlvbiByZWdpc3Rlck9yVW5yZWdpc3RlckV2ZW50KGl0ZW0sIG5hbWUsIGZ1bmMsIGVuYWJsZSkge1xuICAgICAgICBpZiAoaXRlbS5fX2NoUmVnaXN0ZXJlZEV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdGVtLl9fY2hSZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5hYmxlKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5fX2NoUmVnaXN0ZXJlZEV2ZW50c1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5fX2NoUmVnaXN0ZXJlZEV2ZW50c1tuYW1lXSsrO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5fX2NoUmVnaXN0ZXJlZEV2ZW50c1tuYW1lXSA9IDE7XG4gICAgICAgICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuYywgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5fX2NoUmVnaXN0ZXJlZEV2ZW50cy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uX19jaFJlZ2lzdGVyZWRFdmVudHNbbmFtZV0tLTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLl9fY2hSZWdpc3RlcmVkRXZlbnRzW25hbWVdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZnVuYyk7XG4gICAgICAgICAgICBpdGVtLl9fY2hSZWdpc3RlcmVkRXZlbnRzW25hbWVdID0gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2V0VG91Y2hBd2FyZSA9IGZ1bmN0aW9uIHNldFRvdWNoQXdhcmUoaXRlbSwgZXZlbnROYW1lLCBlbmFibGUpIHtcbiAgICAgICAgLy8gTGVhdmluZyB0b2tlbnNcbiAgICAgICAgaWYgKCFpdGVtLl9fY2hHbG9iYWxSZWdpc3RlcmVkRXZlbnRzKSB7XG4gICAgICAgICAgICBpdGVtLl9fY2hHbG9iYWxSZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYWJsZSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uX19jaEdsb2JhbFJlZ2lzdGVyZWRFdmVudHNbZXZlbnROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5fX2NoR2xvYmFsUmVnaXN0ZXJlZEV2ZW50c1tldmVudE5hbWVdKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5fX2NoR2xvYmFsUmVnaXN0ZXJlZEV2ZW50c1tldmVudE5hbWVdID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpdGVtLl9fY2hHbG9iYWxSZWdpc3RlcmVkRXZlbnRzW2V2ZW50TmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uX19jaEdsb2JhbFJlZ2lzdGVyZWRFdmVudHNbZXZlbnROYW1lXS0tO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLl9fY2hHbG9iYWxSZWdpc3RlcmVkRXZlbnRzW2V2ZW50TmFtZV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uX19jaEdsb2JhbFJlZ2lzdGVyZWRFdmVudHNbZXZlbnROYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWVHZW5lcmF0b3I7XG4gICAgICAgIHZhciBldmVudEdlbmVyYXRvcjtcbiAgICAgICAgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xuICAgICAgICAgICAgbmFtZUdlbmVyYXRvciA9IGZ1bmN0aW9uIG5hbWVHZW5lcmF0b3IobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcmVmaXhFdmVudE5hbWUoJ01TJywgbmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnRHZW5lcmF0b3IgPSBnZW5lcmF0ZVRvdWNoQ2xvbmVkRXZlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lR2VuZXJhdG9yID0gZ2V0TW91c2VFcXVpdmFsZW50RXZlbnROYW1lO1xuICAgICAgICAgICAgZXZlbnRHZW5lcmF0b3IgPSBnZW5lcmF0ZU1vdXNlUHJveHk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BvaW50ZXJlbnRlcic6XG4gICAgICAgICAgICBjYXNlICdwb2ludGVybGVhdmUnOlxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRFdmVudCA9IG5hbWVHZW5lcmF0b3IoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVsnb24nICsgdGFyZ2V0RXZlbnQudG9Mb3dlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3Rlck9yVW5yZWdpc3RlckV2ZW50KGl0ZW0sIHRhcmdldEV2ZW50LCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEdlbmVyYXRvcihldnQsIGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGVuYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEludGVyY2VwdCBhZGRFdmVudExpc3RlbmVyIGNhbGxzIGJ5IGNoYW5naW5nIHRoZSBwcm90b3R5cGVcbiAgICB2YXIgaW50ZXJjZXB0QWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGludGVyY2VwdEFkZEV2ZW50TGlzdGVuZXIocm9vdCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHJvb3QucHJvdG90eXBlID8gcm9vdC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA6IHJvb3QuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICAgICAgICB2YXIgY3VzdG9tQWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGN1c3RvbUFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuYywgY2FwdHVyZSkge1xuICAgICAgICAgICAgLy8gQnJhbmNoIHdoZW4gYSBQb2ludGVyWFhYIGlzIHVzZWRcbiAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRFdmVudHNOYW1lcy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHNldFRvdWNoQXdhcmUodGhpcywgbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaEV2ZW50KCdvbicgKyBnZXRNb3VzZUVxdWl2YWxlbnRFdmVudE5hbWUobmFtZSksIGZ1bmMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmNhbGwodGhpcywgbmFtZSwgZnVuYywgY2FwdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJvb3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgICByb290LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gY3VzdG9tQWRkRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lciA9IGN1c3RvbUFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW50ZXJjZXB0IHJlbW92ZUV2ZW50TGlzdGVuZXIgY2FsbHMgYnkgY2hhbmdpbmcgdGhlIHByb3RvdHlwZVxuICAgIHZhciBpbnRlcmNlcHRSZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gaW50ZXJjZXB0UmVtb3ZlRXZlbnRMaXN0ZW5lcihyb290KSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcm9vdC5wcm90b3R5cGUgPyByb290LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyIDogcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG4gICAgICAgIHZhciBjdXN0b21SZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gY3VzdG9tUmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jLCBjYXB0dXJlKSB7XG4gICAgICAgICAgICAvLyBSZWxlYXNlIHdoZW4gYSBQb2ludGVyWFhYIGlzIHVzZWRcbiAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRFdmVudHNOYW1lcy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHNldFRvdWNoQXdhcmUodGhpcywgbmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hFdmVudChnZXRNb3VzZUVxdWl2YWxlbnRFdmVudE5hbWUobmFtZSksIGZ1bmMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmNhbGwodGhpcywgbmFtZSwgZnVuYywgY2FwdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChyb290LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgcm9vdC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGN1c3RvbVJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBjdXN0b21SZW1vdmVFdmVudExpc3RlbmVyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEhvb2tzXG4gICAgaW50ZXJjZXB0QWRkRXZlbnRMaXN0ZW5lcih3aW5kb3cpO1xuICAgIGludGVyY2VwdEFkZEV2ZW50TGlzdGVuZXIod2luZG93LkhUTUxFbGVtZW50IHx8IHdpbmRvdy5FbGVtZW50KTtcbiAgICBpbnRlcmNlcHRBZGRFdmVudExpc3RlbmVyKGRvY3VtZW50KTtcbiAgICBpbnRlcmNlcHRBZGRFdmVudExpc3RlbmVyKEhUTUxCb2R5RWxlbWVudCk7XG4gICAgaW50ZXJjZXB0QWRkRXZlbnRMaXN0ZW5lcihIVE1MRGl2RWxlbWVudCk7XG4gICAgaW50ZXJjZXB0QWRkRXZlbnRMaXN0ZW5lcihIVE1MSW1hZ2VFbGVtZW50KTtcbiAgICBpbnRlcmNlcHRBZGRFdmVudExpc3RlbmVyKEhUTUxVTGlzdEVsZW1lbnQpO1xuICAgIGludGVyY2VwdEFkZEV2ZW50TGlzdGVuZXIoSFRNTEFuY2hvckVsZW1lbnQpO1xuICAgIGludGVyY2VwdEFkZEV2ZW50TGlzdGVuZXIoSFRNTExJRWxlbWVudCk7XG4gICAgaW50ZXJjZXB0QWRkRXZlbnRMaXN0ZW5lcihIVE1MVGFibGVFbGVtZW50KTtcbiAgICBpZiAod2luZG93LkhUTUxTcGFuRWxlbWVudCkge1xuICAgICAgICBpbnRlcmNlcHRBZGRFdmVudExpc3RlbmVyKEhUTUxTcGFuRWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgaW50ZXJjZXB0QWRkRXZlbnRMaXN0ZW5lcihIVE1MQ2FudmFzRWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh3aW5kb3cuU1ZHRWxlbWVudCkge1xuICAgICAgICBpbnRlcmNlcHRBZGRFdmVudExpc3RlbmVyKFNWR0VsZW1lbnQpO1xuICAgIH1cblxuICAgIGludGVyY2VwdFJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93KTtcbiAgICBpbnRlcmNlcHRSZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdy5IVE1MRWxlbWVudCB8fCB3aW5kb3cuRWxlbWVudCk7XG4gICAgaW50ZXJjZXB0UmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCk7XG4gICAgaW50ZXJjZXB0UmVtb3ZlRXZlbnRMaXN0ZW5lcihIVE1MQm9keUVsZW1lbnQpO1xuICAgIGludGVyY2VwdFJlbW92ZUV2ZW50TGlzdGVuZXIoSFRNTERpdkVsZW1lbnQpO1xuICAgIGludGVyY2VwdFJlbW92ZUV2ZW50TGlzdGVuZXIoSFRNTEltYWdlRWxlbWVudCk7XG4gICAgaW50ZXJjZXB0UmVtb3ZlRXZlbnRMaXN0ZW5lcihIVE1MVUxpc3RFbGVtZW50KTtcbiAgICBpbnRlcmNlcHRSZW1vdmVFdmVudExpc3RlbmVyKEhUTUxBbmNob3JFbGVtZW50KTtcbiAgICBpbnRlcmNlcHRSZW1vdmVFdmVudExpc3RlbmVyKEhUTUxMSUVsZW1lbnQpO1xuICAgIGludGVyY2VwdFJlbW92ZUV2ZW50TGlzdGVuZXIoSFRNTFRhYmxlRWxlbWVudCk7XG4gICAgaWYgKHdpbmRvdy5IVE1MU3BhbkVsZW1lbnQpIHtcbiAgICAgICAgaW50ZXJjZXB0UmVtb3ZlRXZlbnRMaXN0ZW5lcihIVE1MU3BhbkVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAod2luZG93LkhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgIGludGVyY2VwdFJlbW92ZUV2ZW50TGlzdGVuZXIoSFRNTENhbnZhc0VsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAod2luZG93LlNWR0VsZW1lbnQpIHtcbiAgICAgICAgaW50ZXJjZXB0UmVtb3ZlRXZlbnRMaXN0ZW5lcihTVkdFbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCBhZnRlciBUb3VjaCBFdmVudHMgYWN0aW9uXG4gICAgdmFyIHRvdWNoaW5nID0gZmFsc2U7XG4gICAgdmFyIHRvdWNoVGltZXIgPSAtMTtcblxuICAgIGZ1bmN0aW9uIHNldFRvdWNoVGltZXIoKSB7XG4gICAgICAgIHRvdWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRvdWNoVGltZXIpO1xuICAgICAgICB0b3VjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0b3VjaGluZyA9IGZhbHNlO1xuICAgICAgICB9LCA3MDApO1xuICAgICAgICAvLyAxLiBNb2JpbGUgYnJvd3NlcnMgZGlzcGF0Y2ggbW91c2UgZXZlbnRzIDMwMG1zIGFmdGVyIHRvdWNoZW5kXG4gICAgICAgIC8vIDIuIENocm9tZSBmb3IgQW5kcm9pZCBkaXNwYXRjaCBtb3VzZWRvd24gZm9yIGxvbmctdG91Y2ggYWJvdXQgNjUwbXNcbiAgICAgICAgLy8gUmVzdWx0OiBCbG9ja2luZyBNb3VzZSBFdmVudHMgZm9yIDcwMG1zLlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEZpcnN0Q29tbW9uTm9kZSh4LCB5KSB7XG4gICAgICAgIHdoaWxlICh4KSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IHguY29udGFpbnMgJiYgeC5jb250YWlucyh5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCA9IHgucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vZ2VuZXJhdGVQcm94eSByZWNlaXZlcyBhIG5vZGUgdG8gZGlzcGF0Y2ggdGhlIGV2ZW50XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hQb2ludGVyRW50ZXIoY3VycmVudFRhcmdldCwgcmVsYXRlZFRhcmdldCwgZ2VuZXJhdGVQcm94eSkge1xuICAgICAgICB2YXIgY29tbW9uUGFyZW50ID0gZ2V0Rmlyc3RDb21tb25Ob2RlKGN1cnJlbnRUYXJnZXQsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB2YXIgbm9kZSA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHZhciBub2RlbGlzdCA9IFtdO1xuICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBjb21tb25QYXJlbnQpIHtcbiAgICAgICAgICAgIC8vdGFyZ2V0IHJhbmdlOiB0aGlzIHRvIHRoZSBkaXJlY3QgY2hpbGQgb2YgcGFyZW50IHJlbGF0ZWRUYXJnZXRcbiAgICAgICAgICAgIGlmIChjaGVja0V2ZW50UmVnaXN0cmF0aW9uKG5vZGUsICdwb2ludGVyZW50ZXInKSkgLy9jaGVjayBpZiBhbnkgcGFyZW50IG5vZGUgaGFzIHBvaW50ZXJlbnRlclxuICAgICAgICAgICAgICAgIG5vZGVsaXN0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChub2RlbGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZW5lcmF0ZVByb3h5KG5vZGVsaXN0LnBvcCgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vZ2VuZXJhdGVQcm94eSByZWNlaXZlcyBhIG5vZGUgdG8gZGlzcGF0Y2ggdGhlIGV2ZW50XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hQb2ludGVyTGVhdmUoY3VycmVudFRhcmdldCwgcmVsYXRlZFRhcmdldCwgZ2VuZXJhdGVQcm94eSkge1xuICAgICAgICB2YXIgY29tbW9uUGFyZW50ID0gZ2V0Rmlyc3RDb21tb25Ob2RlKGN1cnJlbnRUYXJnZXQsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB2YXIgbm9kZSA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IGNvbW1vblBhcmVudCkge1xuICAgICAgICAgICAgLy90YXJnZXQgcmFuZ2U6IHRoaXMgdG8gdGhlIGRpcmVjdCBjaGlsZCBvZiBwYXJlbnQgcmVsYXRlZFRhcmdldFxuICAgICAgICAgICAgaWYgKGNoZWNrRXZlbnRSZWdpc3RyYXRpb24obm9kZSwgJ3BvaW50ZXJsZWF2ZScpKSAvL2NoZWNrIGlmIGFueSBwYXJlbnQgbm9kZSBoYXMgcG9pbnRlcmxlYXZlXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVQcm94eShub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGluZyBldmVudHMgb24gd2luZG93IHRvIHByZXZlbnQgdW53YW50ZWQgc3VwZXItYnViYmxpbmdcbiAgICAvLyBBbGwgbW91c2UgZXZlbnRzIGFyZSBhZmZlY3RlZCBieSB0b3VjaCBmYWxsYmFja1xuICAgIGZ1bmN0aW9uIGFwcGx5U2ltcGxlRXZlbnRUdW5uZWxzKG5hbWVHZW5lcmF0b3IsIGV2ZW50R2VuZXJhdG9yKSB7XG4gICAgICAgIFsncG9pbnRlcmRvd24nLCAncG9pbnRlcm1vdmUnLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJvdmVyJywgJ3BvaW50ZXJvdXQnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKG5hbWVHZW5lcmF0b3IoZXZlbnROYW1lKSwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIGlmICghdG91Y2hpbmcgJiYgZmluZEV2ZW50UmVnaXN0ZXJlZE5vZGUoZXZ0LnRhcmdldCwgZXZlbnROYW1lKSkgZXZlbnRHZW5lcmF0b3IoZXZ0LCBldmVudE5hbWUsIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAod2luZG93WydvbicgKyBuYW1lR2VuZXJhdG9yKCdwb2ludGVyZW50ZXInKS50b0xvd2VyQ2FzZSgpXSA9PT0gdW5kZWZpbmVkKSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihuYW1lR2VuZXJhdG9yKCdwb2ludGVyb3ZlcicpLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICBpZiAodG91Y2hpbmcpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBmb3VuZE5vZGUgPSBmaW5kRXZlbnRSZWdpc3RlcmVkTm9kZShldnQudGFyZ2V0LCAncG9pbnRlcmVudGVyJyk7XG4gICAgICAgICAgICBpZiAoIWZvdW5kTm9kZSB8fCBmb3VuZE5vZGUgPT09IHdpbmRvdykgcmV0dXJuO2Vsc2UgaWYgKCFmb3VuZE5vZGUuY29udGFpbnMoZXZ0LnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hQb2ludGVyRW50ZXIoZm91bmROb2RlLCBldnQucmVsYXRlZFRhcmdldCwgZnVuY3Rpb24gKHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRHZW5lcmF0b3IoZXZ0LCAncG9pbnRlcmVudGVyJywgZmFsc2UsIHRhcmdldE5vZGUsIGV2dC5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh3aW5kb3dbJ29uJyArIG5hbWVHZW5lcmF0b3IoJ3BvaW50ZXJsZWF2ZScpLnRvTG93ZXJDYXNlKCldID09PSB1bmRlZmluZWQpIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKG5hbWVHZW5lcmF0b3IoJ3BvaW50ZXJvdXQnKSwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgaWYgKHRvdWNoaW5nKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZm91bmROb2RlID0gZmluZEV2ZW50UmVnaXN0ZXJlZE5vZGUoZXZ0LnRhcmdldCwgJ3BvaW50ZXJsZWF2ZScpO1xuICAgICAgICAgICAgaWYgKCFmb3VuZE5vZGUgfHwgZm91bmROb2RlID09PSB3aW5kb3cpIHJldHVybjtlbHNlIGlmICghZm91bmROb2RlLmNvbnRhaW5zKGV2dC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoUG9pbnRlckxlYXZlKGZvdW5kTm9kZSwgZXZ0LnJlbGF0ZWRUYXJnZXQsIGZ1bmN0aW9uICh0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50R2VuZXJhdG9yKGV2dCwgJ3BvaW50ZXJsZWF2ZScsIGZhbHNlLCB0YXJnZXROb2RlLCBldnQucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcbiAgICAgICAgICAgIC8vSUUgMTBcbiAgICAgICAgICAgIGFwcGx5U2ltcGxlRXZlbnRUdW5uZWxzKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByZWZpeEV2ZW50TmFtZSgnTVMnLCBuYW1lKTtcbiAgICAgICAgICAgIH0sIGdlbmVyYXRlVG91Y2hDbG9uZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBseVNpbXBsZUV2ZW50VHVubmVscyhnZXRNb3VzZUVxdWl2YWxlbnRFdmVudE5hbWUsIGdlbmVyYXRlTW91c2VQcm94eSk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsaW5nIG1vdmUgb24gd2luZG93IHRvIGRldGVjdCBwb2ludGVybGVhdmUvb3V0L292ZXJcbiAgICAgICAgICAgIGlmICh3aW5kb3cub250b3VjaHN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldmVudE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50T2JqZWN0LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG91Y2hQb2ludCA9IGV2ZW50T2JqZWN0LmNoYW5nZWRUb3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNUYXJnZXRzW3RvdWNoUG9pbnQuaWRlbnRpZmllcl0gPSB0b3VjaFBvaW50LnRhcmdldDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVUb3VjaEV2ZW50UHJveHlJZlJlZ2lzdGVyZWQoJ3BvaW50ZXJvdmVyJywgdG91Y2hQb2ludCwgdG91Y2hQb2ludC50YXJnZXQsIGV2ZW50T2JqZWN0LCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9wb2ludGVyZW50ZXIgc2hvdWxkIG5vdCBiZSBidWJibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaFBvaW50ZXJFbnRlcih0b3VjaFBvaW50LnRhcmdldCwgbnVsbCwgZnVuY3Rpb24gKHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZVRvdWNoRXZlbnRQcm94eSgncG9pbnRlcmVudGVyJywgdG91Y2hQb2ludCwgdGFyZ2V0Tm9kZSwgZXZlbnRPYmplY3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZVRvdWNoRXZlbnRQcm94eUlmUmVnaXN0ZXJlZCgncG9pbnRlcmRvd24nLCB0b3VjaFBvaW50LCB0b3VjaFBvaW50LnRhcmdldCwgZXZlbnRPYmplY3QsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRvdWNoVGltZXIoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGZ1bmN0aW9uIChldmVudE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50T2JqZWN0LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG91Y2hQb2ludCA9IGV2ZW50T2JqZWN0LmNoYW5nZWRUb3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBwcmV2aW91c1RhcmdldHNbdG91Y2hQb2ludC5pZGVudGlmaWVyXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlVG91Y2hFdmVudFByb3h5SWZSZWdpc3RlcmVkKCdwb2ludGVydXAnLCB0b3VjaFBvaW50LCBjdXJyZW50VGFyZ2V0LCBldmVudE9iamVjdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZVRvdWNoRXZlbnRQcm94eUlmUmVnaXN0ZXJlZCgncG9pbnRlcm91dCcsIHRvdWNoUG9pbnQsIGN1cnJlbnRUYXJnZXQsIGV2ZW50T2JqZWN0LCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9wb2ludGVybGVhdmUgc2hvdWxkIG5vdCBiZSBidWJibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaFBvaW50ZXJMZWF2ZShjdXJyZW50VGFyZ2V0LCBudWxsLCBmdW5jdGlvbiAodGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlVG91Y2hFdmVudFByb3h5KCdwb2ludGVybGVhdmUnLCB0b3VjaFBvaW50LCB0YXJnZXROb2RlLCBldmVudE9iamVjdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcmV2aW91c1RhcmdldHNbdG91Y2hQb2ludC5pZGVudGlmaWVyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUb3VjaFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2ZW50T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRPYmplY3QuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3VjaFBvaW50ID0gZXZlbnRPYmplY3QuY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaFBvaW50LmNsaWVudFgsIHRvdWNoUG9pbnQuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRhcmdldCA9IHByZXZpb3VzVGFyZ2V0c1t0b3VjaFBvaW50LmlkZW50aWZpZXJdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBmb3JjZSBwcmV2ZW50RGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgJiYgY2hlY2tQcmV2ZW50RGVmYXVsdChjdXJyZW50VGFyZ2V0KSA9PT0gdHJ1ZSkgZXZlbnRPYmplY3QucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmlld3BvcnQgbWFuaXB1bGF0aW9uIGZpcmVzIG5vbi1jYW5jZWxhYmxlIHRvdWNobW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudE9iamVjdC5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByZXZpb3VzVGFyZ2V0c1t0b3VjaFBvaW50LmlkZW50aWZpZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlVG91Y2hFdmVudFByb3h5SWZSZWdpc3RlcmVkKCdwb2ludGVyY2FuY2VsJywgdG91Y2hQb2ludCwgY3VycmVudFRhcmdldCwgZXZlbnRPYmplY3QsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlVG91Y2hFdmVudFByb3h5SWZSZWdpc3RlcmVkKCdwb2ludGVyb3V0JywgdG91Y2hQb2ludCwgY3VycmVudFRhcmdldCwgZXZlbnRPYmplY3QsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hQb2ludGVyTGVhdmUoY3VycmVudFRhcmdldCwgbnVsbCwgZnVuY3Rpb24gKHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVUb3VjaEV2ZW50UHJveHkoJ3BvaW50ZXJsZWF2ZScsIHRvdWNoUG9pbnQsIHRhcmdldE5vZGUsIGV2ZW50T2JqZWN0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlVG91Y2hFdmVudFByb3h5SWZSZWdpc3RlcmVkKCdwb2ludGVybW92ZScsIHRvdWNoUG9pbnQsIGN1cnJlbnRUYXJnZXQsIGV2ZW50T2JqZWN0LCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT09IG5ld1RhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBXZSBjYW4gc2tpcCB0aGlzIGFzIHRoZSBwb2ludGVyIGlzIGVmZmVjdGl2ZWx5IG92ZXIgdGhlIGN1cnJlbnQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmFpc2Ugb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVUb3VjaEV2ZW50UHJveHlJZlJlZ2lzdGVyZWQoJ3BvaW50ZXJvdXQnLCB0b3VjaFBvaW50LCBjdXJyZW50VGFyZ2V0LCBldmVudE9iamVjdCwgdHJ1ZSwgbmV3VGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJhaXNlIGxlYXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50VGFyZ2V0LmNvbnRhaW5zKG5ld1RhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVhdmUgbXVzdCBiZSBjYWxsZWQgaWYgdGhlIG5ldyB0YXJnZXQgaXMgbm90IGEgY2hpbGQgb2YgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hQb2ludGVyTGVhdmUoY3VycmVudFRhcmdldCwgbmV3VGFyZ2V0LCBmdW5jdGlvbiAodGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVUb3VjaEV2ZW50UHJveHkoJ3BvaW50ZXJsZWF2ZScsIHRvdWNoUG9pbnQsIHRhcmdldE5vZGUsIGV2ZW50T2JqZWN0LCBmYWxzZSwgbmV3VGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmFpc2Ugb3ZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlVG91Y2hFdmVudFByb3h5SWZSZWdpc3RlcmVkKCdwb2ludGVyb3ZlcicsIHRvdWNoUG9pbnQsIG5ld1RhcmdldCwgZXZlbnRPYmplY3QsIHRydWUsIGN1cnJlbnRUYXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmFpc2UgZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1RhcmdldC5jb250YWlucyhjdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZWF2ZSBtdXN0IGJlIGNhbGxlZCBpZiB0aGUgbmV3IHRhcmdldCBpcyBub3QgdGhlIHBhcmVudCBvZiB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaFBvaW50ZXJFbnRlcihuZXdUYXJnZXQsIGN1cnJlbnRUYXJnZXQsIGZ1bmN0aW9uICh0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZVRvdWNoRXZlbnRQcm94eSgncG9pbnRlcmVudGVyJywgdG91Y2hQb2ludCwgdGFyZ2V0Tm9kZSwgZXZlbnRPYmplY3QsIGZhbHNlLCBjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNUYXJnZXRzW3RvdWNoUG9pbnQuaWRlbnRpZmllcl0gPSBuZXdUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VG91Y2hUaW1lcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgZnVuY3Rpb24gKGV2ZW50T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRPYmplY3QuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3VjaFBvaW50ID0gZXZlbnRPYmplY3QuY2hhbmdlZFRvdWNoZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlVG91Y2hFdmVudFByb3h5SWZSZWdpc3RlcmVkKCdwb2ludGVyY2FuY2VsJywgdG91Y2hQb2ludCwgcHJldmlvdXNUYXJnZXRzW3RvdWNoUG9pbnQuaWRlbnRpZmllcl0sIGV2ZW50T2JqZWN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkoKTtcblxuICAgIC8vIEV4dGVuc2lvbiB0byBuYXZpZ2F0b3JcbiAgICBpZiAobmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAvLyBJbmRpY2F0ZXMgaWYgdGhlIGJyb3dzZXIgd2lsbCBmaXJlIHBvaW50ZXIgZXZlbnRzIGZvciBwb2ludGluZyBpbnB1dFxuICAgICAgICBuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIElFXG4gICAgICAgIGlmIChuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgICAgICAgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID0gbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHM7XG4gICAgICAgIH1cbiAgICB9XG59KSh3aW5kb3cpO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdG91Y2gvdG91Y2grY2xpY2sgZXZlbnRzIGludG8gYSAncG9pbnRlcnRhcCcgZXZlbnQgdGhhdCBpcyBub3RcbiAqIHBhcnQgb2Ygc3RhbmRhcmQuXG4gKiBVc2VzIHBvaW50ZXJFdmVudHMgcG9seWZpbGwgb3IgbmF0aXZlIFBvaW50ZXJFdmVudHMgd2hlbiBzdXBwb3J0ZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFVzZSBwb2ludGVydGFwIGFzIGZhc3RjbGljayBvbiB0b3VjaCBlbmFibGVkIGRldmljZXNcbiAqIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5idG4nKS5hZGRFdmVudExpc3RlbmVyKGNoLnBvaW50ZXJ0YXAsIGZ1bmN0aW9uKGUpIHtcbiAqICAgY29uc29sZS5sb2coJ3RhcCcpO1xuICogfSk7XG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gSUU4IGhhcyBubyBzdXBwb3J0IGZvciBjdXN0b20gTW91c2UgRXZlbnRzLCBmYWxsYmFjayB0byBvbmNsaWNrXG5cbiAgICBpZiAoIXdpbmRvdy5Nb3VzZUV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgUE9JTlRFUl9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbiAgICB2YXIgUE9JTlRFUl9UWVBFX1BFTiA9ICdwZW4nO1xuICAgIHZhciBQT0lOVEVSX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xuXG4gICAgdmFyIGlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgdmFyIHNjcm9sbFRpbWVvdXQgPSBmYWxzZTtcbiAgICB2YXIgc0Rpc3RYID0gMDtcbiAgICB2YXIgc0Rpc3RZID0gMDtcbiAgICB2YXIgYWN0aXZlUG9pbnRlcjtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHNEaXN0WCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgICAgICAgIHNEaXN0WSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpc1Njcm9sbGluZyA9IHRydWU7XG4gICAgICAgIGNsZWFyVGltZW91dChzY3JvbGxUaW1lb3V0KTtcbiAgICAgICAgc2Nyb2xsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHNEaXN0WCA9IDA7XG4gICAgICAgICAgICBzRGlzdFkgPSAwO1xuICAgICAgICB9LCAxMDApO1xuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgcG9pbnRlckRvd24pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBwb2ludGVyVXApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybGVhdmUnLCBwb2ludGVyTGVhdmUpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgZnVuY3Rpb24gKCkgLyogZSAqL3t9KTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlICdwb2ludGVyZG93bicgZXZlbnQgZnJvbSBwb2ludGVyRXZlbnRzIHBvbHlmaWxsIG9yIG5hdGl2ZSBQb2ludGVyRXZlbnRzIHdoZW4gc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR8UG9pbnRlckV2ZW50fSBlIEV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBvaW50ZXJEb3duKGUpIHtcbiAgICAgICAgLy8gZG9uJ3QgcmVnaXN0ZXIgYW4gYWN0aXZlUG9pbnRlciBpZiBtb3JlIHRoYW4gb25lIHRvdWNoIGlzIGFjdGl2ZS5cbiAgICAgICAgdmFyIHNpbmdsZUZpbmdlciA9IGUucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9NT1VTRSB8fCBlLnBvaW50ZXJUeXBlID09PSBQT0lOVEVSX1RZUEVfUEVOIHx8IGUucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCAmJiBlLmlzUHJpbWFyeTtcblxuICAgICAgICBpZiAoIWlzU2Nyb2xsaW5nICYmIHNpbmdsZUZpbmdlcikge1xuICAgICAgICAgICAgYWN0aXZlUG9pbnRlciA9IHtcbiAgICAgICAgICAgICAgICBpZDogZS5wb2ludGVySWQsXG4gICAgICAgICAgICAgICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgICAgICAgICB4OiBlLnggfHwgZS5wYWdlWCxcbiAgICAgICAgICAgICAgICB5OiBlLnkgfHwgZS5wYWdlWSxcbiAgICAgICAgICAgICAgICB0eXBlOiBlLnBvaW50ZXJUeXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgJ3BvaW50ZXJsZWF2ZScgZXZlbnQgZnJvbSBwb2ludGVyRXZlbnRzIHBvbHlmaWxsIG9yIG5hdGl2ZSBQb2ludGVyRXZlbnRzIHdoZW4gc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR8UG9pbnRlckV2ZW50fSBlIEV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBvaW50ZXJMZWF2ZSgpIC8qIGUgKi97XG4gICAgICAgIGFjdGl2ZVBvaW50ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlICdwb2ludGVydXAnIGV2ZW50IGZyb20gcG9pbnRlckV2ZW50cyBwb2x5ZmlsbCBvciBuYXRpdmUgUG9pbnRlckV2ZW50cyB3aGVuIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fFBvaW50ZXJFdmVudH0gZSBFdmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwb2ludGVyVXAoZSkge1xuICAgICAgICAvLyBEb2VzIG91ciBldmVudCBpcyB0aGUgc2FtZSBhcyB0aGUgYWN0aXZlUG9pbnRlciBzZXQgYnkgcG9pbnRlcmRvd24/XG4gICAgICAgIGlmIChhY3RpdmVQb2ludGVyICYmIGFjdGl2ZVBvaW50ZXIuaWQgPT09IGUucG9pbnRlcklkKSB7XG4gICAgICAgICAgICAvLyBIYXZlIHdlIG1vdmVkIHRvbyBtdWNoP1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGFjdGl2ZVBvaW50ZXIueCAtIChlLnggfHwgZS5wYWdlWCkpIDwgNSAmJiBNYXRoLmFicyhhY3RpdmVQb2ludGVyLnkgLSAoZS55IHx8IGUucGFnZVkpKSA8IDUpIHtcbiAgICAgICAgICAgICAgICAvLyBIYXZlIHdlIHNjcm9sbGVkIHRvbyBtdWNoP1xuICAgICAgICAgICAgICAgIGlmICghaXNTY3JvbGxpbmcgfHwgTWF0aC5hYnMoc0Rpc3RYIC0gd2luZG93LnBhZ2VYT2Zmc2V0KSA8IDUgJiYgTWF0aC5hYnMoc0Rpc3RZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFrZVBvaW50ZXJ0YXBFdmVudChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUG9pbnRlciA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcG9pbnRlcnRhcCBldmVudCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHN0YW5kYXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR8UG9pbnRlckV2ZW50fSBzb3VyY2VFdmVudCBBbiBldmVudCB0byB1c2UgYXMgYSBiYXNlIGZvciBwb2ludGVydGFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VQb2ludGVydGFwRXZlbnQoc291cmNlRXZlbnQpIHtcbiAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgICAgICB2YXIgbmV3VGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChzb3VyY2VFdmVudC5jbGllbnRYLCBzb3VyY2VFdmVudC5jbGllbnRZKTtcblxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIE1ETiBkb2NzIGlmIHRoZSBzcGVjaWZpZWQgcG9pbnQgaXMgb3V0c2lkZSB0aGUgdmlzaWJsZSBib3VuZHMgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIC8vIG9yIGVpdGhlciBjb29yZGluYXRlIGlzIG5lZ2F0aXZlLCB0aGUgcmVzdWx0IGlzIG51bGxcbiAgICAgICAgaWYgKCFuZXdUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSAnaW5pdE1vdXNlRXZlbnQnIHdpdGggJ25ldyBNb3VzZUV2ZW50J1xuICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoJ3BvaW50ZXJ0YXAnLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsIHNvdXJjZUV2ZW50LnNjcmVlblgsIHNvdXJjZUV2ZW50LnNjcmVlblksIHNvdXJjZUV2ZW50LmNsaWVudFgsIHNvdXJjZUV2ZW50LmNsaWVudFksIHNvdXJjZUV2ZW50LmN0cmxLZXksIHNvdXJjZUV2ZW50LmFsdEtleSwgc291cmNlRXZlbnQuc2hpZnRLZXksIHNvdXJjZUV2ZW50Lm1ldGFLZXksIHNvdXJjZUV2ZW50LmJ1dHRvbiwgbmV3VGFyZ2V0KTtcblxuICAgICAgICBldnQubWFza2VkRXZlbnQgPSBzb3VyY2VFdmVudDtcbiAgICAgICAgbmV3VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgICByZXR1cm4gZXZ0O1xuICAgIH1cbn0pKCk7XG5cbnZhciBzdXBwb3J0c01vdXNlRXZlbnRzID0gISF3aW5kb3cuTW91c2VFdmVudDtcblxuLyoqXG4gKiBFdmVyeSB0aW1lIENoaWNvIFVJIG5lZWRzIHRvIGluZm9ybSBhbGwgdmlzdWFsIGNvbXBvbmVudHMgdGhhdCBsYXlvdXQgaGFzXG4gKiBiZWVuIGNoYW5nZWQsIGl0IGVtaXRzIHRoaXMgZXZlbnQuXG4gKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG52YXIgb25sYXlvdXRjaGFuZ2UgPSAnbGF5b3V0Y2hhbmdlJztcblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvICdyZXNpemUnLlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG52YXIgb25yZXNpemUgPSAncmVzaXplJztcblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvICdzY3JvbGwnLlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG52YXIgb25zY3JvbGwgPSAnc2Nyb2xsJztcblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvICdwb2ludGVyZG93bicgb3IgJ21vdXNlZG93bicsIGRlcGVuZGluZyBvbiBicm93c2VyIGNhcGFiaWxpdGllcy5cbiAqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyNkZm4tcG9pbnRlcmRvd24gfCBQb2ludGVyIEV2ZW50cyBXM0MgUmVjb21tZW5kYXRpb25cbiAqL1xudmFyIG9ucG9pbnRlcmRvd24gPSBzdXBwb3J0c01vdXNlRXZlbnRzID8gJ3BvaW50ZXJkb3duJyA6ICdtb3VzZWRvd24nO1xuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gJ3BvaW50ZXJ1cCcgb3IgJ21vdXNldXAnLCBkZXBlbmRpbmcgb24gYnJvd3NlciBjYXBhYmlsaXRpZXMuXG4gKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jZGZuLXBvaW50ZXJ1cCB8IFBvaW50ZXIgRXZlbnRzIFczQyBSZWNvbW1lbmRhdGlvblxuICovXG52YXIgb25wb2ludGVydXAgPSBzdXBwb3J0c01vdXNlRXZlbnRzID8gJ3BvaW50ZXJ1cCcgOiAnbW91c2V1cCc7XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byAncG9pbnRlcm1vdmUnIG9yICdtb3VzZW1vdmUnLCBkZXBlbmRpbmcgb24gYnJvd3NlciBjYXBhYmlsaXRpZXMuXG4gKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jZGZuLXBvaW50ZXJtb3ZlIHwgUG9pbnRlciBFdmVudHMgVzNDIFJlY29tbWVuZGF0aW9uXG4gKi9cbnZhciBvbnBvaW50ZXJtb3ZlID0gc3VwcG9ydHNNb3VzZUV2ZW50cyA/ICdwb2ludGVybW92ZScgOiAnbW91c2Vtb3ZlJztcblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvICdwb2ludGVydGFwJyBvciAnY2xpY2snLCBkZXBlbmRpbmcgb24gYnJvd3NlciBjYXBhYmlsaXRpZXMuXG4gKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jbGlzdC1vZi1wb2ludGVyLWV2ZW50cyB8IFBvaW50ZXIgRXZlbnRzIFczQyBSZWNvbW1lbmRhdGlvblxuICovXG52YXIgb25wb2ludGVydGFwID0gc3VwcG9ydC50b3VjaCAmJiBzdXBwb3J0c01vdXNlRXZlbnRzID8gJ3BvaW50ZXJ0YXAnIDogJ2NsaWNrJztcblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvICdwb2ludGVyZW50ZXInIG9yICdtb3VzZWVudGVyJywgZGVwZW5kaW5nIG9uIGJyb3dzZXIgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEBjb25zdGFudFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvI2Rmbi1wb2ludGVyZW50ZXIgfCBQb2ludGVyIEV2ZW50cyBXM0MgUmVjb21tZW5kYXRpb25cbiAqL1xudmFyIG9ucG9pbnRlcmVudGVyID0gc3VwcG9ydHNNb3VzZUV2ZW50cyA/ICdwb2ludGVyZW50ZXInIDogJ21vdXNlZW50ZXInO1xuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gJ3BvaW50ZXJsZWF2ZScgb3IgJ21vdXNlbGVhdmUnLCBkZXBlbmRpbmcgb24gYnJvd3NlciBjYXBhYmlsaXRpZXMuXG4gKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jZGZuLXBvaW50ZXJsZWF2ZSB8IFBvaW50ZXIgRXZlbnRzIFczQyBSZWNvbW1lbmRhdGlvblxuICovXG52YXIgb25wb2ludGVybGVhdmUgPSBzdXBwb3J0c01vdXNlRXZlbnRzID8gJ3BvaW50ZXJsZWF2ZScgOiAnbW91c2VsZWF2ZSc7XG5cbi8qKlxuICogVGhlIERPTSBpbnB1dCBldmVudCB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIHZhbHVlIG9mIGFuIDxpbnB1dD4gb3IgPHRleHRhcmVhPlxuICogZWxlbWVudCBpcyBjaGFuZ2VkLiBFcXVpdmFsZW50IHRvICdpbnB1dCcgb3IgJ2tleWRvd24nLCBkZXBlbmRpbmcgb24gYnJvd3NlclxuICogY2FwYWJpbGl0aWVzLlxuICpcbiAqIEBjb25zdGFudFxuICogQHR5cGUge1N0cmluZ31cbiAqL1xudmFyIG9ua2V5aW5wdXQgPSAnb25pbnB1dCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSA/ICdpbnB1dCcgOiAna2V5ZG93bic7XG5cbnZhciBldmVudHMgPSBPYmplY3QuZnJlZXplKHtcbiAgICBvbmxheW91dGNoYW5nZTogb25sYXlvdXRjaGFuZ2UsXG4gICAgb25yZXNpemU6IG9ucmVzaXplLFxuICAgIG9uc2Nyb2xsOiBvbnNjcm9sbCxcbiAgICBvbnBvaW50ZXJkb3duOiBvbnBvaW50ZXJkb3duLFxuICAgIG9ucG9pbnRlcnVwOiBvbnBvaW50ZXJ1cCxcbiAgICBvbnBvaW50ZXJtb3ZlOiBvbnBvaW50ZXJtb3ZlLFxuICAgIG9ucG9pbnRlcnRhcDogb25wb2ludGVydGFwLFxuICAgIG9ucG9pbnRlcmVudGVyOiBvbnBvaW50ZXJlbnRlcixcbiAgICBvbnBvaW50ZXJsZWF2ZTogb25wb2ludGVybGVhdmUsXG4gICAgb25rZXlpbnB1dDogb25rZXlpbnB1dFxufSk7XG5cbnZhciB0aW55ID0ge1xuICAgIGNsb25lOiBjbG9uZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBpbmhlcml0czogaW5oZXJpdHMsXG4gICAgRXZlbnRFbWl0dGVyOiBFdmVudEVtaXR0ZXIsXG4gICAgYWpheDogYWpheCxcbiAgICBqc29ucDoganNvbnAsXG4gICAgamNvcnM6IGpjb3JzLFxuICAgIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gICAgc3VwcG9ydDogc3VwcG9ydCxcbiAgICBhZGRDbGFzczogY2xhc3NMaXN0LmFkZENsYXNzLFxuICAgIHJlbW92ZUNsYXNzOiBjbGFzc0xpc3QucmVtb3ZlQ2xhc3MsXG4gICAgaGFzQ2xhc3M6IGNsYXNzTGlzdC5oYXNDbGFzcyxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBuZXh0OiBuZXh0LFxuICAgIGNzczogY3NzLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIHNjcm9sbDogc2Nyb2xsLFxuICAgIGNvb2tpZXM6IGNvb2tpZXMsXG4gICAgb246IERPTUV2ZW50cy5vbixcbiAgICBiaW5kOiBET01FdmVudHMub24sXG4gICAgb25lOiBET01FdmVudHMub25jZSxcbiAgICBvbmNlOiBET01FdmVudHMub25jZSxcbiAgICBvZmY6IERPTUV2ZW50cy5vZmYsXG4gICAgdHJpZ2dlcjogRE9NRXZlbnRzLnRyaWdnZXJcbn07XG5cbmZvciAodmFyIGUgaW4gZXZlbnRzKSB7XG4gICAgdGlueVtlXSA9IGV2ZW50c1tlXTtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LnRpbnkgPSB0aW55O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRpbnk7XG5cbn0se1wiZXZlbnRzXCI6MSxcImluaGVyaXRzXCI6Mn1dfSx7fSxbM10pO1xuIiwiLyohXG4gKiBDaGljbyBVSSB2Mi4wLjlcbiAqIGh0dHA6Ly9jaGljby11aS5jb20uYXIvXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LCBNZXJjYWRvTGlicmUuY29tXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vY2hpY28tdWkuY29tLmFyL2xpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24gKHdpbmRvdykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgYWxsIHRoZSBwdWJsaWMgbWVtYmVycy4gQSBzaG9ydCBhbGlhcyBmb3IgZWwucXVlcnlTZWxlY3RvckFsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBWYWxpZCBDU1Mgc2VsZWN0b3IgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fSBjb250ZXh0IEEgRE9NIEVsZW1lbnQsIERvY3VtZW50LCBvciBzZWxlY3RvciBzdHJpbmcgdG8gdXNlIGFzIHF1ZXJ5IGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7Tm9kZUxpc3R9IEEgY29sbGVjdGlvbiBvZiBtYXRjaGVkIGVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEdldCBhbGwgZmlyc3QgbGV2ZWwgaGVhZGluZ3NcbiAgICAgKiB2YXIgaGVhZGluZ3MgPSBjaCgnaDEnKTtcbiAgICAgKlxuICAgICAqIC8vIEdldCBhIGxpc3Qgb2YgcCBjaGlsZHJlbiBlbGVtZW50cyB1bmRlciBhIGNvbnRhaW5lciwgd2hvc2UgcGFyZW50IGlzIGEgZGl2IHRoYXQgaGFzIHRoZSBjbGFzcyAnd3JhcHBlcidcbiAgICAgKiB2YXIgcGFyYWdyYXBocyA9IGNoKCdwJywgY2goJ2Rpdi53cmFwcGVyJykpO1xuICAgICAqIC8vIFRoZSBzYW1lIGFzIGFib3ZlXG4gICAgICogdmFyIHBhcmFncmFwaHMgPSBjaCgncCcsICdkaXYud3JhcHBlcicpO1xuICAgICAqL1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMqL1xuICAgIHZhciBjaCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dCA9IGRvY3VtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29udGV4dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgTm9kZUxpc3QgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QgYnV0IEFycmF5LmlzQXJyYXkgaXMgYWx3YXlzIGZhbHN5XG4gICAgICAgIC8vIHdlIHNob3VsZCBkZXRlY3QgdGhlIE5vZGVMaXN0XG4gICAgICAgIC8vIFBsZWFzZSByZXBsYWNlIE5vZGVMaXN0IGRldGVjdGlvbiB3aXRoIGBjb250ZXh0IGluc3RhbmNlb2YgTm9kZUxpc3QgJiYgY29udGV4dC5sZW5ndGggPiAwYFxuICAgICAgICAvLyAgIHdoZW4gSUU4IHN1cHBvcnQgd2lsbCBiZSBkcm9wcGVkXG4gICAgICAgIC8vIFBsZWFzZSByZXBsYWNlIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCB3aXRoIGBjb250ZXh0Lmhhc093blByb3BlcnR5YCB3aGVuIElFOFxuICAgICAgICAvLyAgIHN1cHBvcnQgd2lsbCBiZSBkcm9wcGVkXG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIC9eXFxbb2JqZWN0IChIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdHxPYmplY3QpXFxdJC8udGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29udGV4dCkpICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGV4dCwgJ2xlbmd0aCcpICYmIGNvbnRleHQubGVuZ3RoID4gMCAmJiBjb250ZXh0WzBdLm5vZGVUeXBlID4gMCkge1xuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHRbMF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dCA9PT0gbnVsbCB8fCAhY29udGV4dC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgY29udGV4dCA9IGRvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgfTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMqL1xuXG4gICAgLyoqXG4gICAgICogVGFiIGtleSBldmVudC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAbWVtYmVyb2YgY2hcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNoLm9ua2V5dGFiID0gJ3RhYic7XG5cbiAgICAvKipcbiAgICAgKiBFbnRlciBrZXkgZXZlbnQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBjaC5vbmtleWVudGVyID0gJ2VudGVyJztcblxuICAgIC8qKlxuICAgICAqIEVzYyBrZXkgZXZlbnQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBjaC5vbmtleWVzYyA9ICdlc2MnO1xuXG4gICAgLyoqXG4gICAgICogTGVmdCBhcnJvdyBrZXkgZXZlbnQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBjaC5vbmtleWxlZnRhcnJvdyA9ICdsZWZ0X2Fycm93JztcblxuICAgIC8qKlxuICAgICAqIFVwIGFycm93IGtleSBldmVudC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAbWVtYmVyb2YgY2hcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNoLm9ua2V5dXBhcnJvdyA9ICd1cF9hcnJvdyc7XG5cbiAgICAvKipcbiAgICAgKiBSaWd0aCBhcnJvdyBrZXkgZXZlbnQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBjaC5vbmtleXJpZ2h0YXJyb3cgPSAncmlnaHRfYXJyb3cnO1xuXG4gICAgLyoqXG4gICAgICogRG93biBhcnJvdyBrZXkgZXZlbnQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBjaC5vbmtleWRvd25hcnJvdyA9ICdkb3duX2Fycm93JztcblxuICAgIC8qKlxuICAgICAqIEJhY2tzcGFjZSBrZXkgZXZlbnQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBjaC5vbmtleWJhY2tzcGFjZSA9ICdiYWNrc3BhY2UnO1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGluIGNoYW5nZSBvZiBleHBvc2UgYSBmcmllbmRseSBpbnRlcmZhY2Ugb2YgdGhlIENoaWNvIGNvbnN0cnVjdG9ycy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBjaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBLbGFzcyBEaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBjb25zdHJ1Y3RvciBmcm9tIHdoZXJlIHRoZSAkLXBsdWdpbiB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICogQGxpbmsgaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9QbHVnaW5zL0F1dGhvcmluZyB8IEF1dGhvcmluZ1xuICAgICAqL1xuICAgIGNoLmZhY3RvcnkgPSBmdW5jdGlvbiAoS2xhc3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aWZpY2F0aW9uIG9mIHRoZSBjb25zdHJ1Y3RvciwgaW4gbG93ZXJjYXNlcy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHZhciBuYW1lID0gS2xhc3MucHJvdG90eXBlLm5hbWU7XG5cbiAgICAgICAgLy8gVXNlcyB0aGUgZnVuY3Rpb24ubmFtZSBwcm9wZXJ0eSAobm9uLXN0YW5kYXJkKSBvbiB0aGUgbmV3ZXN0IGJyb3dzZXJzIE9SXG4gICAgICAgIC8vIHVwcGVyY2FzZXMgdGhlIGZpcnN0IGxldHRlciBmcm9tIHRoZSBpZGVudGlmaWNhdGlvbiBuYW1lIG9mIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICBjaFsobmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpKV0gPSBLbGFzcztcbiAgICB9O1xuXG4vLyBSZW1vdmUgdGhlIG5vLWpzIGNsYXNzbmFtZSBmcm9tIGh0bWwgdGFnXG50aW55LnJlbW92ZUNsYXNzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ25vLWpzJyk7XG5cbi8vIEV4cG9zZSBldmVudCBuYW1lc1xuZm9yICh2YXIgbSBpbiB0aW55KSB7XG4gICAgaWYgKC9eb25cXHcrLy50ZXN0KG0pICYmIHR5cGVvZiB0aW55W21dID09PSAnc3RyaW5nJykge1xuICAgICAgICBjaFttXSA9IHRpbnlbbV07XG4gICAgfVxufVxuXG5cdGNoLnZlcnNpb24gPSAnMi4wLjknO1xuXHR3aW5kb3cuY2ggPSBjaDtcbn0odGhpcykpO1xuKGZ1bmN0aW9uIChjaCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGZ1bmN0aW9uIHRvIG1hbmFnZSBjb21wb25lbnRzIGNvbnRlbnQuXG4gICAgICogQG1lbWJlck9mIGNoXG4gICAgICogQG1peGluXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbnRlbnQoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHRoaXMuX29wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICdwYXJhbXMnOiB0aGlzLl9vcHRpb25zLnBhcmFtcyxcbiAgICAgICAgICAgICAgICAnY2FjaGUnOiB0aGlzLl9vcHRpb25zLmNhY2hlLFxuICAgICAgICAgICAgICAgICd3YWl0aW5nJzogdGhpcy5fb3B0aW9ucy53YWl0aW5nXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYXN5bmMgY29udGVudCBpbnRvIGNvbXBvbmVudCdzIGNvbnRhaW5lciBhbmQgZW1pdHMgdGhlIGN1cnJlbnQgZXZlbnQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzZXRBc3luY0NvbnRlbnQoZXZlbnQpIHtcblxuICAgICAgICAgICAgdGhhdC5fY29udGVudC5pbm5lckhUTUwgPSBldmVudC5yZXNwb25zZTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbnRlbnQgY2hhbmdlLlxuICAgICAgICAgICAgICogQGV2ZW50IGNoLkNvbnRlbnQjY29udGVudGNoYW5nZVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhhdC5lbWl0KCdfY29udGVudGNoYW5nZScpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgaWYgdGhlIGNvbnRlbnQgaXMgbG9hZGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgICAgICAgICAqIEBldmVudCBjaC5Db250ZW50I2NvbnRlbnRkb25lXG4gICAgICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbnRlbnQgaXMgbG9hZGluZy5cbiAgICAgICAgICAgICAqIEBldmVudCBjaC5Db250ZW50I2NvbnRlbnR3YWl0aW5nXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwiY29udGVudHdhaXRpbmdcIiBldmVudC5cbiAgICAgICAgICAgICAqIGNvbXBvbmVudC5vbignY29udGVudHdhaXRpbmcnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXZlbnQgZW1pdHRlZCBpZiB0aGUgY29udGVudCBpc24ndCBsb2FkZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgICAgICogQGV2ZW50IGNoLkNvbnRlbnQjY29udGVudGVycm9yXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwiY29udGVudGVycm9yXCIgZXZlbnQuXG4gICAgICAgICAgICAgKiBjb21wb25lbnQub24oJ2NvbnRlbnRlcnJvcicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgdGhhdC5lbWl0KCdjb250ZW50JyArIGV2ZW50LnN0YXR1cywgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBjb250ZW50IGludG8gY29tcG9uZW50J3MgY29udGFpbmVyIGFuZCBlbWl0cyB0aGUgY29udGVudGRvbmUgZXZlbnQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQpIHtcblxuICAgICAgICAgICAgaWYgKGNvbnRlbnQubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoYXQuX2NvbnRlbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICAgICAgdGhhdC5fY29udGVudC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fY29udGVudC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRoYXQuX29wdGlvbnMuY2FjaGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29udGVudCBjaGFuZ2UuXG4gICAgICAgICAgICAgKiBAZXZlbnQgY2guQ29udGVudCNjb250ZW50Y2hhbmdlXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGF0LmVtaXQoJ19jb250ZW50Y2hhbmdlJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXZlbnQgZW1pdHRlZCBpZiB0aGUgY29udGVudCBpcyBsb2FkZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgICAgICogQGV2ZW50IGNoLkNvbnRlbnQjY29udGVudGRvbmVcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJjb250ZW50ZG9uZVwiIGV2ZW50LlxuICAgICAgICAgICAgICogY29tcG9uZW50Lm9uKCdjb250ZW50ZG9uZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoYXQuZW1pdCgnY29udGVudGRvbmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYXN5bmMgY29udGVudCB3aXRoIGdpdmVuIFVSTC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldEFzeW5jQ29udGVudCh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0Q2ZnO1xuICAgICAgICAgICAgLy8gSW5pdGlhbCBvcHRpb25zIHRvIGJlIG1lcmdlZCB3aXRoIHRoZSB1c2VyJ3Mgb3B0aW9uc1xuICAgICAgICAgICAgb3B0aW9ucyA9IHRpbnkuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAnbWV0aG9kJzogJ0dFVCcsXG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6ICcnLFxuICAgICAgICAgICAgICAgICd3YWl0aW5nJzogJzxkaXYgY2xhc3M9XCJjaC1sb2FkaW5nLWxhcmdlXCI+PC9kaXY+J1xuICAgICAgICAgICAgfSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBTZXQgbG9hZGluZ1xuICAgICAgICAgICAgc2V0QXN5bmNDb250ZW50KHtcbiAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ3dhaXRpbmcnLFxuICAgICAgICAgICAgICAgICdyZXNwb25zZSc6IG9wdGlvbnMud2FpdGluZ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlcXVlc3RDZmcgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFzeW5jQ29udGVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ2RvbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Jlc3BvbnNlJzogcmVzcFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXN5bmNDb250ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGF0dXMnOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Jlc3BvbnNlJzogJzxwPkVycm9yIG9uIGFqYXggY2FsbC48L3A+JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhJzogZXJyLm1lc3NhZ2UgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fb3B0aW9ucy5jYWNoZSA9IG9wdGlvbnMuY2FjaGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhY2hlID09PSBmYWxzZSAmJiBbJ0dFVCcsICdIRUFEJ10uaW5kZXhPZihvcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Q2ZnLmNhY2hlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChbJ0dFVCcsICdIRUFEJ10uaW5kZXhPZihvcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpICE9PSAtMSB8fCBvcHRpb25zLnBhcmFtc1swXSA9PT0gJz8nID8gJycgOiAnPycpICsgb3B0aW9ucy5wYXJhbXM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdENmZy5kYXRhID0gb3B0aW9ucy5wYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIGEgcmVxdWVzdFxuICAgICAgICAgICAgdGlueS5hamF4KHVybCwgcmVxdWVzdENmZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHRvIG1hbmFnZSB0aGUgY29tcG9uZW50cyBjb250ZW50LlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQG1lbWJlcm9mISBjaC5Db250ZW50I1xuICAgICAgICAgKiBAcGFyYW0geyhTdHJpbmcgfCBIVE1MRWxlbWVudCl9IGNvbnRlbnQgVGhlIGNvbnRlbnQgdGhhdCB3aWxsIGJlIHVzZWQgYnkgYSBjb21wb25lbnQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBjdXN0b20gb3B0aW9ucyB0byBiZSB1c2VkIHdpdGggY29udGVudCBsb2FkZWQgYnkgYWpheC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1ldGhvZF0gVGhlIHR5cGUgb2YgcmVxdWVzdCAoXCJQT1NUXCIgb3IgXCJHRVRcIikgdG8gbG9hZCBjb250ZW50IGJ5IGFqYXguIERlZmF1bHQ6IFwiR0VUXCIuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbXNdIFBhcmFtcyBsaWtlIHF1ZXJ5IHN0cmluZyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2FjaGVdIEZvcmNlIHRvIGNhY2hlIHRoZSByZXF1ZXN0IGJ5IHRoZSBicm93c2VyLiBEZWZhdWx0OiB0cnVlLiBmYWxzZSB2YWx1ZSB3aWxsIHdvcmsgb25seSB3aXRoIEhFQUQgYW5kIEdFVCByZXF1ZXN0c1xuICAgICAgICAgKiBAcGFyYW0geyhTdHJpbmcgfCBIVE1MRWxlbWVudCl9IFtvcHRpb25zLndhaXRpbmddIFRlbXBvcmFyeSBjb250ZW50IHRvIHVzZSB3aGlsZSB0aGUgYWpheCByZXF1ZXN0IGlzIGxvYWRpbmcuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFVwZGF0ZSBjb250ZW50IHdpdGggc29tZSBzdHJpbmcuXG4gICAgICAgICAqIGNvbXBvbmVudC5jb250ZW50KCdTb21lIG5ldyBjb250ZW50IGhlcmUhJyk7XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFVwZGF0ZSBjb250ZW50IHRoYXQgd2lsbCBiZSBsb2FkZWQgYnkgYWpheCB3aXRoIGN1c3RvbSBvcHRpb25zLlxuICAgICAgICAgKiBjb21wb25lbnQuY29udGVudCgnaHR0cDovL2NoaWNvLXVpLmNvbS5hci9hamF4Jywge1xuICAgICAgICAgKiAgICAgJ2NhY2hlJzogZmFsc2UsXG4gICAgICAgICAqICAgICAncGFyYW1zJzogJ3gtcmVxdWVzdD10cnVlJ1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50O1xuXG4gICAgICAgICAgICAvLyBSZXR1cm5zIHRoZSBsYXN0IHVwZGF0ZWQgY29udGVudC5cbiAgICAgICAgICAgIGlmIChjb250ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5fY29udGVudC5pbm5lckhUTUw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoYXQuX29wdGlvbnMuY29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0aGF0Ll9vcHRpb25zLmNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9vcHRpb25zLmNhY2hlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIENhc2UgMTogQUpBWCBjYWxsXG4gICAgICAgICAgICAgICAgaWYgKCgvXigoKGh0dHBzfGh0dHB8ZnRwfGZpbGUpOlxcL1xcLyl8d3d3XFwufFxcLlxcL3woXFwuXFwuXFwvKSt8KFxcL3sxLDJ9KXwoXFxkezEsM31cXC4pezN9XFxkezEsM30pKCgoXFx3K3wtKShcXC4/KShcXC8/KSkrKShcXDpcXGR7MSw1fSl7MCwxfSgoKFxcdyt8LSkoXFwuPykoXFwvPykoIz8pKSspKChcXD8pKFxcdys9KFxcdz8pKygmPykpKyk/KFxcdysjXFx3Kyk/JC8pLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXN5bmNDb250ZW50KGNvbnRlbnQucmVwbGFjZSgvIy4rLywgJycpLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBDYXNlIDI6IFBsYWluIHRleHRcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhc2UgMzogSFRNTCBFbGVtZW50XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnQubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgdGlueS5yZW1vdmVDbGFzcyhjb250ZW50LCAnY2gtaGlkZScpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHRpbnkucGFyZW50KGNvbnRlbnQpO1xuXG4gICAgICAgICAgICAgICAgc2V0Q29udGVudChjb250ZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhhdC5fb3B0aW9ucy5jYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIExvYWRzIGNvbnRlbnQgb25jZS4gSWYgdGhlIGNhY2hlIGlzIGRpc2FibGVkIHRoZSBjb250ZW50IGxvYWRzIGluIGVhY2ggc2hvdy5cbiAgICAgICAgdGhpcy5vbmNlKCdfc2hvdycsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdGhhdC5jb250ZW50KHRoYXQuX29wdGlvbnMuY29udGVudCk7XG5cbiAgICAgICAgICAgIHRoYXQub24oJ3Nob3cnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGF0Ll9vcHRpb25zLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY29udGVudCh0aGF0Ll9vcHRpb25zLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjaC5Db250ZW50ID0gQ29udGVudDtcblxufSh0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAoY2gpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgdG9nZ2xlRWZmZWN0cyA9IHtcbiAgICAgICAgJ3NsaWRlRG93bic6ICdzbGlkZVVwJyxcbiAgICAgICAgJ3NsaWRlVXAnOiAnc2xpZGVEb3duJyxcbiAgICAgICAgJ2ZhZGVJbic6ICdmYWRlT3V0JyxcbiAgICAgICAgJ2ZhZGVPdXQnOiAnZmFkZUluJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQ29sbGFwc2libGUgY2xhc3MgZ2l2ZXMgdG8gY29tcG9uZW50cyB0aGUgYWJpbGl0eSB0byBzaG93biBvciBoaWRkZW4gaXRzIGNvbnRhaW5lci5cbiAgICAgKiBAbWVtYmVyT2YgY2hcbiAgICAgKiBAbWl4aW5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBwcml2YXRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbGxhcHNpYmxlKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gY29udGV4dCBvZiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIHRyaWdnZXJDbGFzcyA9ICdjaC0nICsgdGhpcy5uYW1lICsgJy10cmlnZ2VyLW9uJyxcbiAgICAgICAgICAgIGZ4ID0gdGhpcy5fb3B0aW9ucy5meCxcbiAgICAgICAgICAgIHVzZUVmZmVjdHMgPSAodGlueS5zdXBwb3J0LnRyYW5zaXRpb24gJiYgZnggIT09ICdub25lJyAmJiBmeCAhPT0gZmFsc2UpLFxuICAgICAgICAgICAgcHQsIHBiO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNob3dDYWxsYmFjayhlKSB7XG4gICAgICAgICAgICBpZiAodXNlRWZmZWN0cykge1xuICAgICAgICAgICAgICAgIHRpbnkucmVtb3ZlQ2xhc3ModGhhdC5jb250YWluZXIsICdjaC1meC0nICsgZngpO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVXNlIG9yaWdpbmFsIGhlaWdodCB3aGVuIGl0IGlzIGRlZmluZWRcbiAgICAgICAgICAgICAgICBpZiAoL15zbGlkZS8udGVzdChmeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGlueS5yZW1vdmVDbGFzcyh0aGF0LmNvbnRhaW5lciwgJ2NoLWhpZGUnKTtcbiAgICAgICAgICAgIHRoYXQuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGUudHlwZSwgc2hvd0NhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBzaG93bi5cbiAgICAgICAgICAgICAqIEBldmVudCBjaC5Db2xsYXBzaWJsZSNzaG93XG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwic2hvd1wiIGV2ZW50LlxuICAgICAgICAgICAgICogY29sbGFwc2libGUub24oJ3Nob3cnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhhdC5lbWl0KCdzaG93Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoaWRlQ2FsbGJhY2soZSkge1xuICAgICAgICAgICAgaWYgKHVzZUVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICB0aW55LnJlbW92ZUNsYXNzKHRoYXQuY29udGFpbmVyLCAnY2gtZngtJyArIHRvZ2dsZUVmZmVjdHNbZnhdKTtcbiAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKC9ec2xpZGUvLnRlc3QoZngpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3ModGhhdC5jb250YWluZXIsICdjaC1oaWRlJyk7XG4gICAgICAgICAgICB0aGF0LmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGUudHlwZSwgaGlkZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBoaWRkZW4uXG4gICAgICAgICAgICAgKiBAZXZlbnQgY2guQ29sbGFwc2libGUjaGlkZVxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcImhpZGVcIiBldmVudC5cbiAgICAgICAgICAgICAqIGNvbGxhcHNpYmxlLm9uKCdoaWRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoYXQuZW1pdCgnaGlkZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2hvd24gPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvd3MgdGhlIGNvbXBvbmVudCBjb250YWluZXIuXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2hvdyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdGhhdC5fc2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGhhdC50cmlnZ2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aW55LmFkZENsYXNzKHRoYXQudHJpZ2dlciwgdHJpZ2dlckNsYXNzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFdmVudCBlbWl0dGVkIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHNob3duLlxuICAgICAgICAgICAgICogQGV2ZW50IGNoLkNvbGxhcHNpYmxlI2JlZm9yZXNob3dcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJiZWZvcmVzaG93XCIgZXZlbnQuXG4gICAgICAgICAgICAgKiBjb2xsYXBzaWJsZS5vbignYmVmb3Jlc2hvdycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGF0LmVtaXQoJ2JlZm9yZXNob3cnKTtcblxuICAgICAgICAgICAgLy8gQW5pbWF0ZSBvciBub3RcbiAgICAgICAgICAgIGlmICh1c2VFZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9oID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIEJlIHN1cmUgdG8gcmVtb3ZlIGFuIG9wcG9zaXRlIGNsYXNzIHRoYXQgcHJvYmFibHkgZXhpc3QgYW5kXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNpdGlvbmVuZCBsaXN0ZW5lciBmb3IgYW4gb3Bwb3NpdGUgdHJhbnNpdGlvbiwgYWthICQuZm4uc3RvcCh0cnVlLCB0cnVlKVxuICAgICAgICAgICAgICAgIHRpbnkub2ZmKHRoYXQuY29udGFpbmVyLCB0aW55LnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsIGhpZGVDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgdGlueS5yZW1vdmVDbGFzcyh0aGF0LmNvbnRhaW5lciwgJ2NoLWZ4LScgKyB0b2dnbGVFZmZlY3RzW2Z4XSk7XG5cbiAgICAgICAgICAgICAgICB0aW55Lm9uKHRoYXQuY29udGFpbmVyLCB0aW55LnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsIHNob3dDYWxsYmFjayk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXZlYWwgYW4gZWxlbWVudCBiZWZvcmUgdGhlIHRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICAgICAgICAgIC8vIFNldCBtYXJnaW4gYW5kIHBhZGRpbmcgdG8gMCB0byBwcmV2ZW50IGNvbnRlbnQganVtcGluZyBhdCB0aGUgdHJhbnNpdGlvbiBlbmRcbiAgICAgICAgICAgICAgICBpZiAoL15zbGlkZS8udGVzdChmeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIG9yaWdpbmFsIHBhZGRpbmdzIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXB0IHx8ICFwYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHQgPSB0aW55LmNzcyh0aGF0LmNvbnRhaW5lciwgJ3BhZGRpbmctdG9wJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYiA9IHRpbnkuY3NzKHRoYXQuY29udGFpbmVyLCAncGFkZGluZy1ib3R0b20nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXIuc3R5bGUubWFyZ2luVG9wID0gdGhhdC5jb250YWluZXIuc3R5bGUubWFyZ2luQm90dG9tID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lci5zdHlsZS5wYWRkaW5nVG9wID0gdGhhdC5jb250YWluZXIuc3R5bGUucGFkZGluZ0JvdHRvbSA9JzBweCc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAuMDEnO1xuICAgICAgICAgICAgICAgICAgICBfaCA9IHRoYXQuY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXIuc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAnMHB4JztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUcmFuc2l0aW9uIGNhbm5vdCBiZSBhcHBsaWVkIGF0IHRoZSBzYW1lIHRpbWUgd2hlbiBjaGFuZ2luZyB0aGUgZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvXnNsaWRlLy50ZXN0KGZ4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gX2ggKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY29udGFpbmVyLnN0eWxlLnBhZGRpbmdUb3AgPSBwdDtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXIuc3R5bGUucGFkZGluZ0JvdHRvbSA9IHBiO1xuICAgICAgICAgICAgICAgICAgICB0aW55LmFkZENsYXNzKHRoYXQuY29udGFpbmVyLCAnY2gtZngtJyArIGZ4KTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hvd0NhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoYXQuZW1pdCgnX3Nob3cnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpZGVzIHRoZSBjb21wb25lbnQgY29udGFpbmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hpZGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHRoYXQuX3Nob3duID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0aGF0LnRyaWdnZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRpbnkucmVtb3ZlQ2xhc3ModGhhdC50cmlnZ2VyLCB0cmlnZ2VyQ2xhc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgaGlkZGVuLlxuICAgICAgICAgICAgICogQGV2ZW50IGNoLkNvbGxhcHNpYmxlI2JlZm9yZWhpZGVcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJiZWZvcmVoaWRlXCIgZXZlbnQuXG4gICAgICAgICAgICAgKiBjb2xsYXBzaWJsZS5vbignYmVmb3JlaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGF0LmVtaXQoJ2JlZm9yZWhpZGUnKTtcblxuICAgICAgICAgICAgLy8gQW5pbWF0ZSBvciBub3RcbiAgICAgICAgICAgIGlmICh1c2VFZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgLy8gQmUgc3VyZSB0byByZW1vdmUgYW4gb3Bwb3NpdGUgY2xhc3MgdGhhdCBwcm9iYWJseSBleGlzdCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2l0aW9uZW5kIGxpc3RlbmVyIGZvciBhbiBvcHBvc2l0ZSB0cmFuc2l0aW9uLCBha2EgJC5mbi5zdG9wKHRydWUsIHRydWUpXG4gICAgICAgICAgICAgICAgdGlueS5vZmYodGhhdC5jb250YWluZXIsIHRpbnkuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCwgc2hvd0NhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB0aW55LnJlbW92ZUNsYXNzKHRoYXQuY29udGFpbmVyLCAnY2gtZngtJyArIGZ4KTtcblxuICAgICAgICAgICAgICAgIHRpbnkub24odGhhdC5jb250YWluZXIsIHRpbnkuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCwgaGlkZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgbWFyZ2luIGFuZCBwYWRkaW5nIHRvIDAgdG8gcHJldmVudCBjb250ZW50IGp1bXBpbmcgYXQgdGhlIHRyYW5zaXRpb24gZW5kXG4gICAgICAgICAgICAgICAgaWYgKC9ec2xpZGUvLnRlc3QoZngpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRpbnkuY3NzKHRoYXQuY29udGFpbmVyLCAnaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZXMgbmV4dFRpY2sgdG8gdHJpZ2dlciB0aGUgaGVpZ2h0IGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lci5zdHlsZS5wYWRkaW5nVG9wID0gdGhhdC5jb250YWluZXIuc3R5bGUucGFkZGluZ0JvdHRvbSA9JzBweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW55LmFkZENsYXNzKHRoYXQuY29udGFpbmVyLCAnY2gtZngtJyArIHRvZ2dsZUVmZmVjdHNbZnhdKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3ModGhhdC5jb250YWluZXIsICdjaC1meC0nICsgdG9nZ2xlRWZmZWN0c1tmeF0pO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZGVDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvd3Mgb3IgaGlkZXMgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGF0Ll9zaG93bikge1xuICAgICAgICAgICAgICAgIHRoYXQuaGlkZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGF0LnNob3coKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vbignZGlzYWJsZScsIHRoaXMuaGlkZSk7XG4gICAgfVxuXG4gICAgY2guQ29sbGFwc2libGUgPSBDb2xsYXBzaWJsZTtcblxufSh0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAod2luZG93LCBjaCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciByZXNpemVkID0gZmFsc2UsXG4gICAgICAgIHNjcm9sbGVkID0gZmFsc2UsXG4gICAgICAgIHJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9KCkpO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgICAgIHZhciBldmUgPSAocmVzaXplZCA/IGNoLm9ucmVzaXplIDogY2gub25zY3JvbGwpO1xuXG4gICAgICAgIC8vIFJlZnJlc2ggdmlld3BvcnRcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG5cbiAgICAgICAgLy8gQ2hhbmdlIHN0YXR1c1xuICAgICAgICByZXNpemVkID0gZmFsc2U7XG4gICAgICAgIHNjcm9sbGVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdmlld3BvcnQgY2hhbmdlcy5cbiAgICAgICAgICogQGV2ZW50IGNoLnZpZXdwb3J0I3Jlc2l6ZVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjaC52aWV3cG9ydC5vbigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSB2aWV3cG9ydCBpcyBzY3JvbGxlZC5cbiAgICAgICAgICogQGV2ZW50IGNoLnZpZXdwb3J0I3Njcm9sbFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjaC52aWV3cG9ydC5vbignc2Nyb2xsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cblxuICAgICAgICAvLyBFbWl0cyB0aGUgY3VycmVudCBldmVudFxuICAgICAgICB0aGlzLmVtaXQoZXZlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgVmlld3BvcnQgaXMgYSBjb21wb25lbnQgdG8gZWFzZSB2aWV3cG9ydCBtYW5hZ2VtZW50LiBZb3UgY2FuIGdldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdmlld3BvcnQgYW5kIGJleW9uZCwgd2hpY2ggY2FuIGJlIHF1aXRlIGhlbHBmdWwgdG8gcGVyZm9ybSBzb21lIGNoZWNrcyB3aXRoIEphdmFTY3JpcHQuXG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIHRpbnkuRXZlbnRFbWl0dGVyXG4gICAgICogQHJldHVybnMge3ZpZXdwb3J0fSBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIFZpZXdwb3J0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZpZXdwb3J0KCkge1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuXG4gICAgdGlueS5pbmhlcml0cyhWaWV3cG9ydCwgdGlueS5FdmVudEVtaXR0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBpbnN0YW5jZSBvZiBWaWV3cG9ydC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlZpZXdwb3J0LnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3ZpZXdwb3J0fVxuICAgICAqL1xuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU2V0IGVtaXR0ZXIgdG8gemVybyBmb3IgdW5saW1pdGVkIGxpc3RlbmVycyB0byBhdm9pZCB0aGUgd2FybmluZyBpbiBjb25zb2xlXG4gICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNldmVudHNfZW1pdHRlcl9zZXRtYXhsaXN0ZW5lcnNfblxuICAgICAgICB0aGlzLnNldE1heExpc3RlbmVycygwKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSB2aXNpYmxlIGFyZWEuXG4gICAgICAgICAqIEBtZW1iZXJvZiEgY2gudmlld3BvcnQjZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbCA9IHdpbmRvdztcblxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcblxuXG4gICAgICAgIGZ1bmN0aW9uIHZpZXdwb3J0UmVzaXplKCkge1xuICAgICAgICAgICAgLy8gTm8gY2hhbmdpbmcsIGV4aXRcbiAgICAgICAgICAgIGlmICghcmVzaXplZCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiB1cGRhdGVSZXNpemUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZS5jYWxsKHRoYXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdmlld3BvcnRTY3JvbGwoKSB7XG4gICAgICAgICAgICAvLyBObyBjaGFuZ2luZywgZXhpdFxuICAgICAgICAgICAgaWYgKCFzY3JvbGxlZCkge1xuICAgICAgICAgICAgICAgIHNjcm9sbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gdXBkYXRlU2Nyb2xsKCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUuY2FsbCh0aGF0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRpbnkub24od2luZG93LCBjaC5vbnNjcm9sbCwgdmlld3BvcnRTY3JvbGwsIGZhbHNlKTtcbiAgICAgICAgdGlueS5vbih3aW5kb3csIGNoLm9ucmVzaXplLCB2aWV3cG9ydFJlc2l6ZSwgZmFsc2UpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzL3VwZGF0ZXMgdGhlIGNsaWVudCByZWN0cyBvZiB2aWV3cG9ydCAoaW4gcGl4ZWxzKS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlZpZXdwb3J0LnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHt2aWV3cG9ydH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFVwZGF0ZSB0aGUgY2xpZW50IHJlY3RzIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBjaC52aWV3cG9ydC5jYWxjdWxhdGVDbGllbnRSZWN0KCk7XG4gICAgICovXG4gICAgVmlld3BvcnQucHJvdG90eXBlLmNhbGN1bGF0ZUNsaWVudFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCB0b3AgY2xpZW50IHJlY3Qgb2YgdGhlIHZpZXdwb3J0IChpbiBwaXhlbHMpLlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBuYW1lIGNoLlZpZXdwb3J0I3RvcFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBDaGVja3MgaWYgdGhlIHRvcCBjbGllbnQgcmVjdCBvZiB0aGUgdmlld3BvcnQgaXMgZXF1YWwgdG8gMC5cbiAgICAgICAgICogKGNoLnZpZXdwb3J0LnRvcCA9PT0gMCkgPyAnWWVzJzogJ05vJztcbiAgICAgICAgICovXG5cbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBsZWZ0IGNsaWVudCByZWN0IG9mIHRoZSB2aWV3cG9ydCAoaW4gcGl4ZWxzKS5cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAbmFtZSBjaC5WaWV3cG9ydCNsZWZ0XG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIENoZWNrcyBpZiB0aGUgbGVmdCBjbGllbnQgcmVjdCBvZiB0aGUgdmlld3BvcnQgaXMgZXF1YWwgdG8gMC5cbiAgICAgICAgICogKGNoLnZpZXdwb3J0LmxlZnQgPT09IDApID8gJ1llcyc6ICdObyc7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvcCA9IHRoaXMubGVmdCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IGJvdHRvbSBjbGllbnQgcmVjdCBvZiB0aGUgdmlld3BvcnQgKGluIHBpeGVscykuXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQG5hbWUgY2guVmlld3BvcnQjYm90dG9tXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIENoZWNrcyBpZiB0aGUgYm90dG9tIGNsaWVudCByZWN0IG9mIHRoZSB2aWV3cG9ydCBpcyBlcXVhbCB0byBhIG51bWJlci5cbiAgICAgICAgICogKGNoLnZpZXdwb3J0LmJvdHRvbSA9PT0gOTAwKSA/ICdZZXMnOiAnTm8nO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3R0b20gPSBNYXRoLm1heCh0aGlzLmVsLmlubmVySGVpZ2h0IHx8IDAsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCByaWdodCBjbGllbnQgcmVjdCBvZiB0aGUgdmlld3BvcnQgKGluIHBpeGVscykuXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQG5hbWUgY2guVmlld3BvcnQjcmlnaHRcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gQ2hlY2tzIGlmIHRoZSByaWdodCBjbGllbnQgcmVjdCBvZiB0aGUgdmlld3BvcnQgaXMgZXF1YWwgdG8gYSBudW1iZXIuXG4gICAgICAgICAqIChjaC52aWV3cG9ydC5ib3R0b20gPT09IDEyMDApID8gJ1llcyc6ICdObyc7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5lbC5pbm5lcldpZHRoIHx8IDAsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMvdXBkYXRlcyB0aGUgZGltZW5zaW9ucyAod2lkdGggYW5kIGhlaWdodCkgb2YgdGhlIHZpZXdwb3J0IChpbiBwaXhlbHMpLlxuICAgICAqIEBtZW1iZXJvZiEgY2guVmlld3BvcnQucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge3ZpZXdwb3J0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gVXBkYXRlIHRoZSBkaW1lbnNpb25zIHZhbHVlcyBvZiB0aGUgdmlld3BvcnQuXG4gICAgICogY2gudmlld3BvcnQuY2FsY3VsYXRlRGltZW5zaW9ucygpO1xuICAgICAqL1xuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5jYWxjdWxhdGVEaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUNsaWVudFJlY3QoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydCAoaW4gcGl4ZWxzKS5cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAbmFtZSBjaC5WaWV3cG9ydCNoZWlnaHRcbiAgICAgICAgICogQHR5cGUgTnVtYmVyXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIENoZWNrcyBpZiB0aGUgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydCBpcyBlcXVhbCB0byBhIG51bWJlci5cbiAgICAgICAgICogKGNoLnZpZXdwb3J0LmhlaWdodCA9PT0gNzAwKSA/ICdZZXMnOiAnTm8nO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdHRvbTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIHZpZXdwb3J0IChpbiBwaXhlbHMpLlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBuYW1lIGNoLlZpZXdwb3J0I3dpZHRoXG4gICAgICAgICAqIEB0eXBlIE51bWJlclxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBDaGVja3MgaWYgdGhlIGhlaWdodCBvZiB0aGUgdmlld3BvcnQgaXMgZXF1YWwgdG8gYSBudW1iZXIuXG4gICAgICAgICAqIChjaC52aWV3cG9ydC53aWR0aCA9PT0gMTIwMCkgPyAnWWVzJzogJ05vJztcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzL3VwZGF0ZXMgdGhlIHZpZXdwb3J0IHBvc2l0aW9uLlxuICAgICAqIEBtZW1iZXJvZiEgY2guVmlld3BvcnQucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge3ZpZXdwb3J0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gVXBkYXRlIHRoZSBvZmZlc3QgdmFsdWVzIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBjaC52aWV3cG9ydC5jYWxjdWxhdGVPZmZzZXQoKTtcbiAgICAgKi9cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gY29udGV4dCBvZiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBzY3JvbGwgPSB0aW55LnNjcm9sbCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb2Zmc2V0IHRvcCBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAgICAqIEBtZW1iZXJvZiEgY2guVmlld3BvcnQjb2Zmc2V0VG9wXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIENoZWNrcyBpZiB0aGUgb2Zmc2V0IHRvcCBvZiB0aGUgdmlld3BvcnQgaXMgZXF1YWwgdG8gYSBudW1iZXIuXG4gICAgICAgICAqIChjaC52aWV3cG9ydC5vZmZzZXRUb3AgPT09IDIwMCkgPyAnWWVzJzogJ05vJztcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub2Zmc2V0VG9wID0gc2Nyb2xsLnRvcDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9mZnNldCBsZWZ0IG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgICogQG1lbWJlcm9mISBjaC5WaWV3cG9ydCNvZmZzZXRMZWZ0XG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIENoZWNrcyBpZiB0aGUgb2Zmc2V0IGxlZnQgb2YgdGhlIHZpZXdwb3J0IGlzIGVxdWFsIHRvIGEgbnVtYmVyLlxuICAgICAgICAgKiAoY2gudmlld3BvcnQub2Zmc2V0TGVmdCA9PT0gMjAwKSA/ICdZZXMnOiAnTm8nO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vZmZzZXRMZWZ0ID0gc2Nyb2xsLmxlZnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvZmZzZXQgcmlnaHQgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgKiBAbWVtYmVyb2YhIGNoLlZpZXdwb3J0I29mZnNldFJpZ2h0XG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIENoZWNrcyBpZiB0aGUgb2Zmc2V0IHJpZ2h0IG9mIHRoZSB2aWV3cG9ydCBpcyBlcXVhbCB0byBhIG51bWJlci5cbiAgICAgICAgICogKGNoLnZpZXdwb3J0Lm9mZnNldFJpZ2h0ID09PSAyMDApID8gJ1llcyc6ICdObyc7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9mZnNldFJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9mZnNldCBib3R0b20gb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgKiBAbWVtYmVyb2YhIGNoLlZpZXdwb3J0I29mZnNldEJvdHRvbVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBDaGVja3MgaWYgdGhlIG9mZnNldCBib3R0b20gb2YgdGhlIHZpZXdwb3J0IGlzIGVxdWFsIHRvIGEgbnVtYmVyLlxuICAgICAgICAgKiAoY2gudmlld3BvcnQub2Zmc2V0Qm90dG9tID09PSAyMDApID8gJ1llcyc6ICdObyc7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9mZnNldEJvdHRvbSA9IHRoaXMub2Zmc2V0VG9wICsgdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcnR1bnMvdXBkYXRlcyB0aGUgdmlld3BvcnQgb3JpZW50YXRpb246IGxhbmRzY2FwZSBvciBwb3J0cmFpdC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlZpZXdwb3J0LnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHt2aWV3cG9ydH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFVwZGF0ZSB0aGUgZGltZW5zaW9ucyB2YWx1ZXMgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAqIGNoLnZpZXdwb3J0LmNhbGN1bGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgKi9cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuY2FsY3VsYXRlT3JpZW50YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKiBUaGUgdmlld3BvcnQgb3JpZW50YXRpb246IGxhbmRzY2FwZSBvciBwb3J0cmFpdC5cbiAgICAgICAgICogQG1lbWJlcm9mISBjaC5WaWV3cG9ydCNvcmllbnRhdGlvblxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBDaGVja3MgaWYgdGhlIG9yaWVudGF0aW9uIGlzIFwibGFuZHNjYXBlXCIuXG4gICAgICAgICAqIChjaC52aWV3cG9ydC5vcmllbnRhdGlvbiA9PT0gJ2xhbmRzY2FwZScpID8gJ1llcyc6ICdObyc7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gKE1hdGguYWJzKHRoaXMuZWwub3JpZW50YXRpb24pID09PSA5MCkgPyAnbGFuZHNjYXBlJyA6ICdwb3J0cmFpdCc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgaWYgYW4gZWxlbWVudCBpcyBjb21wbGV0ZWx5IGxvY2F0ZWQgaW4gdGhlIHZpZXdwb3J0LlxuICAgICAqIEBtZW1iZXJvZiEgY2guVmlld3BvcnQucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQHBhcmFtcyB7SFRNTEVsZW1lbnR9IGVsIEEgZ2l2ZW4gSE1UTEVsZW1lbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDaGVja3MgaWYgYW4gZWxlbWVudCBpcyBpbiB0aGUgdmlld3BvcnQuXG4gICAgICogY2gudmlld3BvcnQuaW5WaWV3cG9ydChIVE1MRWxlbWVudCkgPyAnWWVzJzogJ05vJztcbiAgICAgKi9cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuaW5WaWV3cG9ydCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgciA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHJldHVybiAoci50b3AgPiAwKSAmJiAoci5yaWdodCA8IHRoaXMud2lkdGgpICYmIChyLmJvdHRvbSA8IHRoaXMuaGVpZ2h0KSAmJiAoci5sZWZ0ID4gMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgaWYgYW4gZWxlbWVudCBpcyB2aXNpYmxlIGluIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlZpZXdwb3J0LnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBwYXJhbXMge0hUTUxFbGVtZW50fSBlbCBBIGdpdmVuIEhUTUxFbGVtZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ2hlY2tzIGlmIGFuIGVsZW1lbnQgaXMgdmlzaWJsZS5cbiAgICAgKiBjaC52aWV3cG9ydC5pc1Zpc2lzYmxlKEhUTUxFbGVtZW50KSA/ICdZZXMnOiAnTm8nO1xuICAgICAqL1xuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIHIgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICByZXR1cm4gKHIuaGVpZ2h0ID49IHRoaXMub2Zmc2V0VG9wKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBhZHRlcyB0aGUgdmlld3BvcnQgZGltZW5zaW9uLCB2aWV3cG9ydCBwb3NpdGlvbnMgYW5kIG9yaWV0YXRpb24uXG4gICAgICogQG1lbWJlcm9mISBjaC5WaWV3cG9ydC5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7dmlld3BvcnR9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBSZWZyZXNocyB0aGUgdmlld3BvcnQuXG4gICAgICogY2gudmlld3BvcnQucmVmcmVzaCgpO1xuICAgICAqL1xuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVPcmllbnRhdGlvbigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBWaWV3cG9ydCBpbnRvIGNoIG5hbWVzcGFjZS5cbiAgICBjaC52aWV3cG9ydCA9IG5ldyBWaWV3cG9ydCgpO1xuXG59KHRoaXMsIHRoaXMuY2gpKTtcblxuKGZ1bmN0aW9uICh3aW5kb3csIGNoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFBvc2l0aW9uZXIgbGV0cyB5b3UgcG9zaXRpb24gZWxlbWVudHMgb24gdGhlIHNjcmVlbiBhbmQgY2hhbmdlcyBpdHMgcG9zaXRpb25zLlxuICAgICAqIEBtZW1iZXJvZiBjaFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRhcmdldCBBIEhUTUxFbGVtZW50IHRoYXQgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRvIGJlIHBvc2l0aW9uZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJlZmVyZW5jZV0gQSBIVE1MRWxlbWVudCB0aGF0IGl0J3MgYSByZWZlcmVuY2UgdG8gcG9zaXRpb24gYW5kIHNpemUgb2YgZWxlbWVudCB0aGF0IHdpbGwgYmUgY29uc2lkZXJlZCB0byBjYXJyeSBvdXQgdGhlIHBvc2l0aW9uLiBJZiBpdCBpc24ndCBkZWZpbmVkIHRocm91Z2ggY29uZmlndXJhdGlvbiwgaXQgd2lsbCBiZSB0aGUgY2gudmlld3BvcnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNpZGVdIFRoZSBzaWRlIG9wdGlvbiB3aGVyZSB0aGUgdGFyZ2V0IGVsZW1lbnQgd2lsbCBiZSBwb3NpdGlvbmVkLiBZb3UgbXVzdCB1c2U6IFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wXCIsIFwiYm90dG9tXCIgb3IgXCJjZW50ZXJcIi4gRGVmYXVsdDogXCJjZW50ZXJcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWxpZ25dIFRoZSBhbGlnbiBvcHRpb25zIHdoZXJlIHRoZSB0YXJnZXQgZWxlbWVudCB3aWxsIGJlIHBvc2l0aW9uZWQuIFlvdSBtdXN0IHVzZTogXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIiBvciBcImNlbnRlclwiLiBEZWZhdWx0OiBcImNlbnRlclwiLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRYXSBEaXN0YW5jZSB0byBkaXNwbGFjZSB0aGUgdGFyZ2V0IGhvcml6b250YWxseS4gRGVmYXVsdDogMC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WV0gRGlzdGFuY2UgdG8gZGlzcGxhY2UgdGhlIHRhcmdldCB2ZXJ0aWNhbGx5LiBEZWZhdWx0OiAwLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbl0gVGhldGhlIHR5cGUgb2YgcG9zaXRpb25pbmcgdXNlZC4gWW91IG11c3QgdXNlOiBcImFic29sdXRlXCIgb3IgXCJmaXhlZFwiLiBEZWZhdWx0OiBcImZpeGVkXCIuXG4gICAgICogQHJlcXVpcmVzIGNoLlZpZXdwb3J0XG4gICAgICogQHJldHVybnMge3Bvc2l0aW9uZXJ9IFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgUG9zaXRpb25lci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEluc3RhbmNlIHRoZSBQb3NpdGlvbmVyIEl0IHJlcXVpcmVzIGEgbGl0dGxlIGNvbmZpZ3VyYXRpb24uXG4gICAgICogLy8gVGhlIGRlZmF1bHQgYmVoYXZpb3IgcGxhY2UgYW4gZWxlbWVudCBjZW50ZXIgaW50byB0aGUgVmlld3BvcnQuXG4gICAgICogdmFyIHBvc2l0aW9uZWQgPSBuZXcgY2guUG9zaXRpb25lcih7XG4gICAgICogICAgICd0YXJnZXQnOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFyZ2V0JyksXG4gICAgICogICAgICdyZWZlcmVuY2UnOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucmVmZXJlbmNlJyksXG4gICAgICogICAgICdzaWRlJzogJ3RvcCcsXG4gICAgICogICAgICdhbGlnbic6ICdsZWZ0JyxcbiAgICAgKiAgICAgJ29mZnNldFgnOiAyMCxcbiAgICAgKiAgICAgJ29mZnNldFknOiAxMFxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gb2Zmc2V0WDogVGhlIFBvc2l0aW9uZXIgY291bGQgYmUgY29uZmlndXJhdGVkIHdpdGggYW4gb2Zmc2V0WC5cbiAgICAgKiAvLyBUaGlzIGV4YW1wbGUgc2hvdyBhbiBlbGVtZW50IGRpc3BsYWNlZCBob3Jpem9udGFsbHkgYnkgMTBweCBvZiBkZWZpbmVkIHBvc2l0aW9uLlxuICAgICAqIHZhciBwb3NpdGlvbmVkID0gbmV3IGNoLlBvc2l0aW9uZXIoe1xuICAgICAqICAgICAndGFyZ2V0JzogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRhcmdldCcpLFxuICAgICAqICAgICAncmVmZXJlbmNlJzogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJlZmVyZW5jZScpLFxuICAgICAqICAgICAnc2lkZSc6ICd0b3AnLFxuICAgICAqICAgICAnYWxpZ24nOiAnbGVmdCcsXG4gICAgICogICAgICdvZmZzZXRYJzogMTBcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG9mZnNldFk6IFRoZSBQb3NpdGlvbmVyIGNvdWxkIGJlIGNvbmZpZ3VyYXRlZCB3aXRoIGFuIG9mZnNldFkuXG4gICAgICogLy8gVGhpcyBleGFtcGxlIHNob3cgYW4gZWxlbWVudCBkaXNwbGFjZWQgdmVydGljYWxseSBieSAxMHB4IG9mIGRlZmluZWQgcG9zaXRpb24uXG4gICAgICogdmFyIHBvc2l0aW9uZWQgPSBuZXcgY2guUG9zaXRpb25lcih7XG4gICAgICogICAgICd0YXJnZXQnOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFyZ2V0JyksXG4gICAgICogICAgICdyZWZlcmVuY2UnOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucmVmZXJlbmNlJyksXG4gICAgICogICAgICdzaWRlJzogJ3RvcCcsXG4gICAgICogICAgICdhbGlnbic6ICdsZWZ0JyxcbiAgICAgKiAgICAgJ29mZnNldFknOiAxMFxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gcG9zaXRpb25lZDogVGhlIHBvc2l0aW9uZXIgY291bGQgYmUgY29uZmlndXJlZCB0byB3b3JrIHdpdGggZml4ZWQgb3IgYWJzb2x1dGUgcG9zaXRpb24gdmFsdWUuXG4gICAgICogdmFyIHBvc2l0aW9uZWQgPSBuZXcgY2guUG9zaXRpb25lcih7XG4gICAgICogICAgICd0YXJnZXQnOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFyZ2V0JyksXG4gICAgICogICAgICdyZWZlcmVuY2UnOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucmVmZXJlbmNlJyksXG4gICAgICogICAgICdwb3NpdGlvbic6ICdmaXhlZCdcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQb3NpdGlvbmVyKG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgd2luZG93LkVycm9yKCdjaC5Qb3NpdGlvbmVyOiBFeHBlY3RlZCBvcHRpb25zIGRlZmluZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGVzIGl0cyBwcml2YXRlIG9wdGlvbnNcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHRpbnkuY2xvbmUodGhpcy5fZGVmYXVsdHMpO1xuXG4gICAgICAgIC8vIEluaXRcbiAgICAgICAgdGhpcy5fY29uZmlndXJlKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQG1lbWJlcm9mISBjaC5Qb3NpdGlvbmVyLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgUG9zaXRpb25lci5wcm90b3R5cGUubmFtZSA9ICdwb3NpdGlvbmVyJztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgY3JlYXRlZCB0aGUgaW5zdGFuY2UncyBwcm90b3R5cGUuXG4gICAgICogQG1lbWJlcm9mISBjaC5Qb3NpdGlvbmVyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUG9zaXRpb25lci5wcm90b3R5cGUuX2NvbnN0cnVjdG9yID0gUG9zaXRpb25lcjtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gYnkgZGVmYXVsdC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUG9zaXRpb25lci5wcm90b3R5cGUuX2RlZmF1bHRzID0ge1xuICAgICAgICAnb2Zmc2V0WCc6IDAsXG4gICAgICAgICdvZmZzZXRZJzogMCxcbiAgICAgICAgJ3NpZGUnOiAnY2VudGVyJyxcbiAgICAgICAgJ2FsaWduJzogJ2NlbnRlcicsXG4gICAgICAgICdyZWZlcmVuY2UnOiBjaC52aWV3cG9ydCxcbiAgICAgICAgJ3Bvc2l0aW9uJzogJ2ZpeGVkJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBwb3NpdGlvbmVyIGluc3RhbmNlIHdpdGggYSBnaXZlbiBvcHRpb25zLlxuICAgICAqIEBtZW1iZXJvZiEgY2guUG9zaXRpb25lci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtwb3NpdGlvbmVyfVxuICAgICAqIEBwYXJhbXMge09iamVjdH0gb3B0aW9ucyBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIFBvc2l0aW9uZXIucHJvdG90eXBlLl9jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgICAgIC8vIE1lcmdlIHVzZXIgb3B0aW9ucyB3aXRoIGl0cyBvcHRpb25zXG4gICAgICAgIHRpbnkuZXh0ZW5kKHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX29wdGlvbnMub2Zmc2V0WCA9IHBhcnNlSW50KHRoaXMuX29wdGlvbnMub2Zmc2V0WCwgMTApO1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9mZnNldFkgPSBwYXJzZUludCh0aGlzLl9vcHRpb25zLm9mZnNldFksIDEwKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHRvIGJlIHBvc2l0aW9uZWQuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgdGhpcy50YXJnZXQ7XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXQncyBhIHJlZmVyZW5jZSB0byBwb3NpdGlvbiBhbmQgc2l6ZSBvZiBlbGVtZW50IHRoYXQgd2lsbCBiZSBjb25zaWRlcmVkIHRvIGNhcnJ5IG91dCB0aGUgcG9zaXRpb24uXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVmZXJlbmNlID0gb3B0aW9ucy5yZWZlcmVuY2UgfHwgdGhpcy5yZWZlcmVuY2U7XG4gICAgICAgIHRoaXMuX3JlZmVyZW5jZSA9IHRoaXMuX29wdGlvbnMucmVmZXJlbmNlO1xuXG4gICAgICAgIHRoaXMudGFyZ2V0LnN0eWxlLnBvc2l0aW9uID0gdGhpcy5fb3B0aW9ucy5wb3NpdGlvbjtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY3VycmVudCBwb3NpdGlvbiB3aXRoIGEgZ2l2ZW4gb3B0aW9uc1xuICAgICAqIEBtZW1iZXJvZiEgY2guUG9zaXRpb25lci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7cG9zaXRpb25lcn1cbiAgICAgKiBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnMgQSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFVwZGF0ZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICogcG9zaXRpb25lZC5yZWZyZXNoKCk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBVcGRhdGVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIHdpdGggbmV3IG9mZnNldFggYW5kIG9mZnNldFkuXG4gICAgICogcG9zaXRpb25lZC5yZWZyZXNoKHtcbiAgICAgKiAgICAgJ29mZmVzdFgnOiAxMDAsXG4gICAgICogICAgICdvZmZlc3RZJzogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBQb3NpdGlvbmVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25maWd1cmUob3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcmVmZXJlbmNlICE9PSBjaC52aWV3cG9ydCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlUmVmZXJlbmNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVUYXJnZXQoKTtcblxuICAgICAgICAvLyB0aGUgb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSB0b3AsIGxlZnQgcmVmZXJlbmNlIHRvIHNldCB0byB0aGUgdGFyZ2V0XG4gICAgICAgIHRoaXMuX3NldFBvaW50KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHJlZmVyZW5jZSAoZWxlbWVudCBvciBjaC52aWV3cG9ydCkgb2YgdGhlIHBvc2l0aW9uLlxuICAgICAqIEBtZW1iZXJvZiEgY2guUG9zaXRpb25lci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtwb3NpdGlvbmVyfVxuICAgICAqL1xuICAgIFBvc2l0aW9uZXIucHJvdG90eXBlLl9jYWxjdWxhdGVSZWZlcmVuY2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIHJlZmVyZW5jZSA9IHRoaXMucmVmZXJlbmNlLFxuICAgICAgICAgICAgb2Zmc2V0O1xuXG4gICAgICAgIHJlZmVyZW5jZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2lkZScsIHRoaXMuX29wdGlvbnMuc2lkZSk7XG4gICAgICAgIHJlZmVyZW5jZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtYWxpZ24nLCB0aGlzLl9vcHRpb25zLmFsaWduKTtcblxuICAgICAgICB0aGlzLl9yZWZlcmVuY2UgPSB0aGlzLl9nZXRPdXRlckRpbWVuc2lvbnMocmVmZXJlbmNlKTtcblxuICAgICAgICBpZiAocmVmZXJlbmNlLm9mZnNldFBhcmVudCA9PT0gdGhpcy50YXJnZXQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZlcmVuY2UubGVmdCA9IHJlZmVyZW5jZS5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgdGhpcy5fcmVmZXJlbmNlLnRvcCA9IHJlZmVyZW5jZS5vZmZzZXRUb3A7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRpbnkub2Zmc2V0KHJlZmVyZW5jZSk7XG4gICAgICAgICAgICB0aGlzLl9yZWZlcmVuY2UubGVmdCA9IG9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgdGhpcy5fcmVmZXJlbmNlLnRvcCA9IG9mZnNldC50b3A7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgcG9zaXRpb25lZCBlbGVtZW50LlxuICAgICAqIEBtZW1iZXJvZiEgY2guUG9zaXRpb25lci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtwb3NpdGlvbmVyfVxuICAgICAqL1xuICAgIFBvc2l0aW9uZXIucHJvdG90eXBlLl9jYWxjdWxhdGVUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLXNpZGUnLCB0aGlzLl9vcHRpb25zLnNpZGUpO1xuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLWFsaWduJywgdGhpcy5fb3B0aW9ucy5hbGlnbik7XG5cbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGhpcy5fZ2V0T3V0ZXJEaW1lbnNpb25zKHRhcmdldCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBvdXRlciBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgY2guUG9zaXRpb25lci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBBIGdpdmVuIEhUTUxFbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgUG9zaXRpb25lci5wcm90b3R5cGUuX2dldE91dGVyRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgb2JqID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd3aWR0aCc6IChvYmoucmlnaHQgLSBvYmoubGVmdCksXG4gICAgICAgICAgICAnaGVpZ2h0JzogKG9iai5ib3R0b20gLSBvYmoudG9wKVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBwb2ludHMuXG4gICAgICogQG1lbWJlcm9mISBjaC5Qb3NpdGlvbmVyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3Bvc2l0aW9uZXJ9XG4gICAgICovXG4gICAgUG9zaXRpb25lci5wcm90b3R5cGUuX3NldFBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2lkZSA9IHRoaXMuX29wdGlvbnMuc2lkZSxcbiAgICAgICAgICAgIG9yaWVudGF0aW9uID0gKHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nKSA/ICdob3Jpem9udGFsJyA6ICgoc2lkZSA9PT0gJ3JpZ2h0JyB8fCBzaWRlID09PSAnbGVmdCcpID8gJ3ZlcnRpY2FsJyA6ICdjZW50ZXInKSxcbiAgICAgICAgICAgIGNvb3JzLFxuICAgICAgICAgICAgb3JpZW50YXRpb25NYXA7XG5cbiAgICAgICAgLy8gdGFrZSB0aGUgc2lkZSBhbmQgY2FsY3VsYXRlIHRoZSBhbGlnbm1lbnQgYW5kIG1ha2UgdGhlIENTU3BvaW50XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZXMgdGhlIGNvb3JkaW5hdGVzIHJlbGF0ZWQgdG8gdGhlIGNlbnRlciBzaWRlIHRvIGxvY2F0ZSB0aGUgdGFyZ2V0XG4gICAgICAgICAgICBjb29ycyA9IHtcbiAgICAgICAgICAgICAgICAndG9wJzogKHRoaXMuX3JlZmVyZW5jZS50b3AgKyAodGhpcy5fcmVmZXJlbmNlLmhlaWdodCAvIDIgLSB0aGlzLl90YXJnZXQuaGVpZ2h0IC8gMikpLFxuICAgICAgICAgICAgICAgICdsZWZ0JzogKHRoaXMuX3JlZmVyZW5jZS5sZWZ0ICsgKHRoaXMuX3JlZmVyZW5jZS53aWR0aCAvIDIgLSB0aGlzLl90YXJnZXQud2lkdGggLyAyKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGVzIHRoZSBjb29yZGluYXRlcyByZWxhdGVkIHRvIHRoZSB0b3Agb3IgYm90dG9tIHNpZGUgdG8gbG9jYXRlIHRoZSB0YXJnZXRcbiAgICAgICAgICAgIG9yaWVudGF0aW9uTWFwID0ge1xuICAgICAgICAgICAgICAgICdsZWZ0JzogdGhpcy5fcmVmZXJlbmNlLmxlZnQsXG4gICAgICAgICAgICAgICAgJ2NlbnRlcic6ICh0aGlzLl9yZWZlcmVuY2UubGVmdCArICh0aGlzLl9yZWZlcmVuY2Uud2lkdGggLyAyIC0gdGhpcy5fdGFyZ2V0LndpZHRoIC8gMikpLFxuICAgICAgICAgICAgICAgICdyaWdodCc6ICh0aGlzLl9yZWZlcmVuY2UubGVmdCArIHRoaXMuX3JlZmVyZW5jZS53aWR0aCAtIHRoaXMuX3RhcmdldC53aWR0aCksXG4gICAgICAgICAgICAgICAgJ3RvcCc6IHRoaXMuX3JlZmVyZW5jZS50b3AgLSB0aGlzLl90YXJnZXQuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICdib3R0b20nOiAodGhpcy5fcmVmZXJlbmNlLnRvcCArIHRoaXMuX3JlZmVyZW5jZS5oZWlnaHQpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb29ycyA9IHtcbiAgICAgICAgICAgICAgICAndG9wJzogb3JpZW50YXRpb25NYXBbc2lkZV0sXG4gICAgICAgICAgICAgICAgJ2xlZnQnOiBvcmllbnRhdGlvbk1hcFt0aGlzLl9vcHRpb25zLmFsaWduXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlcyB0aGUgY29vcmRpbmF0ZXMgcmVsYXRlZCB0byB0aGUgcmlnaHQgb3IgbGVmdCBzaWRlIHRvIGxvY2F0ZSB0aGUgdGFyZ2V0XG4gICAgICAgICAgICBvcmllbnRhdGlvbk1hcCA9IHtcbiAgICAgICAgICAgICAgICAndG9wJzogdGhpcy5fcmVmZXJlbmNlLnRvcCxcbiAgICAgICAgICAgICAgICAnY2VudGVyJzogKHRoaXMuX3JlZmVyZW5jZS50b3AgKyAodGhpcy5fcmVmZXJlbmNlLmhlaWdodCAvIDIgLSB0aGlzLl90YXJnZXQuaGVpZ2h0IC8gMikpLFxuICAgICAgICAgICAgICAgICdib3R0b20nOiAodGhpcy5fcmVmZXJlbmNlLnRvcCArIHRoaXMuX3JlZmVyZW5jZS5oZWlnaHQgLSB0aGlzLl90YXJnZXQuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAncmlnaHQnOiAodGhpcy5fcmVmZXJlbmNlLmxlZnQgKyB0aGlzLl9yZWZlcmVuY2Uud2lkdGgpLFxuICAgICAgICAgICAgICAgICdsZWZ0JzogKHRoaXMuX3JlZmVyZW5jZS5sZWZ0IC0gdGhpcy5fdGFyZ2V0LndpZHRoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29vcnMgPSB7XG4gICAgICAgICAgICAgICAgJ3RvcCc6IG9yaWVudGF0aW9uTWFwW3RoaXMuX29wdGlvbnMuYWxpZ25dLFxuICAgICAgICAgICAgICAgICdsZWZ0Jzogb3JpZW50YXRpb25NYXBbc2lkZV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb29ycy50b3AgKz0gdGhpcy5fb3B0aW9ucy5vZmZzZXRZO1xuICAgICAgICBjb29ycy5sZWZ0ICs9IHRoaXMuX29wdGlvbnMub2Zmc2V0WDtcblxuICAgICAgICB0aGlzLnRhcmdldC5zdHlsZS50b3AgPSBjb29ycy50b3AgKyAncHgnO1xuICAgICAgICB0aGlzLnRhcmdldC5zdHlsZS5sZWZ0ID0gY29vcnMubGVmdCArICdweCc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNoLlBvc2l0aW9uZXIgPSBQb3NpdGlvbmVyO1xuXG59KHRoaXMsIHRoaXMuY2gpKTtcblxuKGZ1bmN0aW9uICh3aW5kb3csIGNoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgICBjb2RlTWFwID0ge1xuICAgICAgICAgICAgJzgnOiBjaC5vbmtleWJhY2tzcGFjZSxcbiAgICAgICAgICAgICc5JzogY2gub25rZXl0YWIsXG4gICAgICAgICAgICAnMTMnOiBjaC5vbmtleWVudGVyLFxuICAgICAgICAgICAgJzI3JzogY2gub25rZXllc2MsXG4gICAgICAgICAgICAnMzcnOiBjaC5vbmtleWxlZnRhcnJvdyxcbiAgICAgICAgICAgICczOCc6IGNoLm9ua2V5dXBhcnJvdyxcbiAgICAgICAgICAgICczOSc6IGNoLm9ua2V5cmlnaHRhcnJvdyxcbiAgICAgICAgICAgICc0MCc6IGNoLm9ua2V5ZG93bmFycm93XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0c1xuICAgICAgICAgKiBAbWVtYmVyb2YgY2hcbiAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvcnRjdXRzID0ge1xuXG4gICAgICAgICAgICAnX2FjdGl2ZSc6IG51bGwsXG5cbiAgICAgICAgICAgICdfcXVldWUnOiBbXSxcblxuICAgICAgICAgICAgJ19jb2xsZWN0aW9uJzoge30sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIGEgY2FsbGJhY2sgdG8gYSBzaG9ydGN1dCB3aXRoIGdpdmVuIG5hbWUuXG4gICAgICAgICAgICAgKiBAcGFyYW0geyhjaC5vbmtleWJhY2tzcGFjZSB8IGNoLm9ua2V5dGFiIHwgY2gub25rZXllbnRlciB8IGNoLm9ua2V5ZXNjIHwgY2gub25rZXlsZWZ0YXJyb3cgfCBjaC5vbmtleXVwYXJyb3cgfCBjaC5vbmtleXJpZ2h0YXJyb3cgfCBjaC5vbmtleWRvd25hcnJvdyl9IHNob3J0Y3V0IFNob3J0Y3V0IHRvIHN1YnNjcmliZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEEgbmFtZSB0byBhZGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGdpdmVuIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dW5zIHRoZSBjaC5zaG9ydGN1dHMuXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogLy8gQWRkIGEgY2FsbGJhY2sgdG8gRVNDIGtleSB3aXRoIFwiY29tcG9uZW50XCIgbmFtZS5cbiAgICAgICAgICAgICAqIGNoLnNob3J0Y3V0cy5hZGQoY2gub25rZXllc2MsICdjb21wb25lbnQnLCBjb21wb25lbnQuaGlkZSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdhZGQnOiBmdW5jdGlvbiAoc2hvcnRjdXQsIG5hbWUsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29sbGVjdGlvbltuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25bbmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29sbGVjdGlvbltuYW1lXVtzaG9ydGN1dF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uW25hbWVdW3Nob3J0Y3V0XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25bbmFtZV1bc2hvcnRjdXRdLnB1c2goY2FsbGJhY2spO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlcyBhIGNhbGxiYWNrIGZyb20gYSBzaG9ydGN1dCB3aXRoIGdpdmVuIG5hbWUuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBBIG5hbWUgdG8gcmVtb3ZlIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0geyhjaC5vbmtleWJhY2tzcGFjZSB8IGNoLm9ua2V5dGFiIHwgY2gub25rZXllbnRlciB8IGNoLm9ua2V5ZXNjIHwgY2gub25rZXlsZWZ0YXJyb3cgfCBjaC5vbmtleXVwYXJyb3cgfCBjaC5vbmtleXJpZ2h0YXJyb3cgfCBjaC5vbmtleWRvd25hcnJvdyl9IFtzaG9ydGN1dF0gU2hvcnRjdXQgdG8gdW5zdWJzY3JpYmUuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGdpdmVuIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dW5zIHRoZSBjaC5zaG9ydGN1dHMuXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogLy8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSBFU0Mga2V5IHdpdGggXCJjb21wb25lbnRcIiBuYW1lLlxuICAgICAgICAgICAgICogY2guc2hvcnRjdXRzLnJlbW92ZShjaC5vbmtleWVzYywgJ2NvbXBvbmVudCcsIGNvbXBvbmVudC5oaWRlKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ3JlbW92ZSc6IGZ1bmN0aW9uIChuYW1lLCBzaG9ydGN1dCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZ0LFxuICAgICAgICAgICAgICAgICAgICBldnRDb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBldnRDb2xsZWN0aW9uTGVuZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3J0Y3V0cyAtIFwicmVtb3ZlKG5hbWUsIHNob3J0Y3V0LCBjYWxsYmFjaylcIjogXCJuYW1lXCIgcGFyYW1ldGVyIG11c3QgYmUgZGVmaW5lZC4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hvcnRjdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fY29sbGVjdGlvbltuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbGxlY3Rpb25bbmFtZV1bc2hvcnRjdXRdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBldnRDb2xsZWN0aW9uID0gdGhpcy5fY29sbGVjdGlvbltuYW1lXVtzaG9ydGN1dF07XG5cbiAgICAgICAgICAgICAgICBldnRDb2xsZWN0aW9uTGVuZ2h0ID0gZXZ0Q29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGV2dCA9IDA7IGV2dCA8IGV2dENvbGxlY3Rpb25MZW5naHQ7IGV2dCArPSAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2dENvbGxlY3Rpb25bZXZ0XSA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dENvbGxlY3Rpb24uc3BsaWNlKGV2dCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUdXJuIG9uIHNob3J0Y3V0cyBhc3NvY2lhdGVkIHRvIGEgZ2l2ZW4gbmFtZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEEgZ2l2ZW4gbmFtZSBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dW5zIHRoZSBjaC5zaG9ydGN1dHMuXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogLy8gVHVybiBvbiBzaG9ydGN1dHMgYXNzb2NpYXRlZCB0byBcImNvbXBvbmVudFwiIG5hbWUuXG4gICAgICAgICAgICAgKiBjaC5zaG9ydGN1dHMub24oJ2NvbXBvbmVudCcpO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnb24nOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBxdWV1ZUxlbmd0aCA9IHRoaXMuX3F1ZXVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHF1ZXVlTGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBpbnN0YW5jZSBleGlzdCBhbmQgbW92ZSB0aGUgb3JkZXIsIGFkZHMgaXQgYXQgdGhlIGxhcyBwb3NpdGlvbiBhbmQgcmVtb3ZlcyB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgIGZvciAoaXRlbTsgaXRlbSA+PSAwOyBpdGVtIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3F1ZXVlW2l0ZW1dID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5zcGxpY2UoaXRlbSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IG5hbWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVHVybiBvZmYgc2hvcnRjdXRzIGFzc29jaWF0ZWQgdG8gYSBnaXZlbiBuYW1lLlxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgQSBnaXZlbiBuYW1lIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1bnMgdGhlIGNoLnNob3J0Y3V0cy5cbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAvLyBUdXJuIG9mZiBzaG9ydGN1dHMgYXNzb2NpYXRlZCB0byBcImNvbXBvbmVudFwiIG5hbWUuXG4gICAgICAgICAgICAgKiBjaC5zaG9ydGN1dHMub2ZmKCdjb21wb25lbnQnKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ29mZic6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXVlTGVuZ3RoID0gdGhpcy5fcXVldWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBpdGVtID0gcXVldWVMZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpdGVtOyBpdGVtID49IDA7IGl0ZW0gLT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcXVldWVbaXRlbV0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZXMgdGhlIGluc3RhbmNlIHRoYXQgSSdtIHNldHRpbmcgb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5zcGxpY2UoaXRlbSwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBxdWV1ZSBpcyBmdWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX3F1ZXVlW3RoaXMuX3F1ZXVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBxdWV1ZSBubyBoYXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3J0Y3V0c0VtaXR0ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHNob3J0Y3V0ID0gY29kZU1hcFtrZXlDb2RlXSxcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzTGVuZ2h0LFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBpZiAoc2hvcnRjdXQgIT09IHVuZGVmaW5lZCAmJiBzaG9ydGN1dHMuX2FjdGl2ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IHNob3J0Y3V0cy5fY29sbGVjdGlvbltzaG9ydGN1dHMuX2FjdGl2ZV1bc2hvcnRjdXRdO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQuc2hvcnRjdXQgPSBzaG9ydGN1dDtcblxuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrcyAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzTGVuZ2h0ID0gY2FsbGJhY2tzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2FsbGJhY2tzTGVuZ2h0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXShldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgdGlueS5vbihkb2N1bWVudCwgJ2tleWRvd24nLCBzaG9ydGN1dHNFbWl0dGVyKTtcblxuICAgIGNoLnNob3J0Y3V0cyA9IHNob3J0Y3V0cztcblxufSh0aGlzLCB0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAod2luZG93LCBjaCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciB1aWQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQmFzZSBjbGFzcyBmb3IgYWxsIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgY2hcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgdGlueS5FdmVudEVtaXR0ZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbZWxdIEl0IG11c3QgYmUgYSBIVE1MRWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7Y29tcG9uZW50fSBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIENvbXBvbmVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBDb21wb25lbnQuXG4gICAgICogdmFyIGNvbXBvbmVudCA9IG5ldyBjaC5Db21wb25lbnQoKTtcbiAgICAgKiB2YXIgY29tcG9uZW50ID0gbmV3IGNoLkNvbXBvbmVudCgnLm15LWNvbXBvbmVudCcsIHsnb3B0aW9uJzogJ3ZhbHVlJ30pO1xuICAgICAqIHZhciBjb21wb25lbnQgPSBuZXcgY2guQ29tcG9uZW50KCcubXktY29tcG9uZW50Jyk7XG4gICAgICogdmFyIGNvbXBvbmVudCA9IG5ldyBjaC5Db21wb25lbnQoeydvcHRpb24nOiAndmFsdWUnfSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KGVsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2luaXQoZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB5b3UgZGVmaW5lIGFuIGluaXRpYWxpemUgbWV0aG9kLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYSBuZXcgRXhwYW5kYWJsZSBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mISBjaC5FeHBhbmRhYmxlLnByb3RvdHlwZVxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHJlYWR5IHRvIHVzZS5cbiAgICAgICAgICogQGV2ZW50IGNoLkNvbXBvbmVudCNyZWFkeVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJyZWFkeVwiIGV2ZW50LlxuICAgICAgICAgKiBjb21wb25lbnQub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aGF0LmVtaXQoJ3JlYWR5Jyk7IH0sIDUwKTtcbiAgICB9XG5cbiAgICB0aW55LmluaGVyaXRzKENvbXBvbmVudCwgdGlueS5FdmVudEVtaXR0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgYSBjb21wb25lbnQuXG4gICAgICogQG1lbWJlcm9mISBjaC5Db21wb25lbnQucHJvdG90eXBlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLm5hbWUgPSAnY29tcG9uZW50JztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ29tcG9uZW50LnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IGluc3RhbmNlIG9mIENvbXBvbmVudCBhbmQgbWVyZ2UgY3VzdG9tIG9wdGlvbnMgd2l0aCBkZWZhdWx0cyBvcHRpb25zLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ29tcG9uZW50LnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge2NvbXBvbmVudH1cbiAgICAgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFNldCBlbWl0dGVyIHRvIHplcm8gZm9yIHVubGltaXRlZCBsaXN0ZW5lcnMgdG8gYXZvaWQgdGhlIHdhcm5pbmcgaW4gY29uc29sZVxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2VtaXR0ZXJfc2V0bWF4bGlzdGVuZXJzX25cbiAgICAgICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMCk7XG5cbiAgICAgICAgLy8gQ2xvbmVzIGRlZmF1bHRzIG9yIGNyZWF0ZXMgYSBkZWZhdWx0cyBvYmplY3RcbiAgICAgICAgdmFyIGRlZmF1bHRzID0gKHRoaXMuX2RlZmF1bHRzKSA/IHRpbnkuY2xvbmUodGhpcy5fZGVmYXVsdHMpIDoge307XG5cbiAgICAgICAgaWYgKGVsID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcImVsXCIgcGFyYW1ldGVyIGlzIG5vdCBwcmVzZW50IGluIHRoZSBET00nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHVuaXF1ZSBpZCB0byBpZGVudGlmeSB0aGUgaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVpZCA9ICh1aWQgKz0gMSk7XG5cbiAgICAgICAgLy8gZWwgaXMgSFRNTEVsZW1lbnRcbiAgICAgICAgLy8gSUU4IGFuZCBlYXJsaWVyIGRvbid0IGRlZmluZSB0aGUgbm9kZSB0eXBlIGNvbnN0YW50cywgMSA9PT0gZG9jdW1lbnQuRUxFTUVOVF9OT0RFXG4gICAgICAgIGlmIChlbCAhPT0gdW5kZWZpbmVkICYmIGVsLm5vZGVUeXBlICE9PSB1bmRlZmluZWQgJiYgZWwubm9kZVR5cGUgPT09IDEpIHtcblxuICAgICAgICAgICAgdGhpcy5fZWwgPSBlbDtcblxuICAgICAgICAgICAgLy8gc2V0IHRoZSB1aWQgdG8gdGhlIGVsZW1lbnQgdG8gaGVscCBzZWFyY2ggZm9yIHRoZSBpbnN0YW5jZSBpbiB0aGUgY29sbGVjdGlvbiBpbnN0YW5jZXNcbiAgICAgICAgICAgIHRoaXMuX2VsLnNldEF0dHJpYnV0ZSgnZGF0YS11aWQnLCB0aGlzLnVpZCk7XG5cbiAgICAgICAgICAgIC8vIHdlIGV4dGVuZCBkZWZhdWx0cyB3aXRoIG9wdGlvbnMgcGFyYW1ldGVyXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zID0gdGlueS5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGVsIGlzIGFuIG9iamVjdCBjb25maWd1cmF0aW9uXG4gICAgICAgIH0gZWxzZSBpZiAoZWwgPT09IHVuZGVmaW5lZCB8fCBlbC5ub2RlVHlwZSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbCA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgLy8gY3JlYXRlcyBhIGVtcHR5IGVsZW1lbnQgYmVjb3VzZSB0aGUgdXNlciBub3Qgc2V0IGEgRE9NIGVsbWVudCB0byB1c2UsIGJ1dCB3ZSByZXF1aXJlcyBvbmVcbiAgICAgICAgICAgIC8vIHRoaXMuX2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgIC8vIHdlIGV4dGVuZCBkZWZhdWx0cyB3aXRoIHRoZSBvYmplY3QgdGhhdCBpcyBpbiBlbCBwYXJhbWV0ZXIgb2JqZWN0XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zID0gdGlueS5leHRlbmQoZGVmYXVsdHMsIGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgYSBjb21wb25lbnQgaXMgZW5hYmxlZC5cbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIGFsbCBpbnN0YW5jZXMgY3JlYXRlZFxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICBjaC5pbnN0YW5jZXMgPSBjaC5pbnN0YW5jZXMgfHwge307XG4gICAgICAgIGNoLmluc3RhbmNlc1t0aGlzLnVpZF0gPSB0aGlzO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZnVuY3Rpb25hbGl0eSBvciBhYmlsaXRpZXMgZnJvbSBvdGhlciBjbGFzc2VzLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ29tcG9uZW50LnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtjb21wb25lbnR9XG4gICAgICogQHBhcmFtcyB7Li4uU3RyaW5nfSB2YXJfYXJncyBUaGUgbmFtZSBvZiB0aGUgYWJpbGl0aWVzIHRvIHdpbGwgYmUgdXNlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFlvdSBjYW4gcmVxdWlyZSBzb21lIGFiaWxpdGllc3QgdG8gdXNlIGluIHlvdXIgY29tcG9uZW50LlxuICAgICAqIC8vIEZvciBleGFtcGxlIHlvdSBzaG91bGQgcmVxdWlyZSB0aGUgY29sbHBhc2libGUgYWJpdGxpeS5cbiAgICAgKiB2YXIgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgKiBjb21wb25lbnQucmVxdWlyZSgnQ29sbGFwc2libGUnKTtcbiAgICAgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLnJlcXVpcmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIGFyZyxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgICAgICBpZiAodGhpc1thcmcudG9Mb3dlckNhc2UoKV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNoW2FyZ10uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGFuIGluc3RhbmNlIG9mIENvbXBvbmVudC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNvbXBvbmVudC5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Y29tcG9uZW50fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRW5hYmxpbmcgYW4gaW5zdGFuY2Ugb2YgQ29tcG9uZW50LlxuICAgICAqIGNvbXBvbmVudC5lbmFibGUoKTtcbiAgICAgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gYSBjb21wb25lbnQgaXMgZW5hYmxlZC5cbiAgICAgICAgICogQGV2ZW50IGNoLkNvbXBvbmVudCNlbmFibGVcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwiZW5hYmxlXCIgZXZlbnQuXG4gICAgICAgICAqIGNvbXBvbmVudC5vbignZW5hYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWl0KCdlbmFibGUnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgYW4gaW5zdGFuY2Ugb2YgQ29tcG9uZW50LlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ29tcG9uZW50LnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtjb21wb25lbnR9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBEaXNhYmxpbmcgYW4gaW5zdGFuY2Ugb2YgQ29tcG9uZW50LlxuICAgICAqIGNvbXBvbmVudC5kaXNhYmxlKCk7XG4gICAgICovXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gYSBjb21wb25lbnQgaXMgZGlzYWJsZS5cbiAgICAgICAgICogQGV2ZW50IGNoLkNvbXBvbmVudCNkaXNhYmxlXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcImRpc2FibGVcIiBldmVudC5cbiAgICAgICAgICogY29tcG9uZW50Lm9uKCdkaXNhYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWl0KCdkaXNhYmxlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIENvbXBvbmVudCBhbmQgcmVtb3ZlIGl0cyBkYXRhIGZyb20gYXNvY2lhdGVkIGVsZW1lbnQuXG4gICAgICogQG1lbWJlcm9mISBjaC5Db21wb25lbnQucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBEZXN0cm95IGEgY29tcG9uZW50XG4gICAgICogY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgKiAvLyBFbXB0eSB0aGUgY29tcG9uZW50IHJlZmVyZW5jZVxuICAgICAqIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcbiAgICAgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjaC5pbnN0YW5jZXNbdGhpcy5fZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXVpZCcpXTtcbiAgICAgICAgICAgIHRoaXMuX2VsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS11aWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICogQGV2ZW50IGNoLkNvbXBvbmVudCNkZXN0cm95XG4gICAgICAgICAqIEBleGFtcGxlRGVzY3JpcHRpb25cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwiZGVzdHJveVwiIGV2ZW50LlxuICAgICAgICAgKiBjb21wb25lbnQub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIGNoLkNvbXBvbmVudCA9IENvbXBvbmVudDtcblxufSh0aGlzLCB0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAod2luZG93LCBjaCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEZvcm0gaXMgYSBjb250cm9sbGVyIG9mIERPTSdzIEhUTUxGb3JtRWxlbWVudC5cbiAgICAgKiBAbWVtYmVyb2YgY2hcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgY2guQ29tcG9uZW50XG4gICAgICogQHJlcXVpcmVzIGNoLlZhbGlkYXRpb25zXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgQSBIVE1MRWxlbWVudCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgY2guRm9ybS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gY3VzdG9taXplIGFuIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tZXNzYWdlc10gQSBjb2xsZWN0aW9ucyBvZiB2YWxpZGF0aW9ucyBtZXNzYWdlcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZXMucmVxdWlyZWRdIEEgdmFsaWRhdGlvbiBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlcy5zdHJpbmddIEEgdmFsaWRhdGlvbiBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlcy51cmxdIEEgdmFsaWRhdGlvbiBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlcy5lbWFpbF0gQSB2YWxpZGF0aW9uIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VzLm1heExlbmd0aF0gQSB2YWxpZGF0aW9uIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VzLm1pbkxlbmd0aF0gQSB2YWxpZGF0aW9uIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VzLmN1c3RvbV0gQSB2YWxpZGF0aW9uIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VzLm51bWJlcl0gQSB2YWxpZGF0aW9uIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VzLm1pbl0gQSB2YWxpZGF0aW9uIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VzLm1heF0gQSB2YWxpZGF0aW9uIG1lc3NhZ2UuXG4gICAgICogQHJldHVybnMge2Zvcm19IFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgRm9ybS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBGb3JtLlxuICAgICAqIHZhciBmb3JtID0gbmV3IGNoLkZvcm0oZWwsIFtvcHRpb25zXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgRm9ybSB3aXRoIGN1c3RvbSBtZXNzYWdlcy5cbiAgICAgKiB2YXIgZm9ybSA9IG5ldyBjaC5Gb3JtKHtcbiAgICAgKiAgICAgJ21lc3NhZ2VzJzoge1xuICAgICAqICAgICAgICAgICdyZXF1aXJlZCc6ICdTb21lIG1lc3NhZ2UhJyxcbiAgICAgKiAgICAgICAgICAnZW1haWwnOiAnQW5vdGhlciBtZXNzYWdlISdcbiAgICAgKiAgICAgfVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZvcm0oZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhhdC5faW5pdChlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHlvdSBkZWZpbmUgYW4gaW5pdGlhbGl6ZSBtZXRob2QsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhIG5ldyBGb3JtIGlzIGNyZWF0ZWQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YhIGNoLkZvcm0ucHJvdG90eXBlXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXQgZW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgZm9ybSBpcyByZWFkeSB0byB1c2UuXG4gICAgICAgICAqIEBldmVudCBjaC5Gb3JtI3JlYWR5XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcInJlYWR5XCIgZXZlbnQuXG4gICAgICAgICAqIGZvcm0ub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aGF0LmVtaXQoJ3JlYWR5Jyk7IH0sIDUwKTtcbiAgICB9XG5cbiAgICAvLyBJbmhlcml0YW5jZVxuICAgIHRpbnkuaW5oZXJpdHMoRm9ybSwgY2guQ29tcG9uZW50KTtcblxuICAgIHZhciBwYXJlbnQgPSBGb3JtLnN1cGVyXy5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBtZW1iZXJvZiEgY2guRm9ybS5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIEZvcm0ucHJvdG90eXBlLm5hbWUgPSAnZm9ybSc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkZvcm0ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgRm9ybS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGb3JtO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBpbnN0YW5jZSBvZiBGb3JtIGFuZCBtZXJnZSBjdXN0b20gb3B0aW9ucyB3aXRoIGRlZmF1bHRzIG9wdGlvbnMuXG4gICAgICogQG1lbWJlcm9mISBjaC5Gb3JtLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge2Zvcm19XG4gICAgICovXG4gICAgRm9ybS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ2FsbCB0byBpdHMgcGFyZW50IGluaXQgbWV0aG9kXG4gICAgICAgIHBhcmVudC5faW5pdC5jYWxsKHRoaXMsIGVsLCBvcHRpb25zKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY29sbGVjdGlvbiBvZiBhY3RpdmUgZXJyb3JzLlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGRlZmluZWQgbWVzc2FnZXMuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IHRoaXMuX29wdGlvbnMubWVzc2FnZXMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY29sbGVjdGlvbiBvZiB2YWxpZGF0aW9ucyBpbnN0YW5jZXMuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsaWRhdGlvbnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvcm0gY29udGFpbmVyLlxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuX2VsO1xuICAgICAgICAgICAgLy8gQWRkIGNsYXNzbmFtZVxuICAgICAgICB0aW55LmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCAnY2gtZm9ybScpO1xuICAgICAgICAgICAgLy8gRGlzYWJsZSBIVE1MNSBicm93c2VyLW5hdGl2ZSB2YWxpZGF0aW9uc1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ25vdmFsaWRhdGUnLCAnbm92YWxpZGF0ZScpO1xuICAgICAgICAgICAgLy8gQmluZCB0aGUgc3VibWl0XG4gICAgICAgIHRpbnkub24odGhpcy5jb250YWluZXIsICdzdWJtaXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFJ1bnMgdmFsaWRhdGlvbnNcbiAgICAgICAgICAgIHRoYXQudmFsaWRhdGUoZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBCaW5kIHRoZSByZXNldFxuICAgICAgICBpZiAodGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cInJlc2V0XCJdJykpIHtcbiAgICAgICAgICAgIHRpbnkub24odGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cInJlc2V0XCJdJyksIGNoLm9ucG9pbnRlcnRhcCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGF0LnJlc2V0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHViIGZvciBFdmVudEVtaXR0ZXIgdG8gcHJldmVudCB0aGUgZXJyb3JzIHRocm93aW5nXG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24oKXt9KTtcblxuICAgICAgICAvLyBDbGVhbiB2YWxpZGF0aW9uc1xuICAgICAgICB0aGlzLm9uKCdkaXNhYmxlJywgdGhpcy5jbGVhcik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGFsbCB2YWxpZGF0aW9ucy5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkZvcm0ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2Zvcm19XG4gICAgICovXG4gICAgRm9ybS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0IGVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIGZvcm0gd2lsbCBiZSB2YWxpZGF0ZWQuXG4gICAgICAgICAqIEBldmVudCBjaC5Gb3JtI2JlZm9yZXZhbGlkYXRlXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcImJlZm9yZXZhbGlkYXRlXCIgZXZlbnQuXG4gICAgICAgICAqIGNvbXBvbmVudC5vbignYmVmb3JldmFsaWRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoJ2JlZm9yZXZhbGlkYXRlJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBqID0gdGhhdC52YWxpZGF0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICB2YWxpZGF0aW9uLFxuICAgICAgICAgICAgZmlyc3RFcnJvcixcbiAgICAgICAgICAgIGZpcnN0RXJyb3JWaXNpYmxlLFxuICAgICAgICAgICAgdHJpZ2dlckVycm9yO1xuXG4gICAgICAgIHRoaXMuZXJyb3JzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgLy8gUnVuIHZhbGlkYXRpb25zXG4gICAgICAgIGZvciAoaTsgaSA8IGo7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFsaWRhdGlvbiA9IHRoYXQudmFsaWRhdGlvbnNbaV07XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlXG4gICAgICAgICAgICB2YWxpZGF0aW9uLnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHZhbGlkYXRpb25zIHdpdGggZXJyb3JzXG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbi5pc1Nob3duKCkpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmVycm9ycy5wdXNoKHZhbGlkYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXMgdGhlcmUncyBhbiBlcnJvclxuICAgICAgICBpZiAodGhhdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZmlyc3RFcnJvciA9IHRoYXQuZXJyb3JzWzBdO1xuICAgICAgICAgICAgZmlyc3RFcnJvclZpc2libGUgPSBmaXJzdEVycm9yLnRyaWdnZXI7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgdmlzaWJsZSBwYXJlbnQgaWYgY3VycmVudCBlbGVtZW50IGlzIGhpZGRlblxuICAgICAgICAgICAgd2hpbGUgKHRpbnkuY3NzKGZpcnN0RXJyb3JWaXNpYmxlLCAnZGlzcGxheScpID09PSAnbm9uZScgJiYgZmlyc3RFcnJvclZpc2libGUgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGZpcnN0RXJyb3JWaXNpYmxlID0gZmlyc3RFcnJvclZpc2libGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlyc3RFcnJvclZpc2libGUuc2Nyb2xsSW50b1ZpZXcoKTtcblxuICAgICAgICAgICAgLy8gSXNzdWUgVUktMzMyOiBPbiB2YWxpZGF0aW9uIG11c3QgZm9jdXMgdGhlIGZpcnN0IGZpZWxkIHdpdGggZXJyb3JzLlxuICAgICAgICAgICAgLy8gRG9jOiBodHRwOi8vd2lraS5tbC5jb20vZGlzcGxheS91eC9NZW5zYWplcytkZStlcnJvclxuICAgICAgICAgICAgdHJpZ2dlckVycm9yID0gZmlyc3RFcnJvci50cmlnZ2VyO1xuXG4gICAgICAgICAgICBpZiAodHJpZ2dlckVycm9yLnRhZ05hbWUgPT09ICdESVYnKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RFcnJvci50cmlnZ2VyLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0OmZpcnN0LWNoaWxkJykuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRyaWdnZXJFcnJvci50eXBlICE9PSAnaGlkZGVuJyB8fCB0cmlnZ2VyRXJyb3IudGFnTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXJyb3IuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJdCBlbWl0cyBhbiBldmVudCB3aGVuIGEgZm9ybSBoYXMgZ290IGVycm9ycy5cbiAgICAgICAgICAgICAqIEBldmVudCBjaC5Gb3JtI2Vycm9yXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwiZXJyb3JcIiBldmVudC5cbiAgICAgICAgICAgICAqIGZvcm0ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9ycykge1xuICAgICAgICAgICAgICogICAgIGNvbnNvbGUubG9nKGVycm9ycy5sZW5ndGgpO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB0aGlzLmVycm9ycyk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJdCBlbWl0cyBhbiBldmVudCB3aGVuIGEgZm9ybSBoYXNuJ3QgZ290IGVycm9ycy5cbiAgICAgICAgICAgICAqIEBldmVudCBjaC5Gb3JtI3N1Y2Nlc3NcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJzdWNjZXNzXCIgZXZlbnQuXG4gICAgICAgICAgICAgKiBmb3JtLm9uKFwic3VibWl0XCIsZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwic3VjY2Vzc1wiIGV2ZW50IGFuZCBwcmV2ZW50IHRoZSBzdWJtaXQgZXZlbnQuXG4gICAgICAgICAgICAgKiBmb3JtLm9uKFwic3VibWl0XCIsZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgKiAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N1Y2Nlc3MnLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBmb3JtIGhhcyBnb3QgZXJyb3JzIGJ1dCBpdCBkb2Vzbid0IHNob3cgYnViYmxlcy5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkZvcm0ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDaGVja3MgaWYgYSBmb3JtIGhhcyBlcnJvcnMgYW5kIGRvIHNvbWV0aGluZy5cbiAgICAgKiBpZiAoZm9ybS5oYXNFcnJvcigpKSB7XG4gICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAqIH07XG4gICAgICovXG4gICAgRm9ybS5wcm90b3R5cGUuaGFzRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVycm9ycy5sZW5ndGggPSAwO1xuXG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGogPSB0aGlzLnZhbGlkYXRpb25zLmxlbmd0aCxcbiAgICAgICAgICAgIHZhbGlkYXRpb247XG5cbiAgICAgICAgLy8gUnVuIGhhc0Vycm9yXG4gICAgICAgIGZvciAoaTsgaSA8IGo7IGkgKz0gMSkge1xuXG4gICAgICAgICAgICB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0aW9uc1tpXTtcblxuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb24uaGFzRXJyb3IoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2godmFsaWRhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9ycy5sZW5ndGggPiAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgYWN0aXZlIGVycm9ycy5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkZvcm0ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2Zvcm19XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDbGVhciBhY3RpdmUgZXJyb3JzLlxuICAgICAqIGZvcm0uY2xlYXIoKTtcbiAgICAgKi9cbiAgICBGb3JtLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgaiA9IHRoaXMudmFsaWRhdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaTsgaSA8IGo7IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0aW9uc1tpXS5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0IGVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIGZvcm0gaXMgY2xlYW5lZC5cbiAgICAgICAgICogQGV2ZW50IGNoLkZvcm0jY2xlYXJcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwiY2xlYXJcIiBldmVudC5cbiAgICAgICAgICogZm9ybS5vbignY2xlYXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoJ2NsZWFyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBhY3RpdmUgZXJyb3JzIGFuZCBleGVjdXRlcyB0aGUgcmVzZXQoKSBuYXRpdmUgbWVodG9kLlxuICAgICAqIEBtZW1iZXJvZiEgY2guRm9ybS5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Zm9ybX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFJlc2V0cyBmb3JtIGZpZWxkcyBhbmQgY2xlYXJzIGFjdGl2ZSBlcnJvcnMuXG4gICAgICogZm9ybS5yZXNldCgpO1xuICAgICAqL1xuICAgIEZvcm0ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8vIENsZWFycyBhbGwgc2hvd24gdmFsaWRhdGlvbnNcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgIC8vIEV4ZWN1dGVzIHRoZSBuYXRpdmUgcmVzZXQoKSBtZXRob2RcbiAgICAgICAgdGhpcy5fZWwucmVzZXQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXQgZW1pdHMgYW4gZXZlbnQgd2hlbiBhIGZvcm0gcmVzZXRzIGl0cyBmaWVsZHMuXG4gICAgICAgICAqIEBldmVudCBjaC5Gb3JtI3Jlc2V0XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcInJlc2V0XCIgZXZlbnQuXG4gICAgICAgICAqIGZvcm0ub24oJ3Jlc2V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWl0KCdyZXNldCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhIEZvcm0gaW5zdGFuY2UuXG4gICAgICogQG1lbWJlcm9mISBjaC5Gb3JtLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRGVzdHJveSBhIGZvcm1cbiAgICAgKiBmb3JtLmRlc3Ryb3koKTtcbiAgICAgKiAvLyBFbXB0eSB0aGUgZm9ybSByZWZlcmVuY2VcbiAgICAgKiBmb3JtID0gdW5kZWZpbmVkO1xuICAgICAqL1xuICAgIEZvcm0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLy8gdGhpcy4kY29udGFpbmVyLm9mZignLmZvcm0nKVxuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ25vdmFsaWRhdGUnKTtcblxuICAgICAgICB0aGlzLnZhbGlkYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuZGVzdHJveSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwYXJlbnQuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgLy8gRmFjdG9yaXplXG4gICAgY2guZmFjdG9yeShGb3JtKTtcblxufSh0aGlzLCB0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAoY2gpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBQcml2YXRlIE1lbWJlcnNcbiAgICB2YXIgY29uZGl0aW9ucyA9IHtcbiAgICAgICAgJ3N0cmluZyc6IHtcbiAgICAgICAgICAgICdmbic6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgcmVndWxhciBleHByZXNzaW9uIGhhcyB0aGUgdXRmIGNvZGUgZm9yIHRoZSBsYXRpbmcgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgIC8vIHRoZSByYW5nZXMgYXJlIEEsRUksTyxVLGEsZWksbyx1LMOnLMOHIHBsZWFzZSBmb3IgcmVmZXJlbmNlIHNlZSBodHRwOi8vd3d3LmZpbGVmb3JtYXQuaW5mby9pbmZvL2NoYXJzZXQvVVRGLTgvbGlzdC5odG1cbiAgICAgICAgICAgICAgICByZXR1cm4gKC9eKFthLXpBLVpcXHUwMEMwLVxcdTAwQzRcXHUwMEM4LVxcdTAwQ0ZcXHUwMEQyLVxcdTAwRDZcXHUwMEQ5LVxcdTAwRENcXHUwMEUwLVxcdTAwRTRcXHUwMEU4LVxcdTAwRUZcXHUwMEYyLVxcdTAwRjZcXHUwMEU5LVxcdTAwRkNcXHUwMEM3XFx1MDBFN1xcc10qKSQvaSkudGVzdCh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21lc3NhZ2UnOiAnVXNlIG9ubHkgbGV0dGVycy4nXG4gICAgICAgIH0sXG4gICAgICAgICdlbWFpbCc6IHtcbiAgICAgICAgICAgICdmbic6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoL14oKFtePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC8pLnRlc3QodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtZXNzYWdlJzogJ1VzZSBhIHZhbGlkIGUtbWFpbCBzdWNoIGFzIG5hbWVAZXhhbXBsZS5jb20uJ1xuICAgICAgICB9LFxuICAgICAgICAndXJsJzoge1xuICAgICAgICAgICAgJ2ZuJzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgvXigoaHR0cHM/fGZ0cHxmaWxlKTpcXC9cXC98KCh3d3d8ZnRwKVxcLil8KFxcL3wuKlxcLykqKVthLXowLTktXSsoKFxcLnxcXC8pW2EtejAtOS1dKykrKFsvP10uKik/JC9pKS50ZXN0KHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWVzc2FnZSc6ICdJdCBtdXN0IGJlIGEgdmFsaWQgVVJMLidcbiAgICAgICAgfSxcbiAgICAgICAgJ21pbkxlbmd0aCc6IHtcbiAgICAgICAgICAgICdmbic6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmxlbmd0aCA+PSBiOyB9LFxuICAgICAgICAgICAgJ21lc3NhZ2UnOiAnRW50ZXIgYXQgbGVhc3QgeyNudW0jfSBjaGFyYWN0ZXJzLidcbiAgICAgICAgfSxcbiAgICAgICAgJ21heExlbmd0aCc6IHtcbiAgICAgICAgICAgICdmbic6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmxlbmd0aCA8PSBiOyB9LFxuICAgICAgICAgICAgJ21lc3NhZ2UnOiAnVGhlIG1heGltdW0gYW1vdW50IG9mIGNoYXJhY3RlcnMgaXMgeyNudW0jfS4nXG4gICAgICAgIH0sXG4gICAgICAgICdudW1iZXInOiB7XG4gICAgICAgICAgICAnZm4nOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKC9eKC0/WzAtOV0rKSQvaSkudGVzdCh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21lc3NhZ2UnOiAnVXNlIG9ubHkgbnVtYmVycy4nXG4gICAgICAgIH0sXG4gICAgICAgICdtYXgnOiB7XG4gICAgICAgICAgICAnZm4nOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA8PSBiOyB9LFxuICAgICAgICAgICAgJ21lc3NhZ2UnOiAnVGhlIGFtb3VudCBtdXN0IGJlIHNtYWxsZXIgdGhhbiB7I251bSN9LidcbiAgICAgICAgfSxcbiAgICAgICAgJ21pbic6IHtcbiAgICAgICAgICAgICdmbic6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhID49IGI7IH0sXG4gICAgICAgICAgICAnbWVzc2FnZSc6ICdUaGUgYW1vdW50IG11c3QgYmUgaGlnaGVyIHRoYW4geyNudW0jfS4nXG4gICAgICAgIH0sXG4gICAgICAgICdyZXF1aXJlZCc6IHtcbiAgICAgICAgICAgICdmbic6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHRpbnkuaGFzQ2xhc3ModGhpcy50cmlnZ2VyLCAnY2gtZm9ybS1vcHRpb25zJykgPyAnT1BUSU9OUycgOiB0aGlzLl9lbC50YWdOYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWQ7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ09QVElPTlMnOlxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWQgPSB0aGlzLnRyaWdnZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQ6Y2hlY2tlZCcpLmxlbmd0aCAhPT0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdTRUxFQ1QnOlxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWQgPSAodmFsdWUgIT09ICctMScgJiYgdmFsdWUgIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvLyBJTlBVVFMgYW5kIFRFWFRBUkVBU1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZCA9IHZhbHVlLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKS5sZW5ndGggIT09IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21lc3NhZ2UnOiAnRmlsbCBpbiB0aGlzIGluZm9ybWF0aW9uLidcbiAgICAgICAgfSxcbiAgICAgICAgJ2N1c3RvbSc6IHtcbiAgICAgICAgICAgIC8vIEkgZG9uJ3QgaGF2ZSBwcmUtY29uZGl0aW9ucywgY29tZXMgd2l0aGluIGNvbmYuZm4gYXJndW1lbnRcbiAgICAgICAgICAgICdtZXNzYWdlJzogJ0Vycm9yJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbmRpdGlvbiB1dGlsaXR5LlxuICAgICAqIEBtZW1iZXJvZiBjaFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEByZXF1aXJlcyBjaC5WYWxpZGF0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmRpdGlvbl0gQSBjb25kaXRpb25zIHRvIHZhbGlkYXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZGl0aW9uLm5hbWVdIFRoZSBuYW1lIG9mIHRoZSBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25kaXRpb24ubWVzc2FnZV0gVGhlIGdpdmVuIGVycm9yIG1lc3NhZ2UgdG8gdGhlIGNvbmRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmRpdGlvbi5mbl0gVGhlIG1ldGhvZCB0byB2YWxpZGF0ZSBhIGdpdmVuIGNvbmRpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Y29uZGl0aW9ufSBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIENvbmRpdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBjb25kaXRpb24gb2JqZWN0IHdpdGggcGF0dC5cbiAgICAgKiB2YXIgY29uZGl0aW9uID0gY2guQ29uZGl0aW9uKHtcbiAgICAgKiAgICAgJ25hbWUnOiAnc3RyaW5nJyxcbiAgICAgKiAgICAgJ3BhdHQnOiAvXihbYS16QS1aXFx1MDBDMC1cXHUwMEM0XFx1MDBDOC1cXHUwMENGXFx1MDBEMi1cXHUwMEQ2XFx1MDBEOS1cXHUwMERDXFx1MDBFMC1cXHUwMEU0XFx1MDBFOC1cXHUwMEVGXFx1MDBGMi1cXHUwMEY2XFx1MDBFOS1cXHUwMEZDXFx1MDBDN1xcdTAwRTdcXHNdKikkLyxcbiAgICAgKiAgICAgJ21lc3NhZ2UnOiAnU29tZSBtZXNzYWdlIGhlcmUhJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy9DcmVhdGUgYSBuZXcgY29uZGl0aW9uIG9iamVjdCB3aXRoIGV4cHIuXG4gICAgICogdmFyIGNvbmRpdGlvbiA9IGNoLkNvbmRpdGlvbih7XG4gICAgICogICAgICduYW1lJzogJ21heExlbmd0aCcsXG4gICAgICogICAgICdwYXR0JzogZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhLmxlbmd0aCA8PSBiIH0sXG4gICAgICogICAgICdtZXNzYWdlJzogJ1NvbWUgbWVzc2FnZSBoZXJlIScsXG4gICAgICogICAgICd2YWx1ZSc6IDRcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBjb25kaXRpb24gb2JqZWN0IHdpdGggZnVuYy5cbiAgICAgKiB2YXIgY29uZGl0aW9uID0gY2guQ29uZGl0aW9uKHtcbiAgICAgKiAgICAgJ25hbWUnOiAnY3VzdG9tJyxcbiAgICAgKiAgICAgJ3BhdHQnOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgKiAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ0NoaWNvVUknKSB7XG4gICAgICpcbiAgICAgKiAgICAgICAgICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgKlxuICAgICAqICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgICAgICAgfTtcbiAgICAgKlxuICAgICAqICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAqICAgICB9LFxuICAgICAqICAgICAnbWVzc2FnZSc6ICdZb3VyIG1lc3NhZ2UgaGVyZSEnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29uZGl0aW9uKGNvbmRpdGlvbikge1xuXG4gICAgICAgIHRpbnkuZXh0ZW5kKHRoaXMsIGNvbmRpdGlvbnNbY29uZGl0aW9uLm5hbWVdLCBjb25kaXRpb24pO1xuXG4gICAgICAgIC8vIHJlcGxhY2VzIHRoZSBjb25kaXRpb24gZGVmYXVsdCBtZXNzYWdlIGluIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBtYXgsIG1pbiwgbWluTGVuZ2h0LCBtYXhMZW5naHRcbiAgICAgICAgaWYgKHRoaXMubmFtZSA9PT0gJ21pbicgfHwgdGhpcy5uYW1lID09PSAnbWF4JyB8fCB0aGlzLm5hbWUgPT09ICdtaW5MZW5ndGgnIHx8IHRoaXMubmFtZSA9PT0gJ21heExlbmd0aCcpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMubWVzc2FnZS5yZXBsYWNlKCd7I251bSN9JywgdGhpcy5udW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNvbmRpdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIENvbmRpdGlvbi5wcm90b3R5cGUubmFtZSA9ICdjb25kaXRpb24nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQG1lbWJlcm9mISBjaC5Db25kaXRpb24ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgQ29uZGl0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmRpdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgYW4gaW5zdGFuY2Ugb2YgY29uZGl0aW9uLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ29uZGl0aW9uLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtjb25kaXRpb259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBFbmFibGluZyBhbiBpbnN0YW5jZSBvZiBDb25kaXRpb24uXG4gICAgICogY29uZGl0aW9uLmVuYWJsZSgpO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRW5hYmxpbmcgYSBjb25kaXRpb24uXG4gICAgICogY29uZGl0aW9uLmVuYWJsZSgpO1xuICAgICAqL1xuICAgIENvbmRpdGlvbi5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgYW4gaW5zdGFuY2Ugb2YgYSBjb25kaXRpb24uXG4gICAgICogQG1lbWJlcm9mISBjaC5Db25kaXRpb24ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2NvbmRpdGlvbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIERpc2FibGluZyBhbiBpbnN0YW5jZSBvZiBDb25kaXRpb24uXG4gICAgICogY29uZGl0aW9uLmRpc2FibGUoKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIERpc2FibGluZyBhIGNvbmRpdGlvbi5cbiAgICAgKiBjb25kaXRpb24uZGlzYWJsZSgpO1xuICAgICAqL1xuICAgIENvbmRpdGlvbi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGFuIGluc3RhbmNlIG9mIGNvbmRpdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNvbmRpdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyhTdHJpbmcgfCBOdW1iZXIpfSB2YWx1ZSBBIGdpdmVuIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Y29uZGl0aW9ufSB2YWxpZGF0aW9uIEEgZ2l2ZW4gdmFsaWRhdGlvbiB0byBleGVjdXRlLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbmRpdGlvbiBmYWlscyBvciBub3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBUZXN0aW5nIGEgY29uZGl0aW9uLlxuICAgICAqIGNvbmRpdGlvbi50ZXN0KCdmb29iYXInLCB2YWxpZGF0aW9uQSk7XG4gICAgICovXG4gICAgQ29uZGl0aW9uLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKHZhbHVlLCB2YWxpZGF0aW9uKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZuLmNhbGwodmFsaWRhdGlvbiwgdmFsdWUsIHRoaXMubnVtKTtcbiAgICB9O1xuXG4gICAgY2guQ29uZGl0aW9uID0gQ29uZGl0aW9uO1xuXG59KHRoaXMuY2gpKTtcblxuKGZ1bmN0aW9uICh3aW5kb3csIGNoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGlvbiBpcyBhbiBlbmdpbmUgdG8gdmFsaWRhdGUgSFRNTCBmb3JtcyBlbGVtZW50cy5cbiAgICAgKiBAbWVtYmVyb2YgY2hcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgY2guQ29tcG9uZW50XG4gICAgICogQHJlcXVpcmVzIGNoLkNvbmRpdGlvblxuICAgICAqIEByZXF1aXJlcyBjaC5Gb3JtXG4gICAgICogQHJlcXVpcmVzIGNoLkJ1YmJsZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEEgSFRNTEVsZW1lbnQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIGNoLlZhbGlkYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRvIGN1c3RvbWl6ZSBhbiBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jb25kaXRpb25zXSBBIGNvbGxlY3Rpb24gb2YgY29uZGl0aW9ucyB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29uZGl0aW9ucy5uYW1lXSBUaGUgbmFtZSBvZiB0aGUgY29uZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb25kaXRpb25zLm1lc3NhZ2VdIFRoZSBnaXZlbiBlcnJvciBtZXNzYWdlIHRvIHRoZSBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbmRpdGlvbnMuZm5dIFRoZSBtZXRob2QgdG8gdmFsaWRhdGUgYSBnaXZlbiBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW29wdGlvbnMucmVmZXJlbmNlXSBJdCdzIGEgcmVmZXJlbmNlIHRvIHBvc2l0aW9uIGFuZCBzaXplIG9mIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGNvbnNpZGVyZWQgdG8gY2Fycnkgb3V0IHRoZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2lkZV0gVGhlIHNpZGUgb3B0aW9uIHdoZXJlIHRoZSB0YXJnZXQgZWxlbWVudCB3aWxsIGJlIHBvc2l0aW9uZWQuIERlZmF1bHQ6IFwicmlnaHRcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWxpZ25dIFRoZSBhbGlnbiBvcHRpb25zIHdoZXJlIHRoZSB0YXJnZXQgZWxlbWVudCB3aWxsIGJlIHBvc2l0aW9uZWQuIERlZmF1bHQ6IFwidG9wXCIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFhdIERpc3RhbmNlIHRvIGRpc3BsYWNlIHRoZSB0YXJnZXQgaG9yaXpvbnRhbGx5LiBEZWZhdWx0OiAxMC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WV0gRGlzdGFuY2UgdG8gZGlzcGxhY2UgdGhlIHRhcmdldCB2ZXJ0aWNhbGx5LiBEZWZhdWx0OiAwLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbl0gVGhlIHR5cGUgb2YgcG9zaXRpb25pbmcgdXNlZC4gRGVmYXVsdDogXCJhYnNvbHV0ZVwiLlxuICAgICAqIEByZXR1cm5zIHt2YWxpZGF0aW9ufSBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIFZhbGlkYXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgVmFsaWRhdGlvbi5cbiAgICAgKiB2YXIgdmFsaWRhdGlvbiA9IG5ldyBjaC5WYWxpZGF0aW9uKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5uYW1lLWZpZWxkJyksIFtvcHRpb25zXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSB2YWxpZGF0aW9uIHdpdGggd2l0aCBjdXN0b20gb3B0aW9ucy5cbiAgICAgKiB2YXIgdmFsaWRhdGlvbiA9IG5ldyBjaC5WYWxpZGF0aW9uKHtcbiAgICAgKiAgICAgJ2NvbmRpdGlvbnMnOiBbXG4gICAgICogICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgJ25hbWUnOiAncmVxdWlyZWQnLFxuICAgICAqICAgICAgICAgICAgICdtZXNzYWdlJzogJ1BsZWFzZSwgZmlsbCBpbiB0aGlzIGluZm9ybWF0aW9uLidcbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgJ25hbWUnOiAnY3VzdG9tLWVtYWlsJyxcbiAgICAgKiAgICAgICAgICAgICAnZm4nOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSBcImN1c3RvbWFpbEBjdXN0b20uY29tXCI7IH0sXG4gICAgICogICAgICAgICAgICAgJ21lc3NhZ2UnOiAnVXNlIGEgdmFsaWQgZS1tYWlsIHN1Y2ggYXMgbmFtZUBjdXN0b20uY29tLidcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgXSxcbiAgICAgKiAgICAgJ29mZnNldFgnOiAwLFxuICAgICAqICAgICAnb2Zmc2V0WSc6IDEwLFxuICAgICAqICAgICAnc2lkZSc6ICdib3R0b20nLFxuICAgICAqICAgICAnYWxpZ24nOiAnbGVmdCdcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uKGVsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2luaXQoZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB5b3UgZGVmaW5lIGFuIGluaXRpYWxpemUgbWV0aG9kLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYSBuZXcgVmFsaWRhdGlvbiBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mISBjaC5WYWxpZGF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHJlYWR5IHRvIHVzZS5cbiAgICAgICAgICogQGV2ZW50IGNoLlZhbGlkYXRpb24jcmVhZHlcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwicmVhZHlcIiBldmVudC5cbiAgICAgICAgICogdmFsaWRhdGlvbi5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRoYXQuZW1pdCgncmVhZHknKTsgfSwgNTApO1xuICAgIH1cblxuICAgIC8vIEluaGVyaXRhbmNlXG4gICAgdGlueS5pbmhlcml0cyhWYWxpZGF0aW9uLCBjaC5Db21wb25lbnQpO1xuXG4gICAgdmFyIHBhcmVudCA9IFZhbGlkYXRpb24uc3VwZXJfLnByb3RvdHlwZSxcbiAgICAgICAgLy8gQ3JlYXRlcyBtZXRob2RzIGVuYWJsZSBhbmQgZGlzYWJsZSBpbnRvIHRoZSBwcm90b3R5cGUuXG4gICAgICAgIG1ldGhvZHMgPSBbJ2VuYWJsZScsICdkaXNhYmxlJ10sXG4gICAgICAgIGxlbiA9IG1ldGhvZHMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlTWV0aG9kcyhtZXRob2QpIHtcbiAgICAgICAgVmFsaWRhdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgICAgIC8vIFNwZWNpZmljIGNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbiAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY29uZGl0aW9uc1tjb25kaXRpb25dICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uc1tjb25kaXRpb25dW21ldGhvZF0oKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIGFsbCBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gdGhpcy5jb25kaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmRpdGlvbnNba2V5XVttZXRob2RdKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJlbnRbbWV0aG9kXS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBtZW1iZXJvZiEgY2guVmFsaWRhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIFZhbGlkYXRpb24ucHJvdG90eXBlLm5hbWUgPSAndmFsaWRhdGlvbic7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlZhbGlkYXRpb24ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgVmFsaWRhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWYWxpZGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWYWxpZGF0aW9uLnByb3RvdHlwZS5fZGVmYXVsdHMgPSB7XG4gICAgICAgICdvZmZzZXRYJzogMTBcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBpbnN0YW5jZSBvZiBWYWxpZGF0aW9uIGFuZCBtZXJnZSBjdXN0b20gb3B0aW9ucyB3aXRoIGRlZmF1bHRzIG9wdGlvbnMuXG4gICAgICogQG1lbWJlcm9mISBjaC5WYWxpZGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3ZhbGlkYXRpb259XG4gICAgICovXG4gICAgVmFsaWRhdGlvbi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgcGFyZW50Ll9pbml0LmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmFsaWRhdGlvbiB0cmlnZ2VyLlxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIgPSB0aGlzLl9lbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbGlkYXRpb24gY29udGFpbmVyLlxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb25maWd1cmVDb250YWluZXIoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbGxlY3Rpb24gb2YgY29uZGl0aW9ucy5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29uZGl0aW9ucyA9IHt9O1xuXG4gICAgICAgIC8vIE1lcmdlIGNvbmRpdGlvbnNcbiAgICAgICAgdGhpcy5fbWVyZ2VDb25kaXRpb25zKG9wdGlvbnMuY29uZGl0aW9ucyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgdGhhdCBsZXQgeW91IGtub3cgaWYgdGhlcmUncyBhIHZhbGlkYXRpb24gZ29pbmcgb24uXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2hvd24gPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgZXJyb3IuIElmIHRoZSB2YWxpZGF0aW9ucyBoYXMgbm90IGVycm9yIGlzIFwibnVsbFwiLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG5cbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLy8gQ2xlYW4gdGhlIHZhbGlkYXRpb24gaWYgaXMgc2hvd247XG4gICAgICAgICAgICAub24oJ2Rpc2FibGUnLCB0aGlzLmNsZWFyKTtcblxuICAgICAgICB0aGlzLm9uKCdlcnJvcicsIHRoaXMuX2hhbmRsZUVycm9yKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGEgRm9ybSBpbnN0YW5jZS4gSWYgdGhlcmUgaXNuJ3QgYW55LCB0aGUgVmFsaWRhdGlvbiBpbnN0YW5jZSB3aWxsIGNyZWF0ZSBvbmUuXG4gICAgICAgICAqIEB0eXBlIHtmb3JtfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtID0gKGNoLmluc3RhbmNlc1t0aW55LnBhcmVudCh0aGF0LnRyaWdnZXIsICdmb3JtJykuZ2V0QXR0cmlidXRlKCdkYXRhLXVpZCcpXSB8fCBuZXcgY2guRm9ybSh0aW55LnBhcmVudCh0aGF0LnRyaWdnZXIsICdmb3JtJykpKTtcblxuICAgICAgICB0aGlzLmZvcm0udmFsaWRhdGlvbnMucHVzaCh0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGEgdmFsaWRhdGlvbiBldmVudCB0byBhZGQgbGlzdGVuZXJzLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdmFsaWRhdGlvbkV2ZW50ID0gKHRpbnkuaGFzQ2xhc3ModGhpcy50cmlnZ2VyLCAnY2gtZm9ybS1vcHRpb25zJykgfHwgdGhpcy5fZWwudGFnTmFtZSA9PT0gJ1NFTEVDVCcgfHwgKHRoaXMuX2VsLnRhZ05hbWUgPT09ICdJTlBVVCcgJiYgdGhpcy5fZWwudHlwZSA9PT0gJ3JhbmdlJykpID8gJ2NoYW5nZScgOiAnYmx1cic7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgY29sbGVjdGlvbiBvZiBjb25kaXRpb25zIHdpdGggYSBnaXZlbiBjb25kaXRpb25zLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmFsaWRhdGlvbi5wcm90b3R5cGUuX21lcmdlQ29uZGl0aW9ucyA9IGZ1bmN0aW9uIChjb25kaXRpb25zKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGogPSBjb25kaXRpb25zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGk7IGkgPCBqOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uc1tjb25kaXRpb25zW2ldLm5hbWVdID0gbmV3IGNoLkNvbmRpdGlvbihjb25kaXRpb25zW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIHZhbHVlIG9mICRlbC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlZhbGlkYXRpb24ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge3ZhbGlkYXRpb259XG4gICAgICovXG4gICAgVmFsaWRhdGlvbi5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3IoKSkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N1Y2Nlc3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdmFsaWRhdGlvbiBoYXMgZ290IGFuIGVycm9yIGV4ZWN1dGVzIHRoaXMgZnVuY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWYWxpZGF0aW9uLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZTtcblxuICAgICAgICAvLyBJdCBtdXN0IGhhcHBlbiBvbmx5IG9uY2UuXG4gICAgICAgIHRpbnkub24odGhpcy50cmlnZ2VyLCB0aGlzLl92YWxpZGF0aW9uRXZlbnQsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IHRoaXMudmFsdWUgfHwgdGhhdC5fdmFsaWRhdGlvbkV2ZW50ID09PSAnY2hhbmdlJyAmJiB0aGF0LmlzU2hvd24oKSkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoYXQudmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoYXQuY29uZGl0aW9ucy5yZXF1aXJlZCA9PT0gdW5kZWZpbmVkICYmIHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5jbGVhcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdCBlbWl0cyBhbiBlcnJvciBldmVudCB3aGVuIGEgdmFsaWRhdGlvbiBnb3QgYW4gZXJyb3IuXG4gICAgICAgICAqIEBldmVudCBjaC5WYWxpZGF0aW9uI2Vycm9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcImVycm9yXCIgZXZlbnQuXG4gICAgICAgICAqIHZhbGlkYXRpb24ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9ycykge1xuICAgICAgICAgKiAgICAgY29uc29sZS5sb2coZXJyb3JzLmxlbmd0aCk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHRoaXMuZXJyb3IpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBlcnJvciBoYW5kbGVyLCBzaG93cyB0aGUgZXJyb3JzIHdoZW4gbmVlZGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyIHtPYmplY3R9IEEgY2guVmFsaWRhdGlvbiNlcnJvciBvYmplY3QgdGhhdCBjb250YWluIHRoZSBlcnJvciBtZXNzYWdlIGFuZCB0aGUgZXJyb3IgY29uZGl0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWYWxpZGF0aW9uLnByb3RvdHlwZS5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhhdC5fcHJldmlvdXNFcnJvci5jb25kaXRpb24gfHwgIXRoYXQuX3Nob3duKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5fZWwubm9kZU5hbWUgPT09ICdJTlBVVCcgfHwgdGhhdC5fZWwubm9kZU5hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgICAgICAgICB0aW55LmFkZENsYXNzKHRoYXQudHJpZ2dlciwgJ2NoLXZhbGlkYXRpb24tZXJyb3InKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC5fc2hvd0Vycm9yTWVzc2FnZShlcnIubWVzc2FnZSB8fCAnRXJyb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnIuY29uZGl0aW9uICE9PSB0aGF0Ll9wcmV2aW91c0Vycm9yLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhhdC5fc2hvd0Vycm9yTWVzc2FnZShlcnIubWVzc2FnZSB8fCB0aGF0LmZvcm0uX21lc3NhZ2VzW2Vyci5jb25kaXRpb25dIHx8ICdFcnJvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5fc2hvd24gPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdmFsaWRhdGlvbiBoYXNuJ3QgZ290IGFuIGVycm9yIGV4ZWN1dGVzIHRoaXMgZnVuY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWYWxpZGF0aW9uLnByb3RvdHlwZS5fc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvLyBTdGF0dXMgT0sgKHdpdGggcHJldmlvdXMgZXJyb3IpIHRoaXMuX3ByZXZpb3VzRXJyb3JcbiAgICAgICAgaWYgKHRoaXMuX3Nob3duIHx8ICF0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBQdWJsaWMgc3RhdHVzIE9LXG4gICAgICAgICAgICB0aGlzLl9zaG93biA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgICAgICB0aW55LnJlbW92ZUNsYXNzKHRoaXMudHJpZ2dlciwgJ2NoLXZhbGlkYXRpb24tZXJyb3InKTtcblxuXG4gICAgICAgIHRoaXMuX2hpZGVFcnJvck1lc3NhZ2UoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXQgZW1pdHMgYW4gZXZlbnQgd2hlbiBhIHZhbGlkYXRpb24gaGFzbid0IGdvdCBhbiBlcnJvci5cbiAgICAgICAgICogQGV2ZW50IGNoLlZhbGlkYXRpb24jc3VjY2Vzc1xuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJzdWNjZXNzXCIgZXZlbnQuXG4gICAgICAgICAqIHZhbGlkYXRpb24ub24oXCJzdWJtaXRcIixmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoJ3N1Y2Nlc3MnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSB2YWxpZGF0aW9uIGhhcyBnb3QgZXJyb3JzIGJ1dCBpdCBkb2Vzbid0IHNob3cgYnViYmxlcy5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlZhbGlkYXRpb24ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDaGVja3MgaWYgYSB2YWxpZGF0aW9uIGhhcyBlcnJvcnMgYW5kIGRvIHNvbWV0aGluZy5cbiAgICAgKiBpZiAodmFsaWRhdGlvbi5oYXNFcnJvcigpKSB7XG4gICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAqIH07XG4gICAgICovXG4gICAgVmFsaWRhdGlvbi5wcm90b3R5cGUuaGFzRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLy8gUHJlLXZhbGlkYXRpb246IERvbid0IHZhbGlkYXRlIGRpc2FibGVkXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXIuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8ICF0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29uZGl0aW9uLFxuICAgICAgICAgICAgcmVxdWlyZWQgPSB0aGlzLmNvbmRpdGlvbnMucmVxdWlyZWQsXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2VsLnZhbHVlO1xuXG4gICAgICAgIC8vIEF2b2lkIGZpZWxkcyB0aGF0IGFyZW4ndCByZXF1aXJlZCB3aGVuIHRoZXkgYXJlIGVtcHR5IG9yIGRlLWFjdGl2YXRlZFxuICAgICAgICBpZiAoIXJlcXVpcmVkICYmIHZhbHVlID09PSAnJyAmJiB0aGlzLl9zaG93biA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIEhhcyBnb3QgYW4gZXJyb3I/IE5vcFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyB0aGUgcHJldmlvdXMgZXJyb3Igb2JqZWN0XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcmV2aW91c0Vycm9yID0gdGlueS5jbG9uZSh0aGlzLmVycm9yKTtcblxuICAgICAgICAvLyBmb3IgZWFjaCBjb25kaXRpb25cbiAgICAgICAgZm9yIChjb25kaXRpb24gaW4gdGhpcy5jb25kaXRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbnNbY29uZGl0aW9uXSAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmNvbmRpdGlvbnNbY29uZGl0aW9uXS50ZXN0KHZhbHVlLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZXJyb3Igb2JqZWN0XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbmRpdGlvbic6IGNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgJ21lc3NhZ2UnOiB0aGlzLmNvbmRpdGlvbnNbY29uZGl0aW9uXS5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEhhcyBnb3QgYW4gZXJyb3I/IFllYWhcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBlcnJvciBvYmplY3RcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG5cbiAgICAgICAgLy8gSGFzIGdvdCBhbiBlcnJvcj8gTm9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhY3RpdmUgZXJyb3IuXG4gICAgICogQG1lbWJlcm9mISBjaC5WYWxpZGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHt2YWxpZGF0aW9ufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ2xlYXIgYWN0aXZlIGVycm9yLlxuICAgICAqIHZhbGlkYXRpb24uY2xlYXIoKTtcbiAgICAgKi9cbiAgICBWYWxpZGF0aW9uLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLnRyaWdnZXIucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgICAgIHRpbnkucmVtb3ZlQ2xhc3ModGhpcy50cmlnZ2VyLCAnY2gtdmFsaWRhdGlvbi1lcnJvcicpO1xuXG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2hpZGVFcnJvck1lc3NhZ2UoKTtcblxuICAgICAgICB0aGlzLl9zaG93biA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdCBlbWl0cyBhbiBldmVudCB3aGVuIGEgdmFsaWRhdGlvbiBpcyBjbGVhbmVkLlxuICAgICAgICAgKiBAZXZlbnQgY2guVmFsaWRhdGlvbiNjbGVhclxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJjbGVhclwiIGV2ZW50LlxuICAgICAgICAgKiB2YWxpZGF0aW9uLm9uKCdjbGVhcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1pdCgnY2xlYXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSB2YWxpZGF0aW9uIGlzIHNob3duLlxuICAgICAqIEBtZW1iZXJvZiEgY2guVmFsaWRhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEV4ZWN1dGUgYSBmdW5jdGlvbiBpZiB0aGUgdmFsaWRhdGlvbiBpcyBzaG93bi5cbiAgICAgKiBpZiAodmFsaWRhdGlvbi5pc1Nob3duKCkpIHtcbiAgICAgKiAgICAgZm4oKTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgVmFsaWRhdGlvbi5wcm90b3R5cGUuaXNTaG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3duO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIGdldHMgbWVzc2FnZXMgdG8gc3BlY2lmaWNzIGNvbmRpdGlvbnMuXG4gICAgICogQG1lbWJlcm9mISBjaC5WYWxpZGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHsodmFsaWRhdGlvbiB8IFN0cmluZyl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBHZXRzIGEgbWVzc2FnZSBmcm9tIGEgY29uZGl0aW9uXG4gICAgICogdmFsaWRhdGlvbi5tZXNzYWdlKCdyZXF1aXJlZCcpO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gU2V0cyBhIG5ldyBtZXNzYWdlXG4gICAgICogdmFsaWRhdGlvbi5tZXNzYWdlKCdyZXF1aXJlZCcsICdOZXcgbWVzc2FnZSBmb3IgcmVxdWlyZWQgdmFsaWRhdGlvbicpO1xuICAgICAqL1xuICAgIFZhbGlkYXRpb24ucHJvdG90eXBlLm1lc3NhZ2UgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG5cbiAgICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbGlkYXRpb24ubWVzc2FnZShjb25kaXRpb24sIG1lc3NhZ2UpOiBQbGVhc2UsIGEgY29uZGl0aW9uIHBhcmFtZXRlciBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBhIG5ldyBtZXNzYWdlIGZyb20gYSBjb25kaXRpb25cbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1tjb25kaXRpb25dLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXRzIGEgbmV3IG1lc3NhZ2VcbiAgICAgICAgdGhpcy5jb25kaXRpb25zW2NvbmRpdGlvbl0ubWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTaG93bigpICYmIHRoaXMuZXJyb3IuY29uZGl0aW9uID09PSBjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dFcnJvck1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBhbiBpbnN0YW5jZSBvZiB2YWxpZGF0aW9uIG9yIGEgc3BlY2lmaWMgY29uZGl0aW9uLlxuICAgICAqIEBtZW1iZXJvZiEgY2guVmFsaWRhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAbmFtZSBlbmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmRpdGlvbl0gLSBBIGdpdmVuIG51bWJlciBvZiBmb2xkIHRvIGVuYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7dmFsaWRhdGlvbn0gUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBWYWxpZGF0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRW5hYmxpbmcgYW4gaW5zdGFuY2Ugb2YgVmFsaWRhdGlvbi5cbiAgICAgKiB2YWxpZGF0aW9uLmVuYWJsZSgpO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRW5hYmxpbmcgdGhlIFwibWF4XCIgY29uZGl0aW9uLlxuICAgICAqIHZhbGlkYXRpb24uZW5hYmxlKCdtYXgnKTtcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIGFuIGluc3RhbmNlIG9mIGEgdmFsaWRhdGlvbiBvciBhIHNwZWNpZmljIGNvbmRpdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlZhbGlkYXRpb24ucHJvdG90eXBlXG4gICAgICogQG5hbWUgZGlzYWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZGl0aW9uXSAtIEEgZ2l2ZW4gbnVtYmVyIG9mIGZvbGQgdG8gZGlzYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7dmFsaWRhdGlvbn0gUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBWYWxpZGF0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRGlzYWJsaW5nIGFuIGluc3RhbmNlIG9mIFZhbGlkYXRpb24uXG4gICAgICogdmFsaWRhdGlvbi5kaXNhYmxlKCk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBEaXNhYmxpbmcgdGhlIFwiZW1haWxcIiBjb25kaXRpb24uXG4gICAgICogdmFsaWRhdGlvbi5kaXNhYmxlKCdlbWFpbCcpO1xuICAgICAqL1xuICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgY3JlYXRlTWV0aG9kcyhtZXRob2RzW2xlbiAtPSAxXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBWYWxpZGF0aW9uIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJvZiEgY2guVmFsaWRhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIERlc3Ryb3lpbmcgYW4gaW5zdGFuY2Ugb2YgVmFsaWRhdGlvbi5cbiAgICAgKiB2YWxpZGF0aW9uLmRlc3Ryb3koKTtcbiAgICAgKi9cbiAgICBWYWxpZGF0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8vIHRoaXMuJHRyaWdnZXIub2ZmKCcudmFsaWRhdGlvbicpXG4gICAgICAgIHRoaXMudHJpZ2dlci5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc2lkZSBkYXRhLWFsaWduJyk7XG5cbiAgICAgICAgcGFyZW50LmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIC8vIEZhY3Rvcml6ZVxuICAgIGNoLmZhY3RvcnkoVmFsaWRhdGlvbik7XG5cbn0odGhpcywgdGhpcy5jaCkpO1xuXG4oZnVuY3Rpb24gKGNoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJ1YmJsZSB0byBzaG93IHRoZSB2YWxpZGF0aW9uIG1lc3NhZ2UuXG4gICAgICogQG1lbWJlcm9mISBjaC5WYWxpZGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3ZhbGlkYXRpb259XG4gICAgICovXG4gICAgY2guVmFsaWRhdGlvbi5wcm90b3R5cGUuX2NvbmZpZ3VyZUNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHRoZSBsaXR0bGUgc2lnbiB0aGF0IHBvcG92ZXIgc2hvd2luZyB0aGUgdmFsaWRhdGlvbiBtZXNzYWdlLiBJdCdzIGEgUG9wb3ZlciBjb21wb25lbnQsIHNvIHlvdSBjYW4gY2hhbmdlIGl0J3MgY29udGVudCwgd2lkdGggb3IgaGVpZ2h0IGFuZCBjaGFuZ2UgaXRzIHZpc2liaWxpdHkgc3RhdGUuXG4gICAgICAgICAqIEB0eXBlIHtCdWJibGV9XG4gICAgICAgICAqIEBzZWUgY2guQnViYmxlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJ1YmJsZSA9IHRoaXMuX2NvbnRhaW5lciA9IG5ldyBjaC5CdWJibGUoe1xuICAgICAgICAgICAgJ3JlZmVyZW5jZSc6IHRoYXQuX29wdGlvbnMucmVmZXJlbmNlIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlciA9IHRoYXQudHJpZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgaDQsXG4gICAgICAgICAgICAgICAgICAgIHNwYW47XG4gICAgICAgICAgICAgICAgLy8gQ0hFQ0tCT1gsIFJBRElPXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2hlbiBvbGQgZm9ybXMgYmUgZGVwcmVjYXRlZCB3ZSBtdXN0IG9ubHkgc3VwcG9ydCBjaC1mb3JtLW9wdGlvbnMgY2xhc3NcbiAgICAgICAgICAgICAgICBpZiAodGlueS5oYXNDbGFzcyh0cmlnZ2VyLCAnY2gtZm9ybS1vcHRpb25zJykpIHtcbiAgICAgICAgICAgICAgICAvLyBIZWxwZXIgcmVmZXJlbmNlIGZyb20gd2lsbCBiZSBmaXJlZFxuICAgICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlci5xdWVyeVNlbGVjdG9yQWxsKCdoNCcpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdyYXAgY29udGVudCB3aXRoIGlubGluZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBoNCA9IHRyaWdnZXIucXVlcnlTZWxlY3RvcignaDQnKTsgLy8gRmluZCBoNFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBoNC5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaDQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBoNC5pbnNlcnRCZWZvcmUoc3BhbiwgaDQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UgPSBoNC5jaGlsZHJlblswXTsgLy8gSW5saW5lIGVsZW1lbnQgaW4gaDQgbGlrZSBoZWxwZXIgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyaWdnZXIucHJldmlvdXNFbGVtZW50U2libGluZyAmJiB0cmlnZ2VyLnByZXZpb3VzRWxlbWVudFNpYmxpbmcudGFnTmFtZSA9PT0gJ0xFR0VORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZSA9IHRyaWdnZXIucHJldmlvdXNFbGVtZW50U2libGluZzsgLy8gTGVnZW5kIGxpa2UgaGVscGVyIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlID0gdHJpZ2dlci5xdWVyeVNlbGVjdG9yKCdsYWJlbCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSU5QVVQsIFNFTEVDVCwgVEVYVEFSRUFcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UgPSB0cmlnZ2VyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2U7XG4gICAgICAgICAgICB9KCkpLFxuICAgICAgICAgICAgJ2FsaWduJzogdGhhdC5fb3B0aW9ucy5hbGlnbixcbiAgICAgICAgICAgICdzaWRlJzogdGhhdC5fb3B0aW9ucy5zaWRlLFxuICAgICAgICAgICAgJ29mZnNldFknOiB0aGF0Ll9vcHRpb25zLm9mZnNldFksXG4gICAgICAgICAgICAnb2Zmc2V0WCc6IHRoYXQuX29wdGlvbnMub2Zmc2V0WFxuICAgICAgICAgICAgLy8gJ3Bvc2l0aW9uJzogdGhhdC5fb3B0aW9ucy5wb3NpdGlvblxuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgdmFsaWRhdGlvbiBtZXNzYWdlLlxuICAgICAqIEBtZW1iZXJvZiEgY2guVmFsaWRhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2YWxpZGF0aW9ufVxuICAgICAqL1xuICAgIGNoLlZhbGlkYXRpb24ucHJvdG90eXBlLl9zaG93RXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5idWJibGUuY29udGVudChtZXNzYWdlKS5zaG93KCk7XG4gICAgICAgIHRoaXMudHJpZ2dlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnY2gtJyArIHRoaXMuYnViYmxlLm5hbWUgKyAnLScgKyB0aGlzLmJ1YmJsZS51aWQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgdmFsaWRhdGlvbiBtZXNzYWdlLlxuICAgICAqIEBtZW1iZXJvZiEgY2guVmFsaWRhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2YWxpZGF0aW9ufVxuICAgICAqL1xuICAgIGNoLlZhbGlkYXRpb24ucHJvdG90eXBlLl9oaWRlRXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJ1YmJsZS5oaWRlKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHBvc2l0aW9uaW5nIGNvbmZpZ3VyYXRpb24uIFVzZSBpdCB3aXRob3V0IGFyZ3VtZW50cyB0byBnZXQgYWN0dWFsIGNvbmZpZ3VyYXRpb24uIFBhc3MgYW4gYXJndW1lbnQgdG8gZGVmaW5lIGEgbmV3IHBvc2l0aW9uaW5nIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQG1lbWJlcm9mISBjaC5WYWxpZGF0aW9uLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHt2YWxpZGF0aW9ufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ2hhbmdlIHZhbGlkYXRvbiBidWJibGUncyBwb3NpdGlvbi5cbiAgICAgKiB2YWxpZGF0aW9uLnJlZnJlc2hQb3NpdGlvbih7XG4gICAgICogICAgIG9mZnNldFk6IC0xMCxcbiAgICAgKiAgICAgc2lkZTogJ3RvcCcsXG4gICAgICogICAgIGFsaWduOiAnbGVmdCdcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBjaC5WYWxpZGF0aW9uLnByb3RvdHlwZS5yZWZyZXNoUG9zaXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1YmJsZS5fcG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1YmJsZS5yZWZyZXNoUG9zaXRpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxufSh0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAod2luZG93LCBjaCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnIHx8IG9wdGlvbnMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAnY29udGVudCc6IG9wdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kYWJsZSBsZXRzIHlvdSBzaG93IG9yIGhpZGUgY29udGVudC4gRXhwYW5kYWJsZSBuZWVkcyBhIHBhaXI6IGEgdGl0bGUgYW5kIGEgY29udGFpbmVyIHJlbGF0ZWQgdG8gdGl0bGUuXG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIGNoLkNvbXBvbmVudFxuICAgICAqIEBtaXhlcyBjaC5Db2xsYXBzaWJsZVxuICAgICAqIEBtaXhlcyBjaC5Db250ZW50XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgQSBIVE1MRWxlbWVudCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgY2guRXhwYW5kYWJsZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gY3VzdG9taXplIGFuIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5meF0gRW5hYmxlIG9yIGRpc2FibGUgVUkgZWZmZWN0cy4gWW91IG11c3QgdXNlOiBcInNsaWRlRG93blwiLCBcImZhZGVJblwiIG9yIFwibm9uZVwiLiBEZWZhdWx0OiBcIm5vbmVcIi5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRvZ2dsZV0gQ3VzdG9taXplIHRvZ2dsZSBiZWhhdmlvci4gRGVmYXVsdDogdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbb3B0aW9ucy5jb250YWluZXJdIFRoZSBjb250YWluZXIgd2hlcmUgdGhlIGV4cGFuYmRhbGUgcHV0cyBpdHMgY29udGVudC4gRGVmYXVsdDogdGhlIG5leHQgc2libGluZyBvZiBlbCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHsoU3RyaW5nIHwgSFRNTEVsZW1lbnQpfSBbb3B0aW9ucy5jb250ZW50XSBUaGUgY29udGVudCB0byBiZSBzaG93biBpbnRvIHRoZSBleHBhbmRhYmxlIGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJucyB7ZXhwYW5kYWJsZX0gUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBFeHBhbmRhYmxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IEV4cGFuZGFibGUuXG4gICAgICogdmFyIGV4cGFuZGFibGUgPSBuZXcgY2guRXhwYW5kYWJsZShbZWxdLCBbb3B0aW9uc10pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IEV4cGFuZGFibGUgd2l0aCBjdXN0b20gb3B0aW9ucy5cbiAgICAgKiB2YXIgZXhwYW5kYWJsZSA9IG5ldyBjaC5FeHBhbmRhYmxlKHtcbiAgICAgKiAgICAgJ2NvbnRhaW5lcic6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5teS1jb250YWluZXInKSxcbiAgICAgKiAgICAgJ3RvZ2dsZSc6IGZhbHNlLFxuICAgICAqICAgICAnZngnOiAnc2xpZGVEb3duJyxcbiAgICAgKiAgICAgJ2NvbnRlbnQnOiAnaHR0cDovL3VpLm1sLmNvbTozMDQwL2FqYXgnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgRXhwYW5kYWJsZSB1c2luZyB0aGUgc2hvcnRoYW5kIHdheSAoY29udGVudCBhcyBwYXJhbWV0ZXIpLlxuICAgICAqIHZhciBleHBhbmRhYmxlID0gbmV3IGNoLkV4cGFuZGFibGUoJ2h0dHA6Ly91aS5tbC5jb206MzA0MC9hamF4Jyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwYW5kYWJsZShlbCwgb3B0aW9ucykge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gY29udGV4dCBvZiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICB0aGlzLl9pbml0KGVsLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgeW91IGRlZmluZSBhbiBpbml0aWFsaXplIG1ldGhvZCwgaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGEgbmV3IEV4cGFuZGFibGUgaXMgY3JlYXRlZC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiEgY2guRXhwYW5kYWJsZS5wcm90b3R5cGVcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZWFkeSB0byB1c2UuXG4gICAgICAgICAqIEBldmVudCBjaC5FeHBhbmRhYmxlI3JlYWR5XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcInJlYWR5XCIgZXZlbnQuXG4gICAgICAgICAqIGV4cGFuZGFibGUub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aGF0LmVtaXQoJ3JlYWR5Jyk7IH0sIDUwKTtcbiAgICB9XG5cbiAgICAvLyBJbmhlcml0YW5jZVxuICAgIHRpbnkuaW5oZXJpdHMoRXhwYW5kYWJsZSwgY2guQ29tcG9uZW50KTtcblxuICAgIHZhciBwYXJlbnQgPSBFeHBhbmRhYmxlLnN1cGVyXy5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBtZW1iZXJvZiEgY2guRXhwYW5kYWJsZS5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIEV4cGFuZGFibGUucHJvdG90eXBlLm5hbWUgPSAnZXhwYW5kYWJsZSc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkV4cGFuZGFibGUucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgRXhwYW5kYWJsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHBhbmRhYmxlO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFeHBhbmRhYmxlLnByb3RvdHlwZS5fZGVmYXVsdHMgPSB7XG4gICAgICAgICdfY2xhc3NOYW1lVHJpZ2dlcic6ICdjaC1leHBhbmRhYmxlLXRyaWdnZXInLFxuICAgICAgICAnX2NsYXNzTmFtZUljb24nOiAnY2gtZXhwYW5kYWJsZS1pY28nLFxuICAgICAgICAnX2NsYXNzTmFtZUNvbnRhaW5lcic6ICdjaC1leHBhbmRhYmxlLWNvbnRhaW5lcicsXG4gICAgICAgICdmeCc6IGZhbHNlLFxuICAgICAgICAndG9nZ2xlJzogdHJ1ZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IGluc3RhbmNlIG9mIEV4cGFuZGFibGUgYW5kIG1lcmdlIGN1c3RvbSBvcHRpb25zIHdpdGggZGVmYXVsdHMgb3B0aW9ucy5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkV4cGFuZGFibGUucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7ZXhwYW5kYWJsZX1cbiAgICAgKi9cbiAgICBFeHBhbmRhYmxlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICAgICAgICAvLyBDYWxsIHRvIGl0cyBwYXJlbnQgaW5pdCBtZXRob2RcbiAgICAgICAgcGFyZW50Ll9pbml0LmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIFJlcXVpcmVzIGFiaWxpdGllc1xuICAgICAgICB0aGlzLnJlcXVpcmUoJ0NvbGxhcHNpYmxlJywgJ0NvbnRlbnQnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBleHBhbmRhYmxlIHRyaWdnZXIuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gR2V0cyB0aGUgZXhwYW5kYWJsZSB0cmlnZ2VyLlxuICAgICAgICAgKiBleHBhbmRhYmxlLnRyaWdnZXI7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIgPSB0aGlzLl9lbDtcbiAgICAgICAgdGlueS5hZGRDbGFzcyh0aGlzLnRyaWdnZXIsIHRoaXMuX29wdGlvbnMuX2NsYXNzTmFtZVRyaWdnZXIpO1xuICAgICAgICB0aW55LmFkZENsYXNzKHRoaXMudHJpZ2dlciwgdGhpcy5fb3B0aW9ucy5fY2xhc3NOYW1lSWNvbik7XG5cbiAgICAgICAgaWYgKG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCkge1xuICAgICAgICAgICAgdGlueS5vbih0aGlzLl9lbCwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lID09PSAnQScpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGlueS5vbih0aGlzLnRyaWdnZXIsIGNoLm9ucG9pbnRlcnRhcCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoY2gucG9pbnRlckNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAodGhhdC5fb3B0aW9ucy50b2dnbGUpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll90b2dnbGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhhdC5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXhwYW5kYWJsZSBjb250YWluZXIuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gR2V0cyB0aGUgZXhwYW5kYWJsZSBjb250YWluZXIuXG4gICAgICAgICAqIGV4cGFuZGFibGUuY29udGFpbmVyO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLl9jb250ZW50ID0gKHRoaXMuX29wdGlvbnMuY29udGFpbmVyID9cbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY29udGFpbmVyIDogdGlueS5uZXh0KHRoaXMuX2VsKSk7XG4gICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXMuX29wdGlvbnMuX2NsYXNzTmFtZUNvbnRhaW5lcik7XG4gICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsICdjaC1oaWRlJyk7XG4gICAgICAgIGlmICh0aW55LnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLl9vcHRpb25zLmZ4ICE9PSAnbm9uZScgJiYgdGhpcy5fb3B0aW9ucy5meCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsICdjaC1meCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIuZ2V0QXR0cmlidXRlKCdpZCcpID09PSAnJykge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsICdjaC1leHBhbmRhYmxlLScgKyB0aGlzLnVpZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIuc2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJywgdGhpcy5jb250YWluZXIuZ2V0QXR0cmlidXRlKCdpZCcpKTtcblxuICAgICAgICB0aGlzXG4gICAgICAgICAgICAub24oJ3Nob3cnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGlueS50cmlnZ2VyKHdpbmRvdy5kb2N1bWVudCwgY2gub25sYXlvdXRjaGFuZ2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aW55LnRyaWdnZXIod2luZG93LmRvY3VtZW50LCBjaC5vbmxheW91dGNoYW5nZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnRyaWdnZXIuc2V0QXR0cmlidXRlKCd1bnNlbGVjdGFibGUnLCAnb24nKTtcbiAgICAgICAgdGlueS5hZGRDbGFzcyh0aGlzLnRyaWdnZXIsICdjaC11c2VyLW5vLXNlbGVjdCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBleHBhbmRhYmxlJ3MgY29udGVudC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkV4cGFuZGFibGUucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsoU3RyaW5nIHwgSFRNTEVsZW1lbnQpfSBbY29udGVudF0gVGhlIGNvbnRlbnQgdGhhdCB3aWxsIGJlIHVzZWQgYnkgZXhwYW5kYWJsZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgY3VzdG9tIG9wdGlvbnMgdG8gYmUgdXNlZCB3aXRoIGNvbnRlbnQgbG9hZGVkIGJ5IGFqYXguXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1ldGhvZF0gVGhlIHR5cGUgb2YgcmVxdWVzdCAoXCJQT1NUXCIgb3IgXCJHRVRcIikgdG8gbG9hZCBjb250ZW50IGJ5IGFqYXguIERlZmF1bHQ6IFwiR0VUXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhcmFtc10gUGFyYW1zIGxpa2UgcXVlcnkgc3RyaW5nIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNhY2hlXSBGb3JjZSB0byBjYWNoZSB0aGUgcmVxdWVzdCBieSB0aGUgYnJvd3Nlci4gRGVmYXVsdDogdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFzeW5jXSBGb3JjZSB0byBzZW50IHJlcXVlc3QgYXN5bmNocm9ub3VzbHkuIERlZmF1bHQ6IHRydWUuXG4gICAgICogQHBhcmFtIHsoU3RyaW5nIHwgSFRNTEVsZW1lbnQpfSBbb3B0aW9ucy53YWl0aW5nXSBUZW1wb3JhcnkgY29udGVudCB0byB1c2Ugd2hpbGUgdGhlIGFqYXggcmVxdWVzdCBpcyBsb2FkaW5nLlxuICAgICAqIEByZXR1cm5zIHtleHBhbmRhYmxlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gU2hvd3MgYSBiYXNpYyBleHBhbmRhYmxlLlxuICAgICAqIGNvbXBvbmVudC5zaG93KCk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaG93cyBhbiBleHBhbmRhYmxlIHdpdGggbmV3IGNvbnRlbnQuXG4gICAgICogY29tcG9uZW50LnNob3coJ1NvbWUgbmV3IGNvbnRlbnQgaGVyZSEnKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNob3dzIGFuIGV4cGFuZGFibGUgd2l0aCBhIG5ldyBjb250ZW50IHRoYXQgd2lsbCBiZSBsb2FkZWQgYnkgYWpheCBhbmQgc29tZSBjdXN0b20gb3B0aW9ucy5cbiAgICAgKiBjb21wb25lbnQuc2hvdygnaHR0cDovL2NoaWNvLXVpLmNvbS5hci9hamF4Jywge1xuICAgICAqICAgICAnY2FjaGUnOiBmYWxzZSxcbiAgICAgKiAgICAgJ3BhcmFtcyc6ICd4LXJlcXVlc3Q9dHJ1ZSdcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBFeHBhbmRhYmxlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2hvdygpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBBUklBXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG5cbiAgICAgICAgLy8gU2V0IG5ldyBjb250ZW50XG4gICAgICAgIGlmIChjb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudChjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIaWRlcyBjb21wb25lbnQncyBjb250YWluZXIuXG4gICAgICogQG1lbWJlcm9mISBjaC5FeHBhbmRhYmxlLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtleHBhbmRhYmxlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ2xvc2UgYW4gZXhwYW5kYWJsZS5cbiAgICAgKiBleHBhbmRhYmxlLmhpZGUoKTtcbiAgICAgKi9cbiAgICBFeHBhbmRhYmxlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5fZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oaWRlKCk7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJvb2xlYW4gc3BlY2lmeWluZyBpZiB0aGUgY29tcG9uZW50J3MgY29yZSBiZWhhdmlvciBpcyBzaG93bi4gVGhhdCBtZWFucyBpdCB3aWxsIHJldHVybiAndHJ1ZScgaWYgdGhlIGNvbXBvbmVudCBpcyBvbiwgYW5kIGl0IHdpbGwgcmV0dXJuIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkV4cGFuZGFibGUucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBFeGVjdXRlIGEgZnVuY3Rpb24gaWYgdGhlIGNvbXBvbmVudCBpcyBzaG93bi5cbiAgICAgKiBpZiAoZXhwYW5kYWJsZS5pc1Nob3duKCkpIHtcbiAgICAgKiAgICAgZm4oKTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgRXhwYW5kYWJsZS5wcm90b3R5cGUuaXNTaG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3duO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhbiBFeHBhbmRhYmxlIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJvZiEgY2guRXhwYW5kYWJsZS5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIERlc3Ryb3kgYW4gZXhwYW5kYWJsZVxuICAgICAqIGV4cGFuZGFibGUuZGVzdHJveSgpO1xuICAgICAqIC8vIEVtcHR5IHRoZSBleHBhbmRhYmxlIHJlZmVyZW5jZVxuICAgICAqIGV4cGFuZGFibGUgPSB1bmRlZmluZWQ7XG4gICAgICovXG4gICAgRXhwYW5kYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyaWdnZXIgPSB0aGlzLnRyaWdnZXI7XG5cbiAgICAgICAgW1xuICAgICAgICAgICAgJ2NoLWV4cGFuZGFibGUtdHJpZ2dlcicsXG4gICAgICAgICAgICAnY2gtZXhwYW5kYWJsZS1pY28nLFxuICAgICAgICAgICAgJ2NoLXVzZXItbm8tc2VsZWN0J1xuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24oY2xhc3NOYW1lKXtcbiAgICAgICAgICAgIHRpbnkucmVtb3ZlQ2xhc3ModHJpZ2dlciwgY2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyLnJlbW92ZUF0dHJpYnV0ZSgndW5zZWxlY3RhYmxlJyk7XG4gICAgICAgIHRoaXMudHJpZ2dlci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKTtcbiAgICAgICAgdGlueS5yZW1vdmVDbGFzcyh0aGlzLmNvbnRhaW5lciwgJ2NoLWV4cGFuZGFibGUtY29udGFpbmVyJyk7XG4gICAgICAgIHRpbnkucmVtb3ZlQ2xhc3ModGhpcy5jb250YWluZXIsICdjaC1oaWRlJyk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG5cbiAgICAgICAgdGlueS50cmlnZ2VyKHdpbmRvdy5kb2N1bWVudCwgY2gub25sYXlvdXRjaGFuZ2UpO1xuXG4gICAgICAgIHBhcmVudC5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICAvLyBGYWN0b3JpemVcbiAgICBjaC5mYWN0b3J5KEV4cGFuZGFibGUsIG5vcm1hbGl6ZU9wdGlvbnMpO1xuXG59KHRoaXMsIHRoaXMuY2gpKTtcblxuKGZ1bmN0aW9uICh3aW5kb3csIGNoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogTWVudSBsZXRzIHlvdSBvcmdhbml6ZSB0aGUgbGlua3MgYnkgY2F0ZWdvcmllcy5cbiAgICAgKiBAbWVtYmVyb2YgY2hcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgY2guQ29tcG9uZW50XG4gICAgICogQHJlcXVpcmVzIGNoLkV4cGFuZGFibGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBBIEhUTUxFbGVtZW50IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBjaC5NZW51LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBjdXN0b21pemUgYW4gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZ4XSBFbmFibGUgb3IgZGlzYWJsZSBVSSBlZmZlY3RzLiBZb3Ugc2hvdWxkIHVzZTogXCJzbGlkZURvd25cIiwgXCJmYWRlSW5cIiBvciBcIm5vbmVcIi4gRGVmYXVsdDogXCJzbGlkZURvd25cIi5cbiAgICAgKiBAcmV0dXJucyB7bWVudX0gUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBNZW51LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IE1lbnUuXG4gICAgICogdmFyIG1lbnUgPSBuZXcgY2guTWVudShlbCwgW29wdGlvbnNdKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBNZW51IHdpdGggY3VzdG9tIG9wdGlvbnMuXG4gICAgICogdmFyIG1lbnUgPSBuZXcgY2guTWVudSh7XG4gICAgICogICAgICdmeCc6ICdub25lJ1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lbnUoZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhhdC5faW5pdChlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHlvdSBkZWZpbmUgYW4gaW5pdGlhbGl6ZSBtZXRob2QsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhIG5ldyBNZW51IGlzIGNyZWF0ZWQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YhIGNoLk1lbnUucHJvdG90eXBlXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgcmVhZHkgdG8gdXNlLlxuICAgICAgICAgKiBAZXZlbnQgY2guTWVudSNyZWFkeVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJyZWFkeVwiIGV2ZW50LlxuICAgICAgICAgKiBtZW51Lm9uKCdyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhhdC5lbWl0KCdyZWFkeScpOyB9LCA1MCk7XG4gICAgfVxuXG4gICAgLy8gSW5oZXJpdGFuY2VcbiAgICB0aW55LmluaGVyaXRzKE1lbnUsIGNoLkNvbXBvbmVudCk7XG5cbiAgICB2YXIgcGFyZW50ID0gTWVudS5zdXBlcl8ucHJvdG90eXBlLFxuXG4gICAgICAgIC8vIENyZWF0ZXMgbWV0aG9kcyBlbmFibGUgYW5kIGRpc2FibGUgaW50byB0aGUgcHJvdG90eXBlLlxuICAgICAgICBtZXRob2RzID0gWydlbmFibGUnLCAnZGlzYWJsZSddLFxuICAgICAgICBsZW4gPSBtZXRob2RzLmxlbmd0aDtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZHMobWV0aG9kKSB7XG4gICAgICAgIE1lbnUucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIGZvbGQgPSB0aGlzLmZvbGRzW2NoaWxkIC0gMV07XG5cbiAgICAgICAgICAgIC8vIEVuYWJsZXMgb3IgZGlzYWJsZXMgYSBzcGVjaWZpYyBleHBhbmRhYmxlIGZvbGRcbiAgICAgICAgICAgIGlmIChmb2xkICYmIGZvbGQubmFtZSA9PT0gJ2V4cGFuZGFibGUnKSB7XG5cbiAgICAgICAgICAgICAgICBmb2xkW21ldGhvZF0oKTtcblxuICAgICAgICAgICAgLy8gRW5hYmxlcyBvciBkaXNhYmxlcyBFeHBhbmRhYmxlIGZvbGRzXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaSA9IHRoaXMuZm9sZHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGkpIHtcblxuICAgICAgICAgICAgICAgICAgICBmb2xkID0gdGhpcy5mb2xkc1tpIC09IDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xkLm5hbWUgPT09ICdleHBhbmRhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZFttZXRob2RdKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBFeGVjdXRlcyBwYXJlbnQgbWV0aG9kXG4gICAgICAgICAgICAgICAgcGFyZW50W21ldGhvZF0uY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZXMgXCJhcmlhLWRpc2FibGVkXCIgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgdGhpcy5fZWwuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgIXRoaXMuX2VuYWJsZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBtZW1iZXJvZiEgY2guTWVudS5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLm5hbWUgPSAnbWVudSc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLk1lbnUucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZW51O1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5fZGVmYXVsdHMgPSB7XG4gICAgICAgICdmeCc6ICdzbGlkZURvd24nXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSBuZXcgaW5zdGFuY2Ugb2YgTWVudSBhbmQgbWVyZ2UgY3VzdG9tIG9wdGlvbnMgd2l0aCBkZWZhdWx0cyBvcHRpb25zLlxuICAgICAqIEBtZW1iZXJvZiEgY2guTWVudS5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHttZW51fVxuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENhbGwgdG8gaXRzIHBhcmVudCBpbml0IG1ldGhvZFxuICAgICAgICBwYXJlbnQuX2luaXQuY2FsbCh0aGlzLCBlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gY2xvbmVOb2RlKHRydWUpID4gcGFyYW1ldGVycyBpcyByZXF1aXJlZC4gT3BlcmEgJiBJRSB0aHJvd3MgYW5kIGludGVybmFsIGVycm9yLiBPcGVyYSBtb2JpbGUgYnJlYWtzLlxuICAgICAgICB0aGlzLl9zbmlwcGV0ID0gdGhpcy5fZWwuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWVudSBjb250YWluZXIuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5fZWw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncm9sZScsICduYXZpZ2F0aW9uJyk7XG4gICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsICdjaC1tZW51Jyk7XG5cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5fY2xhc3NOYW1lID8gdGlueS5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgdGhpcy5fb3B0aW9ucy5fY2xhc3NOYW1lKSA6IG51bGw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYWRkQ2xhc3MgPyB0aW55LmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCB0aGlzLl9vcHRpb25zLmFkZENsYXNzKSA6IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY29sbGVjdGlvbiBvZiBmb2xkcy5cbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2xkcyA9IFtdO1xuXG4gICAgICAgIC8vIEluaXRzIGFuIGV4cGFuZGFibGUgY29tcG9uZW50IG9uIGVhY2ggbGlzdCBpbnNpZGUgbWFpbiBIVE1MIGNvZGUgc25pcHBldFxuICAgICAgICB0aGlzLl9jcmVhdGVFeHBhbmRhYmxlcygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0cyBhbiBFeHBhbmRhYmxlIGNvbXBvbmVudCBvbiBlYWNoIGxpc3QgaW5zaWRlIG1haW4gSFRNTCBjb2RlIHNuaXBwZXQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5fY3JlYXRlRXhwYW5kYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgY2hpbGQ7XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRXhwYW5kYWJsZShsaSwgaSkge1xuICAgICAgICAgICAgdmFyIGV4cGFuZGFibGUsXG4gICAgICAgICAgICAgICAgbWVudTtcblxuICAgICAgICAgICAgLy8gTGlzdCBlbGVtZW50XG4gICAgICAgICAgICB0aW55LmFkZENsYXNzKGxpLCAnY2gtbWVudS1mb2xkJyk7XG5cbiAgICAgICAgICAgIC8vIENoaWxkcmVuIG9mIGxpc3QgZWxlbWVudHNcbiAgICAgICAgICAgIGNoaWxkID0gbGkuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIC8vIEFuY2hvciBpbnNpZGUgbGlzdFxuICAgICAgICAgICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09ICdBJykge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhdHRyIHJvbGUgdG8gbWF0Y2ggd2FpLWFyaWFcbiAgICAgICAgICAgICAgICBsaS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB0aW55LmFkZENsYXNzKGNoaWxkLCAnY2gtZm9sZC10cmlnZ2VyJyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGFuY2hvciB0byB0aGF0LmZvbGRcbiAgICAgICAgICAgICAgICB0aGF0LmZvbGRzLnB1c2goY2hpbGQpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExpc3QgaW5zaWRlIGxpc3QsIGluaXRzIGFuIEV4cGFuZGFibGVcbiAgICAgICAgICAgICAgICBleHBhbmRhYmxlID0gbmV3IGNoLkV4cGFuZGFibGUoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdy9oaWRlIG9uIElFOC0gaW5zdGVhZCBzbGlkZVVwL3NsaWRlRG93blxuICAgICAgICAgICAgICAgICAgICAnZngnOiB0aGF0Ll9vcHRpb25zLmZ4XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBleHBhbmRhYmxlXG4gICAgICAgICAgICAgICAgICAgIC5vbignc2hvdycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBtZW51IHNob3dzIGEgZm9sZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBldmVudCBjaC5NZW51I3Nob3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJzaG93XCIgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBtZW51Lm9uKCdzaG93JywgZnVuY3Rpb24gKHNob3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5lbWl0KCdzaG93JywgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAub24oJ2hpZGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgbWVudSBoaWRlcyBhIGZvbGQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnQgY2guTWVudSNoaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwiaGlkZVwiIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICogbWVudS5vbignaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmVtaXQoJ2hpZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtZW51ID0gdGlueS5uZXh0KGNoaWxkKTtcbiAgICAgICAgICAgICAgICBtZW51LnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51Jyk7XG5cbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG1lbnUuY2hpbGRyZW4sIGZ1bmN0aW9uIChpdGVtKXtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW5bMF0gPyBpdGVtLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51aXRlbScpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBleHBhbmRhYmxlIHRvIHRoYXQuZm9sZFxuICAgICAgICAgICAgICAgIHRoYXQuZm9sZHMucHVzaChleHBhbmRhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGhpcy5jb250YWluZXIuY2hpbGRyZW4sIGNyZWF0ZUV4cGFuZGFibGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIHNwZWNpZmljIGZvbGQuXG4gICAgICogQG1lbWJlcm9mISBjaC5NZW51LnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGlsZCAtIEEgZ2l2ZW4gbnVtYmVyIG9mIGZvbGQuXG4gICAgICogQHJldHVybnMge21lbnV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaG93cyB0aGUgc2Vjb25kIGZvbGQuXG4gICAgICogbWVudS5zaG93KDIpO1xuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoY2hpbGQpIHtcblxuICAgICAgICB0aGlzLmZvbGRzW2NoaWxkIC0gMV0uc2hvdygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIaWRlcyBhIHNwZWNpZmljIGZvbGQuXG4gICAgICogQG1lbWJlcm9mISBjaC5NZW51LnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGlsZCAtIEEgZ2l2ZW4gbnVtYmVyIG9mIGZvbGQuXG4gICAgICogQHJldHVybnMge21lbnV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBIaWRlcyB0aGUgc2Vjb25kIGZvbGQuXG4gICAgICogbWVudS5oaWRlKDIpO1xuICAgICAqL1xuICAgIE1lbnUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoY2hpbGQpIHtcblxuICAgICAgICB0aGlzLmZvbGRzW2NoaWxkIC0gMV0uaGlkZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdG8gbWFuYWdlIHRoZSBtZW51IGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZvbGQgQSBnaXZlbiBmb2xkIHRvIGNoYW5nZSBpdHMgY29udGVudC5cbiAgICAgKiBAcGFyYW0geyhTdHJpbmcgfCBIVE1MRWxlbWVudCl9IGNvbnRlbnQgVGhlIGNvbnRlbnQgdGhhdCB3aWxsIGJlIHVzZWQgYnkgYSBmb2xkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBjdXN0b20gb3B0aW9ucyB0byBiZSB1c2VkIHdpdGggY29udGVudCBsb2FkZWQgYnkgYWpheC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWV0aG9kXSBUaGUgdHlwZSBvZiByZXF1ZXN0IChcIlBPU1RcIiBvciBcIkdFVFwiKSB0byBsb2FkIGNvbnRlbnQgYnkgYWpheC4gRGVmYXVsdDogXCJHRVRcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFyYW1zXSBQYXJhbXMgbGlrZSBxdWVyeSBzdHJpbmcgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2FjaGVdIEZvcmNlIHRvIGNhY2hlIHRoZSByZXF1ZXN0IGJ5IHRoZSBicm93c2VyLiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXN5bmNdIEZvcmNlIHRvIHNlbnQgcmVxdWVzdCBhc3luY2hyb25vdXNseS4gRGVmYXVsdDogdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyhTdHJpbmcgfCBIVE1MRWxlbWVudCl9IFtvcHRpb25zLndhaXRpbmddIFRlbXBvcmFyeSBjb250ZW50IHRvIHVzZSB3aGlsZSB0aGUgYWpheCByZXF1ZXN0IGlzIGxvYWRpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBVcGRhdGVzIHRoZSBjb250ZW50IG9mIHRoZSBzZWNvbmQgZm9sZCB3aXRoIHNvbWUgc3RyaW5nLlxuICAgICAqIG1lbnUuY29udGVudCgyLCAnaHR0cDovL2FqYXguY29tJywgeydjYWNoZSc6IGZhbHNlfSk7XG4gICAgICovXG4gICAgTWVudS5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIChmb2xkLCBjb250ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChmb2xkID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGZvbGQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgd2luZG93LkVycm9yKCdNZW51LmNvbnRlbnQoZm9sZCwgY29udGVudCwgb3B0aW9ucyk6IEV4cGVjdGVkIG51bWJlciBvZiBmb2xkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9sZHNbZm9sZCAtIDFdLmNvbnRlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZm9sZHNbZm9sZCAtIDFdLmNvbnRlbnQoY29udGVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgY3JlYXRlTWV0aG9kcyhtZXRob2RzW2xlbiAtPSAxXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBNZW51IGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJvZiEgY2guTWVudS5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIERlc3Ryb3kgYSBtZW51XG4gICAgICogbWVudS5kZXN0cm95KCk7XG4gICAgICogLy8gRW1wdHkgdGhlIG1lbnUgcmVmZXJlbmNlXG4gICAgICogbWVudSA9IHVuZGVmaW5lZDtcbiAgICAgKi9cbiAgICBNZW51LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMuZm9sZHMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUuZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2VsLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRoaXMuX3NuaXBwZXQsIHRoaXMuX2VsKTtcblxuICAgICAgICB0aW55LnRyaWdnZXIod2luZG93LmRvY3VtZW50LCBjaC5vbmxheW91dGNoYW5nZSk7XG5cbiAgICAgICAgcGFyZW50LmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIGNoLmZhY3RvcnkoTWVudSk7XG5cbn0odGhpcywgdGhpcy5jaCkpO1xuXG4oZnVuY3Rpb24gKHdpbmRvdywgY2gpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBQb3BvdmVyIGlzIHRoZSBiYXNpYyB1bml0IG9mIGEgZGlhbG9nIHdpbmRvdy5cbiAgICAgKiBAbWVtYmVyb2YgY2hcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgY2guQ29tcG9uZW50XG4gICAgICogQG1peGVzIGNoLkNvbGxhcHNpYmxlXG4gICAgICogQG1peGVzIGNoLkNvbnRlbnRcbiAgICAgKiBAcmVxdWlyZXMgY2guUG9zaXRpb25lclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEEgSFRNTEVsZW1lbnQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIGNoLlBvcG92ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRvIGN1c3RvbWl6ZSBhbiBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWRkQ2xhc3NdIENTUyBjbGFzcyBuYW1lcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGNvbnRhaW5lciBvbiB0aGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5meF0gRW5hYmxlIG9yIGRpc2FibGUgVUkgZWZmZWN0cy4gWW91IG11c3QgdXNlOiBcInNsaWRlRG93blwiLCBcImZhZGVJblwiIG9yIFwibm9uZVwiLiBEZWZhdWx0OiBcImZhZGVJblwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53aWR0aF0gU2V0IGEgd2lkdGggZm9yIHRoZSBjb250YWluZXIuIERlZmF1bHQ6IFwiYXV0b1wiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5oZWlnaHRdIFNldCBhIGhlaWdodCBmb3IgdGhlIGNvbnRhaW5lci4gRGVmYXVsdDogXCJhdXRvXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNob3duYnldIERldGVybWluZXMgaG93IHRvIGludGVyYWN0IHdpdGggdGhlIHRyaWdnZXIgdG8gc2hvdyB0aGUgY29udGFpbmVyLiBZb3UgbXVzdCB1c2U6IFwicG9pbnRlcnRhcFwiLCBcInBvaW50ZXJlbnRlclwiIG9yIFwibm9uZVwiLiBEZWZhdWx0OiBcInBvaW50ZXJ0YXBcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaGlkZGVuYnldIERldGVybWluZXMgaG93IHRvIGhpZGUgdGhlIGNvbXBvbmVudC4gWW91IG11c3QgdXNlOiBcImJ1dHRvblwiLCBcInBvaW50ZXJzXCIsIFwicG9pbnRlcmxlYXZlXCIsIFwiYWxsXCIgb3IgXCJub25lXCIuIERlZmF1bHQ6IFwiYnV0dG9uXCIuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW29wdGlvbnMucmVmZXJlbmNlXSBJdCdzIGEgSFRNTEVsZW1lbnQgcmVmZXJlbmNlIHRvIHBvc2l0aW9uIGFuZCBzaXplIG9mIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGNvbnNpZGVyZWQgdG8gY2Fycnkgb3V0IHRoZSBwb3NpdGlvbi4gRGVmYXVsdDogdGhlIHRyaWdnZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2lkZV0gVGhlIHNpZGUgb3B0aW9uIHdoZXJlIHRoZSB0YXJnZXQgZWxlbWVudCB3aWxsIGJlIHBvc2l0aW9uZWQuIEl0cyB2YWx1ZSBjYW4gYmU6IFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wXCIsIFwiYm90dG9tXCIgb3IgXCJjZW50ZXJcIi4gRGVmYXVsdDogXCJjZW50ZXJcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWxpZ25dIFRoZSBhbGlnbiBvcHRpb25zIHdoZXJlIHRoZSB0YXJnZXQgZWxlbWVudCB3aWxsIGJlIHBvc2l0aW9uZWQuIEl0cyB2YWx1ZSBjYW4gYmU6IFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wXCIsIFwiYm90dG9tXCIgb3IgXCJjZW50ZXJcIi4gRGVmYXVsdDogXCJjZW50ZXJcIi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WF0gRGlzdGFuY2UgdG8gZGlzcGxhY2UgdGhlIHRhcmdldCBob3Jpem9udGFsbHkuIERlZmF1bHQ6IDAuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFldIERpc3RhbmNlIHRvIGRpc3BsYWNlIHRoZSB0YXJnZXQgdmVydGljYWxseS4gRGVmYXVsdDogMC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb25dIFRoZSB0eXBlIG9mIHBvc2l0aW9uaW5nIHVzZWQuIEl0cyB2YWx1ZSBtdXN0IGJlIFwiYWJzb2x1dGVcIiBvciBcImZpeGVkXCIuIERlZmF1bHQ6IFwiYWJzb2x1dGVcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWV0aG9kXSBUaGUgdHlwZSBvZiByZXF1ZXN0IChcIlBPU1RcIiBvciBcIkdFVFwiKSB0byBsb2FkIGNvbnRlbnQgYnkgYWpheC4gRGVmYXVsdDogXCJHRVRcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFyYW1zXSBQYXJhbXMgbGlrZSBxdWVyeSBzdHJpbmcgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2FjaGVdIEZvcmNlIHRvIGNhY2hlIHRoZSByZXF1ZXN0IGJ5IHRoZSBicm93c2VyLiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXN5bmNdIEZvcmNlIHRvIHNlbnQgcmVxdWVzdCBhc3luY2hyb25vdXNseS4gRGVmYXVsdDogdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyhTdHJpbmcgfCBIVE1MRWxlbWVudCl9IFtvcHRpb25zLndhaXRpbmddIFRlbXBvcmFyeSBjb250ZW50IHRvIHVzZSB3aGlsZSB0aGUgYWpheCByZXF1ZXN0IGlzIGxvYWRpbmcuIERlZmF1bHQ6ICcmbHQ7ZGl2IGNsYXNzPVwiY2gtbG9hZGluZyBjaC1sb2FkaW5nLWNlbnRlcmVkXCImZ3Q7Jmx0Oy9kaXYmZ3Q7Jy5cbiAgICAgKiBAcGFyYW0geyhTdHJpbmcgfCBIVE1MRWxlbWVudCl9IFtvcHRpb25zLmNvbnRlbnRdIFRoZSBjb250ZW50IHRvIGJlIHNob3duIGludG8gdGhlIFBvcG92ZXIgY29udGFpbmVyLlxuICAgICAqIEBwYXJhbSB7KEJvb2xlYW4gfCBTdHJpbmcpfSBbb3B0aW9ucy53cmFwcGVyXSBXcmFwIHRoZSByZWZlcmVuY2UgZWxlbWVudCBhbmQgcGxhY2UgdGhlIGNvbnRhaW5lciBpbnRvIGl0IGluc3RlYWQgb2YgYm9keS4gV2hlbiB2YWx1ZSBpcyBhIHN0cmluZyBpdCB3aWxsIGJlIGFwcGxpZWQgYXMgYWRkaXRpb25hbCB3cmFwcGVyIGNsYXNzLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtwb3BvdmVyfSBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIFBvcG92ZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBQb3BvdmVyLlxuICAgICAqIHZhciBwb3BvdmVyID0gbmV3IGNoLlBvcG92ZXIoW2VsXSwgW29wdGlvbnNdKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBQb3BvdmVyIHdpdGggZGlzYWJsZWQgZWZmZWN0cy5cbiAgICAgKiB2YXIgcG9wb3ZlciA9IG5ldyBjaC5Qb3BvdmVyKGVsLCB7XG4gICAgICogICAgICdmeCc6ICdub25lJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IFBvcG92ZXIgdXNpbmcgdGhlIHNob3J0aGFuZCB3YXkgKGNvbnRlbnQgYXMgcGFyYW1ldGVyKS5cbiAgICAgKiB2YXIgcG9wb3ZlciA9IG5ldyBjaC5Qb3BvdmVyKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wb3BvdmVyJyksIHsnY29udGVudCc6ICdodHRwOi8vdWkubWwuY29tOjMwNDAvYWpheCd9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQb3BvdmVyKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gY29udGV4dCBvZiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICB0aGlzLl9pbml0KGVsLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgeW91IGRlZmluZSBhbiBpbml0aWFsaXplIG1ldGhvZCwgaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGEgbmV3IFBvcG92ZXIgaXMgY3JlYXRlZC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiEgY2guUG9wb3Zlci5wcm90b3R5cGVcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZWFkeSB0byB1c2UuXG4gICAgICAgICAqIEBldmVudCBjaC5Qb3BvdmVyI3JlYWR5XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcInJlYWR5XCIgZXZlbnQuXG4gICAgICAgICAqIHBvcG92ZXIub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aGF0LmVtaXQoJ3JlYWR5Jyk7IH0sIDUwKTtcbiAgICB9XG5cbiAgICAvLyBJbmhlcml0YW5jZVxuICAgIHRpbnkuaW5oZXJpdHMoUG9wb3ZlciwgY2guQ29tcG9uZW50KTtcblxuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICAgICAgcGFyZW50ID0gUG9wb3Zlci5zdXBlcl8ucHJvdG90eXBlLFxuICAgICAgICBzaG93bmJ5RXZlbnQgPSB7XG4gICAgICAgICAgICAncG9pbnRlcnRhcCc6IGNoLm9ucG9pbnRlcnRhcCxcbiAgICAgICAgICAgICdwb2ludGVyZW50ZXInOiBjaC5vbnBvaW50ZXJlbnRlclxuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlBvcG92ZXIucHJvdG90eXBlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5uYW1lID0gJ3BvcG92ZXInO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQG1lbWJlcm9mISBjaC5Qb3BvdmVyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIFBvcG92ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9wb3ZlcjtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gYnkgZGVmYXVsdC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlBvcG92ZXIucHJvdG90eXBlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBvcG92ZXIucHJvdG90eXBlLl9kZWZhdWx0cyA9IHtcbiAgICAgICAgJ19hcmlhUm9sZSc6ICdkaWFsb2cnLFxuICAgICAgICAnX2NsYXNzTmFtZSc6ICcnLFxuICAgICAgICAnX2hpZGVEZWxheSc6IDQwMCxcbiAgICAgICAgJ2FkZENsYXNzJzogJycsXG4gICAgICAgICdmeCc6ICdmYWRlSW4nLFxuICAgICAgICAnd2lkdGgnOiAnYXV0bycsXG4gICAgICAgICdoZWlnaHQnOiAnYXV0bycsXG4gICAgICAgICdzaG93bmJ5JzogJ3BvaW50ZXJ0YXAnLFxuICAgICAgICAnaGlkZGVuYnknOiAnYnV0dG9uJyxcbiAgICAgICAgJ3dhaXRpbmcnOiAnPGRpdiBjbGFzcz1cImNoLWxvYWRpbmcgY2gtbG9hZGluZy1jZW50ZXJlZFwiPjwvZGl2PicsXG4gICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICd3cmFwcGVyJzogZmFsc2VcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBpbnN0YW5jZSBvZiBQb3BvdmVyIGFuZCBtZXJnZSBjdXN0b20gb3B0aW9ucyB3aXRoIGRlZmF1bHRzIG9wdGlvbnMuXG4gICAgICogQG1lbWJlcm9mISBjaC5Qb3BvdmVyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3BvcG92ZXJ9XG4gICAgICovXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ2FsbCB0byBpdHMgcGFyZW50IGluaXQgbWV0aG9kXG4gICAgICAgIHBhcmVudC5faW5pdC5jYWxsKHRoaXMsIGVsLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBSZXF1aXJlIGFiaWxpdGllc1xuICAgICAgICB0aGlzLnJlcXVpcmUoJ0NvbGxhcHNpYmxlJywgJ0NvbnRlbnQnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICB0aGlzLl9jb25maWd1cmVXcmFwcGVyKCk7XG5cbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IFtcbiAgICAgICAgICAgICc8ZGl2JyxcbiAgICAgICAgICAgICcgY2xhc3M9XCJjaC1wb3BvdmVyIGNoLWhpZGUgJyArIHRoaXMuX29wdGlvbnMuX2NsYXNzTmFtZSArICcgJyArIHRoaXMuX29wdGlvbnMuYWRkQ2xhc3MgK1xuICAgICAgICAgICAgICAgICh0aW55LnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLl9vcHRpb25zLmZ4ICE9PSAnbm9uZScgJiYgdGhpcy5fb3B0aW9ucy5meCAhPT0gZmFsc2UgPyAnIGNoLWZ4JyA6ICcnKSArICdcIicsXG4gICAgICAgICAgICAnIHJvbGU9XCInICsgdGhpcy5fb3B0aW9ucy5fYXJpYVJvbGUgKyAnXCInLFxuICAgICAgICAgICAgJyBpZD1cImNoLScgKyB0aGlzLm5hbWUgKyAnLScgKyB0aGlzLnVpZCArICdcIicsXG4gICAgICAgICAgICAnIHN0eWxlPVwid2lkdGg6JyArIHRoaXMuX29wdGlvbnMud2lkdGggKyAnO2hlaWdodDonICsgdGhpcy5fb3B0aW9ucy5oZWlnaHQgKyAnXCInLFxuICAgICAgICAgICAgJz48L2Rpdj4nXG4gICAgICAgIF0uam9pbignJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwb3BvdmVyIGNvbnRhaW5lci4gSXQncyB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgc2hvd24gYW5kIGhpZGRlbi5cbiAgICAgICAgICogQHR5cGUge0hUTUxEaXZFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignZGl2Jyk7XG5cbiAgICAgICAgdGlueS5vbih0aGlzLmNvbnRhaW5lciwgY2gub25wb2ludGVydGFwLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRWxlbWVudCB3aGVyZSB0aGUgY29udGVudCB3aWxsIGJlIGFkZGVkLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgdGlueS5hZGRDbGFzcyh0aGlzLl9jb250ZW50LCAnY2gtcG9wb3Zlci1jb250ZW50Jyk7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY29udGVudCk7XG5cbiAgICAgICAgLy8gQWRkIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIHRyaWdnZXIgaWYgaXQgZXhpc3RzXG4gICAgICAgIHRoaXMuX2NvbmZpZ3VyZVRyaWdnZXIoKTtcblxuICAgICAgICB0aGlzLl9wb3NpdGlvbmVyID0gbmV3IGNoLlBvc2l0aW9uZXIoe1xuICAgICAgICAgICAgJ3RhcmdldCc6IHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgICAgJ3JlZmVyZW5jZSc6IHRoaXMuX29wdGlvbnMucmVmZXJlbmNlLFxuICAgICAgICAgICAgJ3NpZGUnOiB0aGlzLl9vcHRpb25zLnNpZGUsXG4gICAgICAgICAgICAnYWxpZ24nOiB0aGlzLl9vcHRpb25zLmFsaWduLFxuICAgICAgICAgICAgJ29mZnNldFgnOiB0aGlzLl9vcHRpb25zLm9mZnNldFgsXG4gICAgICAgICAgICAnb2Zmc2V0WSc6IHRoaXMuX29wdGlvbnMub2Zmc2V0WSxcbiAgICAgICAgICAgICdwb3NpdGlvbic6IHRoaXMuX29wdGlvbnMucG9zaXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXIgdG8gZXhlY3V0ZSB0aGUgcG9zaXRpb25lciByZWZyZXNoKCkgbWV0aG9kIG9uIGxheW91dCBjaGFuZ2VzLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHRvZG8gRGVmaW5lIHRoaXMgZnVuY3Rpb24gb24gcHJvdG90eXBlIGFuZCB1c2UgYmluZCgpOiAkZG9jdW1lbnQub24oY2gub25sYXlvdXRjaGFuZ2UsIHRoaXMucmVmcmVzaFBvc2l0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVmcmVzaFBvc2l0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5fc2hvd24pIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9wb3NpdGlvbmVyLnJlZnJlc2gob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2hpZGVUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuX3RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5oaWRlKCk7XG4gICAgICAgICAgICB9LCB0aGF0Ll9vcHRpb25zLl9oaWRlRGVsYXkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2hpZGVUaW1lckNsZWFuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoYXQuX3RpbWVvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENvbmZpZ3VyZSB0aGUgd2F5IGl0IGhpZGVzXG4gICAgICAgIHRoaXMuX2NvbmZpZ3VyZUhpZGluZygpO1xuXG4gICAgICAgIC8vIFJlZnJlc2ggcG9zaXRpb246XG4gICAgICAgIC8vIG9uIGxheW91dCBjaGFuZ2VcbiAgICAgICAgdGlueS5vbihkb2N1bWVudCwgY2gub25sYXlvdXRjaGFuZ2UsIHRoaXMuX3JlZnJlc2hQb3NpdGlvbkxpc3RlbmVyKTtcbiAgICAgICAgLy8gb24gcmVzaXplXG4gICAgICAgIGNoLnZpZXdwb3J0Lm9uKGNoLm9ucmVzaXplLCB0aGlzLl9yZWZyZXNoUG9zaXRpb25MaXN0ZW5lcik7XG5cbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLm9uY2UoJ19zaG93JywgdGhpcy5fcmVmcmVzaFBvc2l0aW9uTGlzdGVuZXIpXG4gICAgICAgICAgICAvLyBvbiBjb250ZW50IGNoYW5nZVxuICAgICAgICAgICAgLm9uKCdfY29udGVudGNoYW5nZScsIHRoaXMuX3JlZnJlc2hQb3NpdGlvbkxpc3RlbmVyKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBmdW5jdGlvbmFsaXR5IHRvIHRoZSB0cmlnZ2VyLiBXaGVuIGEgbm9uLXRyaWdnZXIgcG9wb3ZlciBpcyBpbml0aWFsaXplZCwgdGhpcyBtZXRob2QgaXNuJ3QgZXhlY3V0ZWQuXG4gICAgICogQG1lbWJlcm9mISBjaC5Qb3BvdmVyLnByb3RvdHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX2NvbmZpZ3VyZVRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2VsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gY29udGV4dCBvZiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIC8vIEl0IHdpbGwgYmUgdHJpZ2dlcmVkIG9uIHBvaW50ZXJ0YXAvcG9pbnRlcmVudGVyIG9mIHRoZSAkdHJpZ2dlclxuICAgICAgICAgICAgLy8gSXQgY2FuIHRvZ2dsZSwgc2hvdywgb3IgZG8gbm90aGluZyAoaW4gc3BlY2lmaWMgY2FzZXMpXG4gICAgICAgICAgICBzaG93SGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9nZ2xlIGFzIGRlZmF1bHRcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSB0aGF0Ll90b2dnbGU7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhIFBvcG92ZXIgaXMgc2hvd24gb24gcG9pbnRlcmVudGVyLCBpdCB3aWxsIHNldCBhIHRpbWVvdXQgdG8gbWFuYWdlIHdoZW5cbiAgICAgICAgICAgICAgICAvLyB0byBjbG9zZSB0aGUgY29tcG9uZW50LiBBdm9pZCB0byB0b2dnbGUgYW5kIGxldCBjaG9pc2Ugd2hlbiB0byBjbG9zZSB0byB0aGUgdGltZXJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5fb3B0aW9ucy5zaG93bmJ5ID09PSAncG9pbnRlcmVudGVyJyB8fCB0aGF0Ll9vcHRpb25zLmhpZGRlbmJ5ID09PSAnbm9uZScgfHwgdGhhdC5fb3B0aW9ucy5oaWRkZW5ieSA9PT0gJ2J1dHRvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoYXQuX3Nob3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgfSgpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9yaWdpbmFsIGFuZCBlbnRpcmUgZWxlbWVudCBhbmQgaXRzIHN0YXRlLCBiZWZvcmUgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIC8vIGNsb25lTm9kZSh0cnVlKSA+IHBhcmFtZXRlcnMgaXMgcmVxdWlyZWQuIE9wZXJhICYgSUUgdGhyb3dzIGFuZCBpbnRlcm5hbCBlcnJvci4gT3BlcmEgbW9iaWxlIGJyZWFrcy5cbiAgICAgICAgdGhpcy5fc25pcHBldCA9IHRoaXMuX2VsLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICAvLyBVc2UgdGhlIHRyaWdnZXIgYXMgdGhlIHBvc2l0aW9uaW5nIHJlZmVyZW5jZVxuICAgICAgICB0aGlzLl9vcHRpb25zLnJlZmVyZW5jZSA9IHRoaXMuX29wdGlvbnMucmVmZXJlbmNlIHx8IHRoaXMuX2VsO1xuXG4gICAgICAgIC8vIE9wZW4gZXZlbnQgd2hlbiBjb25maWd1cmVkIGFzIGFibGUgdG8gc2hvd24gYW55d2F5XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNob3duYnkgIT09ICdub25lJykge1xuXG4gICAgICAgICAgICB0aW55LmFkZENsYXNzKHRoaXMuX2VsLCAnY2gtc2hvd25ieS0nICsgdGhpcy5fb3B0aW9ucy5zaG93bmJ5KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2hvd25ieSA9PT0gc2hvd25ieUV2ZW50LnBvaW50ZXJ0YXAgJiYgbmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGlueS5vbih0aGlzLl9lbCwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpbnkub24odGhpcy5fZWwsIHNob3duYnlFdmVudFt0aGlzLl9vcHRpb25zLnNob3duYnldLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHNob3dIYW5kbGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBhIGNvbnRlbnQgaWYgaXQncyBub3QgZGVmaW5lZFxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5jb250ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIENvbnRlbnQgZnJvbSBhbmNob3IgaHJlZlxuICAgICAgICAgICAgLy8gSUUgZGVmaW5lcyB0aGUgaHJlZiBhdHRyaWJ1dGUgZXF1YWwgdG8gc3JjIGF0dHJpYnV0ZSBvbiBpbWFnZXMuXG4gICAgICAgICAgICBpZiAodGhpcy5fZWwubm9kZU5hbWUgPT09ICdBJyAmJiB0aGlzLl9lbC5ocmVmICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY29udGVudCA9IHRoaXMuX2VsLmhyZWY7XG5cbiAgICAgICAgICAgIC8vIENvbnRlbnQgZnJvbSB0aXRsZSBvciBhbHRcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZWwudGl0bGUgIT09ICcnIHx8IHRoaXMuX2VsLmFsdCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5jb250ZW50ID0gdGhpcy5fZWwudGl0bGUgfHwgdGhpcy5fZWwuYWx0O1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgdGhlIGF0dHJpYnV0ZXMgY29udGVudCBpbnRvIHRoZSBlbGVtZW50IGZvciBwb3NzaWJsZSB1c2FnZVxuICAgICAgICAgICAgICAgIHRoaXMuX2VsLnNldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScsIHRoaXMuX29wdGlvbnMuY29udGVudCk7XG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgdG8gdHJpZ2dlciB0aGUgbmF0aXZlIHRvb2x0aXBcbiAgICAgICAgICAgICAgICB0aGlzLl9lbC50aXRsZSA9IHRoaXMuX2VsLmFsdCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IFdBSS1BUklBXG4gICAgICAgIHRoaXMuX2VsLnNldEF0dHJpYnV0ZSgnYXJpYS1vd25zJywgJ2NoLScgKyB0aGlzLm5hbWUgKyAnLScgKyB0aGlzLnVpZCk7XG4gICAgICAgIHRoaXMuX2VsLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsICd0cnVlJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwb3BvdmVyIHRyaWdnZXIuIEl0J3MgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIHNob3cgYW5kIGhpZGUgdGhlIGNvbnRhaW5lci5cbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyID0gdGhpcy5fZWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaG93IHRvIGhpZGUgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlBvcG92ZXIucHJvdG90eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5fY29uZmlndXJlSGlkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBoaWRkZW5ieSA9IHRoaXMuX29wdGlvbnMuaGlkZGVuYnksXG4gICAgICAgICAgICBkdW1teSxcbiAgICAgICAgICAgIGJ1dHRvbjtcblxuXG5cbiAgICAgICAgLy8gRG9uJ3QgaGlkZSBhbnl0aW1lXG4gICAgICAgIGlmIChoaWRkZW5ieSA9PT0gJ25vbmUnKSB7IHJldHVybjsgfVxuXG4gICAgICAgIC8vIEhpZGUgYnkgbGVhdmluZyB0aGUgY29tcG9uZW50XG4gICAgICAgIGlmIChoaWRkZW5ieSA9PT0gJ3BvaW50ZXJsZWF2ZScgJiYgdGhpcy50cmlnZ2VyICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgW3RoaXMudHJpZ2dlciwgdGhpcy5jb250YWluZXJdLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICB0aW55Lm9uKGVsLCBjaC5vbnBvaW50ZXJlbnRlciwgdGhhdC5faGlkZVRpbWVyQ2xlYW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFt0aGlzLnRyaWdnZXIsIHRoaXMuY29udGFpbmVyXS5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgdGlueS5vbihlbCwgY2gub25wb2ludGVybGVhdmUsIHRoYXQuX2hpZGVUaW1lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhpZGUgd2l0aCB0aGUgYnV0dG9uIENsb3NlXG4gICAgICAgIGlmIChoaWRkZW5ieSA9PT0gJ2J1dHRvbicgfHwgaGlkZGVuYnkgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZHVtbXkuaW5uZXJIVE1MID0gJzxpIGNsYXNzPVwiY2gtY2xvc2VcIiByb2xlPVwiYnV0dG9uXCIgYXJpYS1sYWJlbD1cIkNsb3NlXCI+PC9pPic7XG4gICAgICAgICAgICBidXR0b24gPSBkdW1teS5xdWVyeVNlbGVjdG9yKCdpJyk7XG5cbiAgICAgICAgICAgIHRpbnkub24oYnV0dG9uLCBjaC5vbnBvaW50ZXJ0YXAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoYnV0dG9uLCB0aGlzLmNvbnRhaW5lci5maXJzdENoaWxkKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChoaWRkZW5ieSA9PT0gJ3BvaW50ZXJzJyB8fCBoaWRkZW5ieSA9PT0gJ2FsbCcpICYmIHRoaXMuX2hpZGluZ1Nob3J0Y3V0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9oaWRpbmdTaG9ydGN1dHMoKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb3B0aW9ucyBvYmplY3QgZnJvbSB0aGUgcGFyYW1ldGVycyBhcnJpdmluZyB0byB0aGUgY29uc3RydWN0b3IgbWV0aG9kLlxuICAgICAqIEBtZW1iZXJvZiEgY2guUG9wb3Zlci5wcm90b3R5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIFBvcG92ZXIucHJvdG90eXBlLl9ub3JtYWxpemVPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gSUU4IGFuZCBlYXJsaWVyIGRvbid0IGRlZmluZSB0aGUgbm9kZSB0eXBlIGNvbnN0YW50cywgMSA9PT0gZG9jdW1lbnQuRUxFTUVOVF9OT0RFXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycgfHwgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zLm5vZGVUeXBlID09PSAxKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAnY29udGVudCc6IG9wdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgdXNlIHRoZSB3cmFwcGVyIGFzIHRoZSBwbGFjZW1lbnQgZm9yIGNvbnRhaW5lclxuICAgICAqIEBtZW1iZXJvZiEgY2guUG9wb3Zlci5wcm90b3R5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIFBvcG92ZXIucHJvdG90eXBlLl9jb25maWd1cmVXcmFwcGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9lbCB8fCB0aGlzLl9vcHRpb25zLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHdyYXBwZXIgPSB0aGlzLl9vcHRpb25zLndyYXBwZXI7XG5cbiAgICAgICAgaWYgKHdyYXBwZXIgJiYgdGFyZ2V0ICYmIHRhcmdldC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB3cmFwcGVyIGVsZW1lbnQgYW5kIGFwcGVuZCB0byBpdFxuICAgICAgICAgICAgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3Mod3JhcHBlciwgJ2NoLXBvcG92ZXItd3JhcHBlcicpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMud3JhcHBlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLndyYXBwZXIuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aW55LmFkZENsYXNzKHdyYXBwZXIsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpbnkucGFyZW50KHRhcmdldCkuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIHRhcmdldCk7XG4gICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRhcmdldCk7XG4gICAgICAgICAgICBpZiAodGlueS5jc3Mod3JhcHBlciwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICAgICAgdGlueS5jc3Mod3JhcHBlciwge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyV3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJXcmFwcGVyID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgcG9wb3ZlciBjb250YWluZXIgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGJvZHkuXG4gICAgICogQG1lbWJlcm9mISBjaC5Qb3BvdmVyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IEhUTUxFbGVtZW50KX0gW2NvbnRlbnRdIFRoZSBjb250ZW50IHRoYXQgd2lsbCBiZSB1c2VkIGJ5IHBvcG92ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGN1c3RvbSBvcHRpb25zIHRvIGJlIHVzZWQgd2l0aCBjb250ZW50IGxvYWRlZCBieSBhamF4LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2RdIFRoZSB0eXBlIG9mIHJlcXVlc3QgKFwiUE9TVFwiIG9yIFwiR0VUXCIpIHRvIGxvYWQgY29udGVudCBieSBhamF4LiBEZWZhdWx0OiBcIkdFVFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbXNdIFBhcmFtcyBsaWtlIHF1ZXJ5IHN0cmluZyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYWNoZV0gRm9yY2UgdG8gY2FjaGUgdGhlIHJlcXVlc3QgYnkgdGhlIGJyb3dzZXIuIERlZmF1bHQ6IHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hc3luY10gRm9yY2UgdG8gc2VudCByZXF1ZXN0IGFzeW5jaHJvbm91c2x5LiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IEhUTUxFbGVtZW50KX0gW29wdGlvbnMud2FpdGluZ10gVGVtcG9yYXJ5IGNvbnRlbnQgdG8gdXNlIHdoaWxlIHRoZSBhamF4IHJlcXVlc3QgaXMgbG9hZGluZy5cbiAgICAgKiBAcmV0dXJucyB7cG9wb3Zlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNob3dzIGEgYmFzaWMgcG9wb3Zlci5cbiAgICAgKiBwb3BvdmVyLnNob3coKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNob3dzIGEgcG9wb3ZlciB3aXRoIG5ldyBjb250ZW50XG4gICAgICogcG9wb3Zlci5zaG93KCdTb21lIG5ldyBjb250ZW50IGhlcmUhJyk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaG93cyBhIHBvcG92ZXIgd2l0aCBhIG5ldyBjb250ZW50IHRoYXQgd2lsbCBiZSBsb2FkZWQgYnkgYWpheCB3aXRoIHNvbWUgY3VzdG9tIG9wdGlvbnNcbiAgICAgKiBwb3BvdmVyLnNob3coJ2h0dHA6Ly9kb21haW4uY29tL2FqYXgvdXJsJywge1xuICAgICAqICAgICAnY2FjaGUnOiBmYWxzZSxcbiAgICAgKiAgICAgJ3BhcmFtcyc6ICd4LXJlcXVlc3Q9dHJ1ZSdcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gRG9uJ3QgZXhlY3V0ZSB3aGVuIGl0J3MgZGlzYWJsZWRcbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkIHx8IHRoaXMuX3Nob3duKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGVuZCB0byB0aGUgY29uZmlndXJlZCBob2xkZXJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyV3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG5cbiAgICAgICAgLy8gT3BlbiB0aGUgY29sbGFwc2libGVcbiAgICAgICAgdGhpcy5fc2hvdygpO1xuXG4gICAgICAgIC8vIFJlcXVlc3QgdGhlIGNvbnRlbnRcbiAgICAgICAgaWYgKGNvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50KGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBwb3BvdmVyIGNvbnRhaW5lciBhbmQgZGVsZXRlcyBpdCBmcm9tIHRoZSBib2R5LlxuICAgICAqIEBtZW1iZXJvZiEgY2guUG9wb3Zlci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7cG9wb3Zlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENsb3NlIGEgcG9wb3ZlclxuICAgICAqIHBvcG92ZXIuaGlkZSgpO1xuICAgICAqL1xuICAgIFBvcG92ZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgcGFyZW50O1xuICAgICAgICAvLyBEb24ndCBleGVjdXRlIHdoZW4gaXQncyBkaXNhYmxlZFxuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQgfHwgIXRoaXMuX3Nob3duKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGFjaCB0aGUgY29udGFpbmVyIGZyb20gdGhlIERPTSB3aGVuIGl0IGlzIGhpZGRlblxuICAgICAgICB0aGlzLm9uY2UoJ2hpZGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIER1ZSB0byB0cmFuc2l0aW9ucyB0aGlzLl9zaG93biBjYW4gYmUgb3V0ZGF0ZWQgaGVyZVxuICAgICAgICAgICAgcGFyZW50ID0gc2VsZi5jb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoc2VsZi5jb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDbG9zZSB0aGUgY29sbGFwc2libGVcbiAgICAgICAgdGhpcy5faGlkZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQm9vbGVhbiBzcGVjaWZ5aW5nIGlmIHRoZSBjb250YWluZXIgaXMgc2hvd24gb3Igbm90LlxuICAgICAqIEBtZW1iZXJvZiEgY2guUG9wb3Zlci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENoZWNrIHRoZSBwb3BvdmVyIHN0YXR1c1xuICAgICAqIHBvcG92ZXIuaXNTaG93bigpO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ2hlY2sgdGhlIHBvcG92ZXIgc3RhdHVzIGFmdGVyIGFuIHVzZXIgYWN0aW9uXG4gICAgICogJCh3aW5kb3cpLm9uKGNoLm9ucG9pbnRlcnRhcCwgZnVuY3Rpb24gKCkge1xuICAgICAqICAgICBpZiAocG9wb3Zlci5pc1Nob3duKCkpIHtcbiAgICAgKiAgICAgICAgIGFsZXJ0KCdQb3BvdmVyOiB2aXNpYmxlJyk7XG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgICBhbGVydCgnUG9wb3Zlcjogbm90IHZpc2libGUnKTtcbiAgICAgKiAgICAgfVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIFBvcG92ZXIucHJvdG90eXBlLmlzU2hvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93bjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyLlxuICAgICAqIEBtZW1iZXJvZiEgY2guUG9wb3Zlci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGFdIFNldCBhIHdpZHRoIGZvciB0aGUgY29udGFpbmVyLlxuICAgICAqIEByZXR1cm5zIHsoTnVtYmVyIHwgcG9wb3Zlcil9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTZXQgYSBuZXcgcG9wb3ZlciB3aWR0aFxuICAgICAqIGNvbXBvbmVudC53aWR0aCgnMzAwcHgnKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEdldCB0aGUgY3VycmVudCBwb3BvdmVyIHdpZHRoXG4gICAgICogY29tcG9uZW50LndpZHRoKCk7IC8vICczMDBweCdcbiAgICAgKi9cbiAgICBQb3BvdmVyLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGRhdGE7XG5cbiAgICAgICAgdGhpcy5fb3B0aW9ucy53aWR0aCA9IGRhdGE7XG5cbiAgICAgICAgdGhpcy5yZWZyZXNoUG9zaXRpb24oKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlBvcG92ZXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhXSBTZXQgYSBoZWlnaHQgZm9yIHRoZSBjb250YWluZXIuXG4gICAgICogQHJldHVybnMgeyhOdW1iZXIgfCBwb3BvdmVyKX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNldCBhIG5ldyBwb3BvdmVyIGhlaWdodFxuICAgICAqIGNvbXBvbmVudC5oZWlnaHQoJzMwMHB4Jyk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBHZXQgdGhlIGN1cnJlbnQgcG9wb3ZlciBoZWlnaHRcbiAgICAgKiBjb21wb25lbnQuaGVpZ2h0KCk7IC8vICczMDBweCdcbiAgICAgKi9cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGRhdGE7XG5cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5oZWlnaHQgPSBkYXRhO1xuXG4gICAgICAgIHRoaXMucmVmcmVzaFBvc2l0aW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lciB3aXRoIGdpdmVuIG9wdGlvbnMgb3IgZGVmYXVsdHMuXG4gICAgICogQG1lbWJlcm9mISBjaC5Qb3BvdmVyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbXMge09iamVjdH0gW29wdGlvbnNdIEEgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge3BvcG92ZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgKiBwb3BvdmVyLnJlZnJlc2hQb3NpdGlvbigpO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gVXBkYXRlIHRoZSBjdXJyZW50IHBvc2l0aW9uIHdpdGggYSBuZXcgb2Zmc2V0WCBhbmQgb2Zmc2V0WVxuICAgICAqIHBvcG92ZXIucmVmcmVzaFBvc2l0aW9uKHtcbiAgICAgKiAgICAgJ29mZmVzdFgnOiAxMDAsXG4gICAgICogICAgICdvZmZlc3RZJzogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5yZWZyZXNoUG9zaXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgICAgIGlmICh0aGlzLl9zaG93bikge1xuICAgICAgICAgICAgLy8gUmVmcmVzaCBpdHMgcG9zaXRpb24uXG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvbmVyLnJlZnJlc2gob3B0aW9ucyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBpdHMgb3B0aW9ucy4gSXQgd2lsbCB1cGRhdGUgcG9zaXRpb24gdGhlIG5leHQgdGltZSB0byBiZSBzaG93bi5cbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uZXIuX2NvbmZpZ3VyZShvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGEgUG9wb3ZlciBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlBvcG92ZXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge3BvcG92ZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBFbmFibGUgYSBwb3BvdmVyXG4gICAgICogcG9wb3Zlci5lbmFibGUoKTtcbiAgICAgKi9cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudC5lbmFibGUuY2FsbCh0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgYSBQb3BvdmVyIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJvZiEgY2guUG9wb3Zlci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7cG9wb3Zlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIERpc2FibGUgYSBwb3BvdmVyXG4gICAgICogcG9wb3Zlci5kaXNhYmxlKCk7XG4gICAgICovXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBpZiAodGhpcy5fZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZWwuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2hvd24pIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50LmRpc2FibGUuY2FsbCh0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBQb3BvdmVyIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJvZiEgY2guUG9wb3Zlci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7cG9wb3Zlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIERlc3Ryb3kgYSBwb3BvdmVyXG4gICAgICogcG9wb3Zlci5kZXN0cm95KCk7XG4gICAgICogLy8gRW1wdHkgdGhlIHBvcG92ZXIgcmVmZXJlbmNlXG4gICAgICogcG9wb3ZlciA9IHVuZGVmaW5lZDtcbiAgICAgKi9cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXIgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICB0aW55Lm9mZih0aGlzLnRyaWdnZXIsIGNoLm9ucG9pbnRlcmVudGVyLCB0aGlzLl9oaWRlVGltZXJDbGVhbmVyKTtcbiAgICAgICAgICAgIHRpbnkub2ZmKHRoaXMudHJpZ2dlciwgY2gub25wb2ludGVybGVhdmUsIHRoaXMuX2hpZGVUaW1lcik7XG5cbiAgICAgICAgICAgIHRpbnkucmVtb3ZlQ2xhc3ModGhpcy50cmlnZ2VyLCAnY2gtJyArIHRoaXMubmFtZSArICctdHJpZ2dlcicpO1xuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXRpdGxlJyk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW93bnMnKTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnKTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlci5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc2lkZScpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hbGlnbicpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyLnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuXG4gICAgICAgICAgICB0aGlzLl9zbmlwcGV0LmFsdCA/IHRoaXMudHJpZ2dlci5zZXRBdHRyaWJ1dGUoJ2FsdCcsIHRoaXMuX3NuaXBwZXQuYWx0KSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zbmlwcGV0LnRpdGxlID8gdGhpcy50cmlnZ2VyLnNldEF0dHJpYnV0ZSgndGl0bGUnLCB0aGlzLl9zbmlwcGV0LnRpdGxlKSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aW55Lm9mZihkb2N1bWVudCwgY2gub25sYXlvdXRjaGFuZ2UsIHRoaXMuX3JlZnJlc2hQb3NpdGlvbkxpc3RlbmVyKTtcblxuICAgICAgICBjaC52aWV3cG9ydC5yZW1vdmVMaXN0ZW5lcihjaC5vbnJlc2l6ZSwgdGhpcy5fcmVmcmVzaFBvc2l0aW9uTGlzdGVuZXIpO1xuXG4gICAgICAgIHBhcmVudC5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICBjaC5mYWN0b3J5KFBvcG92ZXIsIFBvcG92ZXIucHJvdG90eXBlLl9ub3JtYWxpemVPcHRpb25zKTtcblxufSh0aGlzLCB0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAod2luZG93LCBjaCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuICAgIGNoLlBvcG92ZXIucHJvdG90eXBlLl9oaWRpbmdTaG9ydGN1dHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhpZGUoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGV2ZW50LmJ1dHRvbiA9PT0gMDogRml4IGlzc3VlICM5MzMgUmlnaHQgY2xpY2sgY2xvc2VzIGl0IG9uIEZpcmVmb3guXG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGF0Ll9lbCAmJiBldmVudC50YXJnZXQgIT09IHRoYXQuY29udGFpbmVyICYmIGV2ZW50LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoYXQuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2guc2hvcnRjdXRzLmFkZChjaC5vbmtleWVzYywgdGhpcy51aWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuaGlkZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzXG4gICAgICAgICAgICAub24oJ3Nob3cnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2guc2hvcnRjdXRzLm9uKHRoYXQudWlkKTtcbiAgICAgICAgICAgICAgICB0aW55Lm9uKGRvY3VtZW50LCBjaC5vbnBvaW50ZXJ0YXAsIGhpZGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjaC5zaG9ydGN1dHMub2ZmKHRoYXQudWlkKTtcbiAgICAgICAgICAgICAgICB0aW55Lm9mZihkb2N1bWVudCwgY2gub25wb2ludGVydGFwLCBoaWRlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub25jZSgnZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjaC5zaG9ydGN1dHMucmVtb3ZlKHRoYXQudWlkLCBjaC5vbmtleWVzYyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuXG59KHRoaXMsIHRoaXMuY2gpKTtcblxuKGZ1bmN0aW9uICh3aW5kb3csIGNoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogTGF5ZXIgaXMgYSBkaWFsb2cgd2luZG93IHRoYXQgY2FuIGJlIHNob3duIG9uZSBhdCBhIHRpbWUuXG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIGNoLlBvcG92ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2VsXSBBIEhUTUxFbGVtZW50IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBjaC5MYXllci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gY3VzdG9taXplIGFuIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hZGRDbGFzc10gQ1NTIGNsYXNzIG5hbWVzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgY29udGFpbmVyIG9uIHRoZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZ4XSBFbmFibGUgb3IgZGlzYWJsZSBVSSBlZmZlY3RzLiBZb3UgbXVzdCB1c2U6IFwic2xpZGVEb3duXCIsIFwiZmFkZUluXCIgb3IgXCJub25lXCIuIERlZmF1bHQ6IFwiZmFkZUluXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndpZHRoXSBTZXQgYSB3aWR0aCBmb3IgdGhlIGNvbnRhaW5lci4gRGVmYXVsdDogXCJhdXRvXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhlaWdodF0gU2V0IGEgaGVpZ2h0IGZvciB0aGUgY29udGFpbmVyLiBEZWZhdWx0OiBcImF1dG9cIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2hvd25ieV0gRGV0ZXJtaW5lcyBob3cgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgdHJpZ2dlciB0byBzaG93IHRoZSBjb250YWluZXIuIFlvdSBtdXN0IHVzZTogXCJwb2ludGVydGFwXCIsIFwicG9pbnRlcmVudGVyXCIgb3IgXCJub25lXCIuIERlZmF1bHQ6IFwicG9pbnRlcmVudGVyXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhpZGRlbmJ5XSBEZXRlcm1pbmVzIGhvdyB0byBoaWRlIHRoZSBjb21wb25lbnQuIFlvdSBtdXN0IHVzZTogXCJidXR0b25cIiwgXCJwb2ludGVyc1wiLCBcInBvaW50ZXJsZWF2ZVwiLCBcImFsbFwiIG9yIFwibm9uZVwiLiBEZWZhdWx0OiBcInBvaW50ZXJsZWF2ZVwiLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtvcHRpb25zLnJlZmVyZW5jZV0gSXQncyBhIHJlZmVyZW5jZSB0byBwb3NpdGlvbiBhbmQgc2l6ZSBvZiBlbGVtZW50IHRoYXQgd2lsbCBiZSBjb25zaWRlcmVkIHRvIGNhcnJ5IG91dCB0aGUgcG9zaXRpb24uIERlZmF1bHQ6IHRoZSB0cmlnZ2VyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNpZGVdIFRoZSBzaWRlIG9wdGlvbiB3aGVyZSB0aGUgdGFyZ2V0IGVsZW1lbnQgd2lsbCBiZSBwb3NpdGlvbmVkLiBJdHMgdmFsdWUgY2FuIGJlOiBcImxlZnRcIiwgXCJyaWdodFwiLCBcInRvcFwiLCBcImJvdHRvbVwiIG9yIFwiY2VudGVyXCIuIERlZmF1bHQ6IFwiYm90dG9tXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFsaWduXSBUaGUgYWxpZ24gb3B0aW9ucyB3aGVyZSB0aGUgdGFyZ2V0IGVsZW1lbnQgd2lsbCBiZSBwb3NpdGlvbmVkLiBJdHMgdmFsdWUgY2FuIGJlOiBcImxlZnRcIiwgXCJyaWdodFwiLCBcInRvcFwiLCBcImJvdHRvbVwiIG9yIFwiY2VudGVyXCIuIERlZmF1bHQ6IFwibGVmdFwiLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRYXSBEaXN0YW5jZSB0byBkaXNwbGFjZSB0aGUgdGFyZ2V0IGhvcml6b250YWxseS4gRGVmYXVsdDogMC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WV0gRGlzdGFuY2UgdG8gZGlzcGxhY2UgdGhlIHRhcmdldCB2ZXJ0aWNhbGx5LiBEZWZhdWx0OiAxMC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb25dIFRoZSB0eXBlIG9mIHBvc2l0aW9uaW5nIHVzZWQuIEl0cyB2YWx1ZSBtdXN0IGJlIFwiYWJzb2x1dGVcIiBvciBcImZpeGVkXCIuIERlZmF1bHQ6IFwiYWJzb2x1dGVcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWV0aG9kXSBUaGUgdHlwZSBvZiByZXF1ZXN0IChcIlBPU1RcIiBvciBcIkdFVFwiKSB0byBsb2FkIGNvbnRlbnQgYnkgYWpheC4gRGVmYXVsdDogXCJHRVRcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFyYW1zXSBQYXJhbXMgbGlrZSBxdWVyeSBzdHJpbmcgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2FjaGVdIEZvcmNlIHRvIGNhY2hlIHRoZSByZXF1ZXN0IGJ5IHRoZSBicm93c2VyLiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXN5bmNdIEZvcmNlIHRvIHNlbnQgcmVxdWVzdCBhc3luY2hyb25vdXNseS4gRGVmYXVsdDogdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyhTdHJpbmcgfCBIVE1MRWxlbWVudCl9IFtvcHRpb25zLndhaXRpbmddIFRlbXBvcmFyeSBjb250ZW50IHRvIHVzZSB3aGlsZSB0aGUgYWpheCByZXF1ZXN0IGlzIGxvYWRpbmcuIERlZmF1bHQ6ICcmbHQ7ZGl2IGNsYXNzPVwiY2gtbG9hZGluZyBjaC1sb2FkaW5nLWNlbnRlcmVkXCImZ3Q7Jmx0Oy9kaXYmZ3Q7Jy5cbiAgICAgKiBAcGFyYW0geyggU3RyaW5nIHwgSFRNTEVsZW1lbnQpfSBbb3B0aW9ucy5jb250ZW50XSBUaGUgY29udGVudCB0byBiZSBzaG93biBpbnRvIHRoZSBMYXllciBjb250YWluZXIuXG4gICAgICogQHBhcmFtIHsoQm9vbGVhbiB8IFN0cmluZyl9IFtvcHRpb25zLndyYXBwZXJdIFdyYXAgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBwbGFjZSB0aGUgY29udGFpbmVyIGludG8gaXQgaW5zdGVhZCBvZiBib2R5LiBXaGVuIHZhbHVlIGlzIGEgc3RyaW5nIGl0IHdpbGwgYmUgYXBwbGllZCBhcyBhZGRpdGlvbmFsIHdyYXBwZXIgY2xhc3MuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2xheWVyfSBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIExheWVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IExheWVyLlxuICAgICAqIHZhciBsYXllciA9IG5ldyBjaC5MYXllcihbZWxdLCBbb3B0aW9uc10pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IExheWVyIHdpdGggZGlzYWJsZWQgZWZmZWN0cy5cbiAgICAgKiB2YXIgbGF5ZXIgPSBuZXcgY2guTGF5ZXIoe1xuICAgICAqICAgICAnY29udGVudCc6ICdUaGlzIGlzIHRoZSBjb250ZW50IG9mIHRoZSBMYXllcidcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBMYXllciB1c2luZyB0aGUgc2hvcnRoYW5kIHdheSAoY29udGVudCBhcyBwYXJhbWV0ZXIpLlxuICAgICAqIHZhciBsYXllciA9IG5ldyBjaC5MYXllcignaHR0cDovL3VpLm1sLmNvbTozMDQwL2FqYXgnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXllcihlbCwgb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5faW5pdChlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHlvdSBkZWZpbmUgYW4gaW5pdGlhbGl6ZSBtZXRob2QsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhIG5ldyBMYXllciBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mISBjaC5MYXllci5wcm90b3R5cGVcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZWFkeSB0byB1c2UuXG4gICAgICAgICAqIEBldmVudCBjaC5MYXllciNyZWFkeVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJyZWFkeVwiIGV2ZW50LlxuICAgICAgICAgKiBsYXllci5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRoYXQuZW1pdCgncmVhZHknKTsgfSwgNTApO1xuICAgIH1cblxuICAgIC8vIEluaGVyaXRhbmNlXG4gICAgdGlueS5pbmhlcml0cyhMYXllciwgY2guUG9wb3Zlcik7XG5cbiAgICAvLyBSZWZlcmVuY2UgdG8gdGhlIGxhc3QgY29tcG9uZW50IG9wZW4uIEFsbG93cyB0byBjbG9zZSBhbmQgdG8gZGVueSB0b1xuICAgIC8vIGhhdmUgMiBjb21wb25lbnRzIG9wZW4gYXQgdGhlIHNhbWUgdGltZVxuICAgIHZhciBsYXN0U2hvd24sXG4gICAgICAgIHBhcmVudCA9IExheWVyLnN1cGVyXy5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBtZW1iZXJvZiEgY2guTGF5ZXIucHJvdG90eXBlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBMYXllci5wcm90b3R5cGUubmFtZSA9ICdsYXllcic7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkxheWVyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIExheWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExheWVyO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBieSBkZWZhdWx0LlxuICAgICAqIEBtZW1iZXJvZiEgY2guTGF5ZXIucHJvdG90eXBlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExheWVyLnByb3RvdHlwZS5fZGVmYXVsdHMgPSB0aW55LmV4dGVuZCh0aW55LmNsb25lKHBhcmVudC5fZGVmYXVsdHMpLCB7XG4gICAgICAgICdfY2xhc3NOYW1lJzogJ2NoLWxheWVyIGNoLWJveC1saXRlIGNoLWNvbmUnLFxuICAgICAgICAnX2FyaWFSb2xlJzogJ3Rvb2x0aXAnLFxuICAgICAgICAnc2hvd25ieSc6ICdwb2ludGVyZW50ZXInLFxuICAgICAgICAnaGlkZGVuYnknOiAncG9pbnRlcmxlYXZlJyxcbiAgICAgICAgJ3NpZGUnOiAnYm90dG9tJyxcbiAgICAgICAgJ2FsaWduJzogJ2xlZnQnLFxuICAgICAgICAnb2Zmc2V0WCc6IDAsXG4gICAgICAgICdvZmZzZXRZJzogMTAsXG4gICAgICAgICd3YWl0aW5nJzogJzxkaXYgY2xhc3M9XCJjaC1sb2FkaW5nLXNtYWxsXCI+PC9kaXY+JyxcbiAgICAgICAgJ3dyYXBwZXInOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIGxheWVyIGNvbnRhaW5lciBhbmQgaGlkZXMgb3RoZXIgbGF5ZXJzLlxuICAgICAqIEBtZW1iZXJvZiEgY2guTGF5ZXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsoU3RyaW5nIHwgSFRNTEVsZW1lbnQpfSBbY29udGVudF0gVGhlIGNvbnRlbnQgdGhhdCB3aWxsIGJlIHVzZWQgYnkgbGF5ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGN1c3RvbSBvcHRpb25zIHRvIGJlIHVzZWQgd2l0aCBjb250ZW50IGxvYWRlZCBieSBhamF4LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2RdIFRoZSB0eXBlIG9mIHJlcXVlc3QgKFwiUE9TVFwiIG9yIFwiR0VUXCIpIHRvIGxvYWQgY29udGVudCBieSBhamF4LiBEZWZhdWx0OiBcIkdFVFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbXNdIFBhcmFtcyBsaWtlIHF1ZXJ5IHN0cmluZyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYWNoZV0gRm9yY2UgdG8gY2FjaGUgdGhlIHJlcXVlc3QgYnkgdGhlIGJyb3dzZXIuIERlZmF1bHQ6IHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hc3luY10gRm9yY2UgdG8gc2VudCByZXF1ZXN0IGFzeW5jaHJvbm91c2x5LiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IEhUTUxFbGVtZW50KX0gW29wdGlvbnMud2FpdGluZ10gVGVtcG9yYXJ5IGNvbnRlbnQgdG8gdXNlIHdoaWxlIHRoZSBhamF4IHJlcXVlc3QgaXMgbG9hZGluZy5cbiAgICAgKiBAcmV0dXJucyB7bGF5ZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaG93cyBhIGJhc2ljIGxheWVyLlxuICAgICAqIGxheWVyLnNob3coKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNob3dzIGEgbGF5ZXIgd2l0aCBuZXcgY29udGVudFxuICAgICAqIGxheWVyLnNob3coJ1NvbWUgbmV3IGNvbnRlbnQgaGVyZSEnKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNob3dzIGEgbGF5ZXIgd2l0aCBhIG5ldyBjb250ZW50IHRoYXQgd2lsbCBiZSBsb2FkZWQgYnkgYWpheCB3aXRoIHNvbWUgY3VzdG9tIG9wdGlvbnNcbiAgICAgKiBsYXllci5zaG93KCdodHRwOi8vZG9tYWluLmNvbS9hamF4L3VybCcsIHtcbiAgICAgKiAgICAgJ2NhY2hlJzogZmFsc2UsXG4gICAgICogICAgICdwYXJhbXMnOiAneC1yZXF1ZXN0PXRydWUnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgTGF5ZXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICAvLyBEb24ndCBleGVjdXRlIHdoZW4gaXQncyBkaXNhYmxlZFxuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQgfHwgdGhpcy5fc2hvd24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBoaWRlIGlmIHRoZXJlIHdhcyBhIGNvbXBvbmVudCBvcGVuZWQgYmVmb3JlXG4gICAgICAgIGlmIChsYXN0U2hvd24gIT09IHVuZGVmaW5lZCAmJiBsYXN0U2hvd24ubmFtZSA9PT0gdGhpcy5uYW1lICYmIGxhc3RTaG93biAhPT0gdGhpcykge1xuICAgICAgICAgICAgbGFzdFNob3duLmhpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgc2F2ZSB0byBmdXR1cmUgY2xvc2UgaWYgdGhpcyBjb21wb25lbnQgaXMgY2xvc2FibGVcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaGlkZGVuYnkgIT09ICdub25lJyAmJiB0aGlzLl9vcHRpb25zLmhpZGRlbmJ5ICE9PSAnYnV0dG9uJykge1xuICAgICAgICAgICAgbGFzdFNob3duID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIG9yaWdpbmFsIHNob3coKVxuICAgICAgICBwYXJlbnQuc2hvdy5jYWxsKHRoaXMsIGNvbnRlbnQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBjaC5mYWN0b3J5KExheWVyLCBwYXJlbnQuX25vcm1hbGl6ZU9wdGlvbnMpO1xuXG59KHRoaXMsIHRoaXMuY2gpKTtcblxuKGZ1bmN0aW9uIChjaCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEltcHJvdmVzIHRoZSBuYXRpdmUgdG9vbHRpcHMuXG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIGNoLlBvcG92ZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBBIEhUTUxFbGVtZW50IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBjaC5Ub29sdGlwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBjdXN0b21pemUgYW4gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFkZENsYXNzXSBDU1MgY2xhc3MgbmFtZXMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjb250YWluZXIgb24gdGhlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZnhdIEVuYWJsZSBvciBkaXNhYmxlIFVJIGVmZmVjdHMuIFlvdSBtdXN0IHVzZTogXCJzbGlkZURvd25cIiwgXCJmYWRlSW5cIiBvciBcIm5vbmVcIi4gRGVmYXVsdDogXCJmYWRlSW5cIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2lkdGhdIFNldCBhIHdpZHRoIGZvciB0aGUgY29udGFpbmVyLiBEZWZhdWx0OiBcImF1dG9cIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaGVpZ2h0XSBTZXQgYSBoZWlnaHQgZm9yIHRoZSBjb250YWluZXIuIERlZmF1bHQ6IFwiYXV0b1wiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zaG93bmJ5XSBEZXRlcm1pbmVzIGhvdyB0byBpbnRlcmFjdCB3aXRoIHRoZSB0cmlnZ2VyIHRvIHNob3cgdGhlIGNvbnRhaW5lci4gWW91IG11c3QgdXNlOiBcInBvaW50ZXJ0YXBcIiwgXCJwb2ludGVyZW50ZXJcIiBvciBcIm5vbmVcIi4gRGVmYXVsdDogXCJwb2ludGVyZW50ZXJcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaGlkZGVuYnldIERldGVybWluZXMgaG93IHRvIGhpZGUgdGhlIGNvbXBvbmVudC4gWW91IG11c3QgdXNlOiBcImJ1dHRvblwiLCBcInBvaW50ZXJzXCIsIFwicG9pbnRlcmxlYXZlXCIsIFwiYWxsXCIgb3IgXCJub25lXCIuIERlZmF1bHQ6IFwicG9pbnRlcmxlYXZlXCIuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW29wdGlvbnMucmVmZXJlbmNlXSBJdCdzIGEgcmVmZXJlbmNlIHRvIHBvc2l0aW9uIGFuZCBzaXplIG9mIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGNvbnNpZGVyZWQgdG8gY2Fycnkgb3V0IHRoZSBwb3NpdGlvbi4gRGVmYXVsdDogdGhlIHRyaWdnZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2lkZV0gVGhlIHNpZGUgb3B0aW9uIHdoZXJlIHRoZSB0YXJnZXQgZWxlbWVudCB3aWxsIGJlIHBvc2l0aW9uZWQuIEl0cyB2YWx1ZSBjYW4gYmU6IFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wXCIsIFwiYm90dG9tXCIgb3IgXCJjZW50ZXJcIi4gRGVmYXVsdDogXCJib3R0b21cIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWxpZ25dIFRoZSBhbGlnbiBvcHRpb25zIHdoZXJlIHRoZSB0YXJnZXQgZWxlbWVudCB3aWxsIGJlIHBvc2l0aW9uZWQuIEl0cyB2YWx1ZSBjYW4gYmU6IFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wXCIsIFwiYm90dG9tXCIgb3IgXCJjZW50ZXJcIi4gRGVmYXVsdDogXCJsZWZ0XCIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFhdIERpc3RhbmNlIHRvIGRpc3BsYWNlIHRoZSB0YXJnZXQgaG9yaXpvbnRhbGx5LiBEZWZhdWx0OiAwLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRZXSBEaXN0YW5jZSB0byBkaXNwbGFjZSB0aGUgdGFyZ2V0IHZlcnRpY2FsbHkuIERlZmF1bHQ6IDEwLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbl0gVGhlIHR5cGUgb2YgcG9zaXRpb25pbmcgdXNlZC4gSXRzIHZhbHVlIG11c3QgYmUgXCJhYnNvbHV0ZVwiIG9yIFwiZml4ZWRcIi4gRGVmYXVsdDogXCJhYnNvbHV0ZVwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2RdIFRoZSB0eXBlIG9mIHJlcXVlc3QgKFwiUE9TVFwiIG9yIFwiR0VUXCIpIHRvIGxvYWQgY29udGVudCBieSBhamF4LiBEZWZhdWx0OiBcIkdFVFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbXNdIFBhcmFtcyBsaWtlIHF1ZXJ5IHN0cmluZyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYWNoZV0gRm9yY2UgdG8gY2FjaGUgdGhlIHJlcXVlc3QgYnkgdGhlIGJyb3dzZXIuIERlZmF1bHQ6IHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hc3luY10gRm9yY2UgdG8gc2VudCByZXF1ZXN0IGFzeW5jaHJvbm91c2x5LiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IEhUTUxFbGVtZW50KX0gW29wdGlvbnMud2FpdGluZ10gVGVtcG9yYXJ5IGNvbnRlbnQgdG8gdXNlIHdoaWxlIHRoZSBhamF4IHJlcXVlc3QgaXMgbG9hZGluZy4gRGVmYXVsdDogJzxkaXYgY2xhc3M9XCJjaC1sb2FkaW5nIGNoLWxvYWRpbmctY2VudGVyZWRcIj48L2Rpdj4nLlxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IEhUTUxFbGVtZW50KX0gW29wdGlvbnMuY29udGVudF0gVGhlIGNvbnRlbnQgdG8gYmUgc2hvd24gaW50byB0aGUgVG9vbHRpcCBjb250YWluZXIuXG4gICAgICogQHJldHVybnMge3Rvb2x0aXB9IFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgVG9vbHRpcC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBUb29sdGlwLlxuICAgICAqIHZhciB0b29sdGlwID0gbmV3IGNoLlRvb2x0aXAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRyaWdnZXInKSwgW29wdGlvbnNdKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBUb29sdGlwIHVzaW5nIHRoZSBzaG9ydGhhbmQgd2F5IChjb250ZW50IGFzIHBhcmFtZXRlcikuXG4gICAgICogdmFyIHRvb2x0aXAgPSBuZXcgY2guVG9vbHRpcChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudHJpZ2dlcicpLCB7J2NvbnRlbnQnOiAnaHR0cDovL3VpLm1sLmNvbTozMDQwL2FqYXgnfSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9vbHRpcChlbCwgb3B0aW9ucykge1xuXG4gICAgICAgIC8vIFRPRE86IFJldmlldyB3aGF0J3MgZ29pbmcgb24gaGVyZSB3aXRoIG9wdGlvbnNcbiAgICAgICAgLypcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiBlbCAhPT0gdW5kZWZpbmVkICYmIGVsLm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBlbDtcbiAgICAgICAgICAgIGVsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICAgICAgb3B0aW9ucyA9IHRpbnkuZXh0ZW5kKHRpbnkuY2xvbmUodGhpcy5fZGVmYXVsdHMpLCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gbmV3IGNoLkxheWVyKGVsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBtZW1iZXJvZiEgY2guVG9vbHRpcC5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gWW91IGNhbiByZWFjaCB0aGUgYXNzb2NpYXRlZCBpbnN0YW5jZS5cbiAgICAgKiB2YXIgdG9vbHRpcCA9ICQoc2VsZWN0b3IpLmRhdGEoJ3Rvb2x0aXAnKTtcbiAgICAgKi9cbiAgICBUb29sdGlwLnByb3RvdHlwZS5uYW1lID0gJ3Rvb2x0aXAnO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQG1lbWJlcm9mISBjaC5Ub29sdGlwLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIFRvb2x0aXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9vbHRpcDtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gYnkgZGVmYXVsdC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlRvb2x0aXAucHJvdG90eXBlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFRvb2x0aXAucHJvdG90eXBlLl9kZWZhdWx0cyA9IHRpbnkuZXh0ZW5kKHRpbnkuY2xvbmUoY2guTGF5ZXIucHJvdG90eXBlLl9kZWZhdWx0cyksIHtcbiAgICAgICAgJ19jbGFzc05hbWUnOiAnY2gtdG9vbHRpcCBjaC1jb25lJ1xuICAgIH0pO1xuXG4gICAgY2guZmFjdG9yeShUb29sdGlwLCBjaC5MYXllci5wcm90b3R5cGUuX25vcm1hbGl6ZU9wdGlvbnMpO1xuXG59KHRoaXMuY2gpKTtcblxuKGZ1bmN0aW9uICh3aW5kb3csIGNoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogRGlhbG9nIHdpbmRvdyB3aXRoIGFuIGVycm9yIHNraW4uXG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIGNoLkNvbXBvbmVudFxuICAgICAqIEByZXF1aXJlcyBjaC5Qb3NpdGlvbmVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgQSBIVE1MRWxlbWVudCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgY2guQnViYmxlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBjdXN0b21pemUgYW4gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFkZENsYXNzXSBDU1MgY2xhc3MgbmFtZXMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjb250YWluZXIgb24gdGhlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZnhdIEVuYWJsZSBvciBkaXNhYmxlIFVJIGVmZmVjdHMuIFlvdSBtdXN0IHVzZTogXCJzbGlkZURvd25cIiwgXCJmYWRlSW5cIiBvciBcIm5vbmVcIi4gRGVmYXVsdDogXCJmYWRlSW5cIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2lkdGhdIFNldCBhIHdpZHRoIGZvciB0aGUgY29udGFpbmVyLiBEZWZhdWx0OiBcImF1dG9cIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaGVpZ2h0XSBTZXQgYSBoZWlnaHQgZm9yIHRoZSBjb250YWluZXIuIERlZmF1bHQ6IFwiYXV0b1wiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zaG93bmJ5XSBEZXRlcm1pbmVzIGhvdyB0byBpbnRlcmFjdCB3aXRoIHRoZSB0cmlnZ2VyIHRvIHNob3cgdGhlIGNvbnRhaW5lci4gWW91IG11c3QgdXNlOiBcInBvaW50ZXJ0YXBcIiwgXCJwb2ludGVyZW50ZXJcIiBvciBcIm5vbmVcIi4gRGVmYXVsdDogXCJub25lXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhpZGRlbmJ5XSBEZXRlcm1pbmVzIGhvdyB0byBoaWRlIHRoZSBjb21wb25lbnQuIFlvdSBtdXN0IHVzZTogXCJidXR0b25cIiwgXCJwb2ludGVyc1wiLCBcInBvaW50ZXJsZWF2ZVwiLCBcImFsbFwiIG9yIFwibm9uZVwiLiBEZWZhdWx0OiBcIm5vbmVcIi5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbb3B0aW9ucy5yZWZlcmVuY2VdIEl0J3MgYSByZWZlcmVuY2UgdG8gcG9zaXRpb24gYW5kIHNpemUgb2YgZWxlbWVudCB0aGF0IHdpbGwgYmUgY29uc2lkZXJlZCB0byBjYXJyeSBvdXQgdGhlIHBvc2l0aW9uLiBEZWZhdWx0OiB0aGUgdHJpZ2dlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zaWRlXSBUaGUgc2lkZSBvcHRpb24gd2hlcmUgdGhlIHRhcmdldCBlbGVtZW50IHdpbGwgYmUgcG9zaXRpb25lZC4gSXRzIHZhbHVlIGNhbiBiZTogXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIiBvciBcImNlbnRlclwiLiBEZWZhdWx0OiBcInJpZ2h0XCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFsaWduXSBUaGUgYWxpZ24gb3B0aW9ucyB3aGVyZSB0aGUgdGFyZ2V0IGVsZW1lbnQgd2lsbCBiZSBwb3NpdGlvbmVkLiBJdHMgdmFsdWUgY2FuIGJlOiBcImxlZnRcIiwgXCJyaWdodFwiLCBcInRvcFwiLCBcImJvdHRvbVwiIG9yIFwiY2VudGVyXCIuIERlZmF1bHQ6IFwidG9wXCIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFhdIERpc3RhbmNlIHRvIGRpc3BsYWNlIHRoZSB0YXJnZXQgaG9yaXpvbnRhbGx5LiBEZWZhdWx0OiAxMC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WV0gRGlzdGFuY2UgdG8gZGlzcGxhY2UgdGhlIHRhcmdldCB2ZXJ0aWNhbGx5LiBEZWZhdWx0OiAwLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbl0gVGhlIHR5cGUgb2YgcG9zaXRpb25pbmcgdXNlZC4gSXRzIHZhbHVlIG11c3QgYmUgXCJhYnNvbHV0ZVwiIG9yIFwiZml4ZWRcIi4gRGVmYXVsdDogXCJhYnNvbHV0ZVwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2RdIFRoZSB0eXBlIG9mIHJlcXVlc3QgKFwiUE9TVFwiIG9yIFwiR0VUXCIpIHRvIGxvYWQgY29udGVudCBieSBhamF4LiBEZWZhdWx0OiBcIkdFVFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbXNdIFBhcmFtcyBsaWtlIHF1ZXJ5IHN0cmluZyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYWNoZV0gRm9yY2UgdG8gY2FjaGUgdGhlIHJlcXVlc3QgYnkgdGhlIGJyb3dzZXIuIERlZmF1bHQ6IHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hc3luY10gRm9yY2UgdG8gc2VudCByZXF1ZXN0IGFzeW5jaHJvbm91c2x5LiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IEhUTUxFbGVtZW50KX0gW29wdGlvbnMud2FpdGluZ10gVGVtcG9yYXJ5IGNvbnRlbnQgdG8gdXNlIHdoaWxlIHRoZSBhamF4IHJlcXVlc3QgaXMgbG9hZGluZy4gRGVmYXVsdDogJyZsdDtkaXYgY2xhc3M9XCJjaC1sb2FkaW5nIGNoLWxvYWRpbmctY2VudGVyZWRcIiZndDsmbHQ7L2RpdiZndDsnLlxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IEhUTUxFbGVtZW50KX0gW29wdGlvbnMuY29udGVudF0gVGhlIGNvbnRlbnQgdG8gYmUgc2hvd24gaW50byB0aGUgQnViYmxlIGNvbnRhaW5lci4gRGVmYXVsdDogXCJDaGVjayB0aGUgaW5mb3JtYXRpb24sIHBsZWFzZS5cIlxuICAgICAqIEByZXR1cm5zIHtidWJibGV9IFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgQnViYmxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IEJ1YmJsZS5cbiAgICAgKiB2YXIgYnViYmxlID0gbmV3IGNoLkJ1YmJsZSgkZWwsIFtvcHRpb25zXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgQnViYmxlIHdpdGggZGlzYWJsZWQgZWZmZWN0cy5cbiAgICAgKiB2YXIgYnViYmxlID0gbmV3IGNoLkJ1YmJsZSh7XG4gICAgICogICAgICdmeCc6ICdub25lJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IEJ1YmJsZSB1c2luZyB0aGUgc2hvcnRoYW5kIHdheSAoY29udGVudCBhcyBwYXJhbWV0ZXIpLlxuICAgICAqIHZhciBidWJibGUgPSBuZXcgY2guQnViYmxlKCdodHRwOi8vdWkubWwuY29tOjMwNDAvYWpheCcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJ1YmJsZShlbCwgb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5faW5pdChlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHlvdSBkZWZpbmUgYW4gaW5pdGlhbGl6ZSBtZXRob2QsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhIG5ldyBCdWJibGUgaXMgY3JlYXRlZC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiEgY2guQnViYmxlLnByb3RvdHlwZVxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHJlYWR5IHRvIHVzZS5cbiAgICAgICAgICogQGV2ZW50IGNoLkJ1YmJsZSNyZWFkeVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJyZWFkeVwiIGV2ZW50LlxuICAgICAgICAgKiBidWJibGUub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aGF0LmVtaXQoJ3JlYWR5Jyk7IH0sIDUwKTtcbiAgICB9XG5cbiAgICAvLyBJbmhlcml0YW5jZVxuICAgIHRpbnkuaW5oZXJpdHMoQnViYmxlLCBjaC5Qb3BvdmVyKTtcblxuICAgIHZhciBwYXJlbnQgPSBCdWJibGUuc3VwZXJfLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQG1lbWJlcm9mISBjaC5CdWJibGUucHJvdG90eXBlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBCdWJibGUucHJvdG90eXBlLm5hbWUgPSAnYnViYmxlJztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQnViYmxlLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIEJ1YmJsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCdWJibGU7XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGJ5IGRlZmF1bHQuXG4gICAgICogQG1lbWJlcm9mISBjaC5CdWJibGUucHJvdG90eXBlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEJ1YmJsZS5wcm90b3R5cGUuX2RlZmF1bHRzID0gdGlueS5leHRlbmQodGlueS5jbG9uZShwYXJlbnQuX2RlZmF1bHRzKSwge1xuICAgICAgICAnX2NsYXNzTmFtZSc6ICdjaC1idWJibGUgY2gtYm94LWljb24gY2gtYm94LWVycm9yIGNoLWNvbmUnLFxuICAgICAgICAnX2FyaWFSb2xlJzogJ2FsZXJ0JyxcbiAgICAgICAgJ3Nob3duYnknOiAnbm9uZScsXG4gICAgICAgICdoaWRkZW5ieSc6ICdub25lJyxcbiAgICAgICAgJ3NpZGUnOiAncmlnaHQnLFxuICAgICAgICAnYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgJ29mZnNldFgnOiAxMCxcbiAgICAgICAgJ2NvbnRlbnQnOiAnQ2hlY2sgdGhlIGluZm9ybWF0aW9uLCBwbGVhc2UuJ1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBpbnN0YW5jZSBvZiBCdWJibGUgYW5kIG1lcmdlIGN1c3RvbSBvcHRpb25zIHdpdGggZGVmYXVsdHMgb3B0aW9ucy5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkJ1YmJsZS5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtidWJibGV9XG4gICAgICovXG4gICAgQnViYmxlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICAgICAgICAvLyBDYWxsIHRvIGl0cyBwYXJlbnQgaW5pdCBtZXRob2RcbiAgICAgICAgcGFyZW50Ll9pbml0LmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgJzxpIGNsYXNzPVwiY2gtaWNvbi1yZW1vdmUtc2lnblwiPjwvaT4nKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgY2guZmFjdG9yeShCdWJibGUsIHBhcmVudC5fbm9ybWFsaXplT3B0aW9ucyk7XG5cbn0odGhpcywgdGhpcy5jaCkpO1xuXG4oZnVuY3Rpb24gKHdpbmRvdywgY2gpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBNb2RhbCBpcyBhIGRpYWxvZyB3aW5kb3cgd2l0aCBhbiB1bmRlcmxheS5cbiAgICAgKiBAbWVtYmVyb2YgY2hcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgY2guUG9wb3ZlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtlbF0gQSBIVE1MRWxlbWVudCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgY2guTW9kYWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRvIGN1c3RvbWl6ZSBhbiBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWRkQ2xhc3NdIENTUyBjbGFzcyBuYW1lcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGNvbnRhaW5lciBvbiB0aGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5meF0gRW5hYmxlIG9yIGRpc2FibGUgVUkgZWZmZWN0cy4gWW91IG11c3QgdXNlOiBcInNsaWRlRG93blwiLCBcImZhZGVJblwiIG9yIFwibm9uZVwiLiBEZWZhdWx0OiBcImZhZGVJblwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53aWR0aF0gU2V0IGEgd2lkdGggZm9yIHRoZSBjb250YWluZXIuIERlZmF1bHQ6IFwiNTAlXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhlaWdodF0gU2V0IGEgaGVpZ2h0IGZvciB0aGUgY29udGFpbmVyLiBEZWZhdWx0OiBcImF1dG9cIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2hvd25ieV0gRGV0ZXJtaW5lcyBob3cgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgdHJpZ2dlciB0byBzaG93IHRoZSBjb250YWluZXIuIFlvdSBtdXN0IHVzZTogXCJwb2ludGVydGFwXCIsIFwicG9pbnRlcmVudGVyXCIgb3IgXCJub25lXCIuIERlZmF1bHQ6IFwicG9pbnRlcnRhcFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5oaWRkZW5ieV0gRGV0ZXJtaW5lcyBob3cgdG8gaGlkZSB0aGUgY29tcG9uZW50LiBZb3UgbXVzdCB1c2U6IFwiYnV0dG9uXCIsIFwicG9pbnRlcnNcIiwgXCJwb2ludGVybGVhdmVcIiwgXCJhbGxcIiBvciBcIm5vbmVcIi4gRGVmYXVsdDogXCJhbGxcIi5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbb3B0aW9ucy5yZWZlcmVuY2VdIEl0J3MgYSByZWZlcmVuY2UgdG8gcG9zaXRpb24gYW5kIHNpemUgb2YgZWxlbWVudCB0aGF0IHdpbGwgYmUgY29uc2lkZXJlZCB0byBjYXJyeSBvdXQgdGhlIHBvc2l0aW9uLiBEZWZhdWx0OiBjaC52aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2lkZV0gVGhlIHNpZGUgb3B0aW9uIHdoZXJlIHRoZSB0YXJnZXQgZWxlbWVudCB3aWxsIGJlIHBvc2l0aW9uZWQuIEl0cyB2YWx1ZSBjYW4gYmU6IFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wXCIsIFwiYm90dG9tXCIgb3IgXCJjZW50ZXJcIi4gRGVmYXVsdDogXCJjZW50ZXJcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWxpZ25dIFRoZSBhbGlnbiBvcHRpb25zIHdoZXJlIHRoZSB0YXJnZXQgZWxlbWVudCB3aWxsIGJlIHBvc2l0aW9uZWQuIEl0cyB2YWx1ZSBjYW4gYmU6IFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wXCIsIFwiYm90dG9tXCIgb3IgXCJjZW50ZXJcIi4gRGVmYXVsdDogXCJjZW50ZXJcIi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WF0gRGlzdGFuY2UgdG8gZGlzcGxhY2UgdGhlIHRhcmdldCBob3Jpem9udGFsbHkuIERlZmF1bHQ6IDAuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFldIERpc3RhbmNlIHRvIGRpc3BsYWNlIHRoZSB0YXJnZXQgdmVydGljYWxseS4gRGVmYXVsdDogMC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb25dIFRoZSB0eXBlIG9mIHBvc2l0aW9uaW5nIHVzZWQuIEl0cyB2YWx1ZSBtdXN0IGJlIFwiYWJzb2x1dGVcIiBvciBcImZpeGVkXCIuIERlZmF1bHQ6IFwiZml4ZWRcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWV0aG9kXSBUaGUgdHlwZSBvZiByZXF1ZXN0IChcIlBPU1RcIiBvciBcIkdFVFwiKSB0byBsb2FkIGNvbnRlbnQgYnkgYWpheC4gRGVmYXVsdDogXCJHRVRcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFyYW1zXSBQYXJhbXMgbGlrZSBxdWVyeSBzdHJpbmcgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2FjaGVdIEZvcmNlIHRvIGNhY2hlIHRoZSByZXF1ZXN0IGJ5IHRoZSBicm93c2VyLiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXN5bmNdIEZvcmNlIHRvIHNlbnQgcmVxdWVzdCBhc3luY2hyb25vdXNseS4gRGVmYXVsdDogdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyhTdHJpbmcgfCBIVE1MRWxlbWVudCl9IFtvcHRpb25zLndhaXRpbmddIFRlbXBvcmFyeSBjb250ZW50IHRvIHVzZSB3aGlsZSB0aGUgYWpheCByZXF1ZXN0IGlzIGxvYWRpbmcuIERlZmF1bHQ6ICcmbHQ7ZGl2IGNsYXNzPVwiY2gtbG9hZGluZy1sYXJnZSBjaC1sb2FkaW5nLWNlbnRlcmVkXCImZ3Q7Jmx0Oy9kaXYmZ3Q7Jy5cbiAgICAgKiBAcGFyYW0geyhTdHJpbmcgfCBIVE1MRWxlbWVudCl9IFtvcHRpb25zLmNvbnRlbnRdIFRoZSBjb250ZW50IHRvIGJlIHNob3duIGludG8gdGhlIE1vZGFsIGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJucyB7bW9kYWx9IFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgTW9kYWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgTW9kYWwuXG4gICAgICogdmFyIG1vZGFsID0gbmV3IGNoLk1vZGFsKFtlbF0sIFtvcHRpb25zXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgTW9kYWwuXG4gICAgICogdmFyIG1vZGFsID0gbmV3IGNoLk1vZGFsKFtvcHRpb25zXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgTW9kYWwgd2l0aCBkaXNhYmxlZCBlZmZlY3RzLlxuICAgICAqIHZhciBtb2RhbCA9IG5ldyBjaC5Nb2RhbCh7XG4gICAgICogICAgICdjb250ZW50JzogJ1RoaXMgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIE1vZGFsJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IE1vZGFsIHVzaW5nIHRoZSBzaG9ydGhhbmQgd2F5IChjb250ZW50IGFzIHBhcmFtZXRlcikuXG4gICAgICogdmFyIG1vZGFsID0gbmV3IGNoLk1vZGFsKCdodHRwOi8vdWkubWwuY29tOjMwNDAvYWpheCcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1vZGFsKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gY29udGV4dCBvZiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICB0aGlzLl9pbml0KGVsLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgeW91IGRlZmluZSBhbiBpbml0aWFsaXplIG1ldGhvZCwgaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGEgbmV3IE1vZGFsIGlzIGNyZWF0ZWQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YhIGNoLk1vZGFsLnByb3RvdHlwZVxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHJlYWR5IHRvIHVzZS5cbiAgICAgICAgICogQGV2ZW50IGNoLk1vZGFsI3JlYWR5XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcInJlYWR5XCIgZXZlbnQuXG4gICAgICAgICAqIG1vZGFsLm9uKCdyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhhdC5lbWl0KCdyZWFkeScpOyB9LCA1MCk7XG4gICAgfVxuXG4gICAgLy8gSW5oZXJpdGFuY2VcbiAgICB0aW55LmluaGVyaXRzKE1vZGFsLCBjaC5Qb3BvdmVyKTtcblxuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICAgICAgdW5kZXJsYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGR1bW15RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZHVtbXlFbGVtZW50LmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwiY2gtdW5kZXJsYXlcIiB0YWJpbmRleD1cIi0xXCI+PC9kaXY+JztcblxuICAgICAgICAgICAgcmV0dXJuIGR1bW15RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAgICAgICAgfSgpKSxcbiAgICAgICAgcGFyZW50ID0gTW9kYWwuc3VwZXJfLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQG1lbWJlcm9mISBjaC5Nb2RhbC5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIE1vZGFsLnByb3RvdHlwZS5uYW1lID0gJ21vZGFsJztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgICAqIEBtZW1iZXJvZiEgY2guTW9kYWwucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgTW9kYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9kYWw7XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIGJ5IGRlZmF1bHQuXG4gICAgICogQG1lbWJlcm9mISBjaC5Nb2RhbC5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTW9kYWwucHJvdG90eXBlLl9kZWZhdWx0cyA9IHRpbnkuZXh0ZW5kKHRpbnkuY2xvbmUocGFyZW50Ll9kZWZhdWx0cyksIHtcbiAgICAgICAgJ19jbGFzc05hbWUnOiAnY2gtbW9kYWwgY2gtYm94LWxpdGUnLFxuICAgICAgICAnX2FyaWFSb2xlJzogJ2RpYWxvZycsXG4gICAgICAgICd3aWR0aCc6ICc1MCUnLFxuICAgICAgICAnaGlkZGVuYnknOiAnYWxsJyxcbiAgICAgICAgJ3JlZmVyZW5jZSc6IGNoLnZpZXdwb3J0LFxuICAgICAgICAnd2FpdGluZyc6ICc8ZGl2IGNsYXNzPVwiY2gtbG9hZGluZy1sYXJnZSBjaC1sb2FkaW5nLWNlbnRlcmVkXCI+PC9kaXY+JyxcbiAgICAgICAgJ3Bvc2l0aW9uJzogJ2ZpeGVkJ1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIE1vZGFsIHVuZGVybGF5LlxuICAgICAqIEBtZW1iZXJvZiEgY2guTW9kYWwucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNb2RhbC5wcm90b3R5cGUuX3Nob3dVbmRlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVzZUFuaW1hdGlvbiA9IHRpbnkuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuX29wdGlvbnMuZnggIT09ICdub25lJyAmJiB0aGlzLl9vcHRpb25zLmZ4ICE9PSBmYWxzZSxcbiAgICAgICAgICAgIGZ4TmFtZSA9ICdjaC1meC0nICsgdGhpcy5fb3B0aW9ucy5meC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodW5kZXJsYXkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNob3dDYWxsYmFjayhlKSB7XG4gICAgICAgICAgICB0aW55LnJlbW92ZUNsYXNzKHVuZGVybGF5LCBmeE5hbWUgKyAnLWVudGVyLWFjdGl2ZScpO1xuICAgICAgICAgICAgdGlueS5yZW1vdmVDbGFzcyh1bmRlcmxheSwgZnhOYW1lICsgJy1lbnRlcicpO1xuXG4gICAgICAgICAgICB0aW55Lm9mZihlLnRhcmdldCwgZS50eXBlLCBzaG93Q2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVzZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGlueS5hZGRDbGFzcyh1bmRlcmxheSwgZnhOYW1lICsgJy1lbnRlcicpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aW55LmFkZENsYXNzKHVuZGVybGF5LCBmeE5hbWUgKyAnLWVudGVyLWFjdGl2ZScpO1xuICAgICAgICAgICAgfSwxMCk7XG4gICAgICAgICAgICB0aW55Lm9uKHVuZGVybGF5LCB0aW55LnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsIHNob3dDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIE1vZGFsIHVuZGVybGF5LlxuICAgICAqIEBtZW1iZXJvZiEgY2guTW9kYWwucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNb2RhbC5wcm90b3R5cGUuX2hpZGVVbmRlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVzZUFuaW1hdGlvbiA9IHRpbnkuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuX29wdGlvbnMuZnggIT09ICdub25lJyAmJiB0aGlzLl9vcHRpb25zLmZ4ICE9PSBmYWxzZSxcbiAgICAgICAgICAgIGZ4TmFtZSA9ICdjaC1meC0nICsgdGhpcy5fb3B0aW9ucy5meC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgcGFyZW50ID0gdW5kZXJsYXkucGFyZW50Tm9kZTtcblxuICAgICAgICBmdW5jdGlvbiBoaWRlQ2FsbGJhY2soZSkge1xuICAgICAgICAgICAgdGlueS5yZW1vdmVDbGFzcyh1bmRlcmxheSwgZnhOYW1lICsgJy1sZWF2ZS1hY3RpdmUnKTtcbiAgICAgICAgICAgIHRpbnkucmVtb3ZlQ2xhc3ModW5kZXJsYXksIGZ4TmFtZSArICctbGVhdmUnKTtcblxuICAgICAgICAgICAgdGlueS5vZmYoZS50YXJnZXQsIGUudHlwZSwgaGlkZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh1bmRlcmxheSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXNlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aW55LmFkZENsYXNzKHVuZGVybGF5LCBmeE5hbWUgKyAnLWxlYXZlJyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3ModW5kZXJsYXksIGZ4TmFtZSArICctbGVhdmUtYWN0aXZlJyk7XG4gICAgICAgICAgICB9LDEwKTtcbiAgICAgICAgICAgIHRpbnkub24odW5kZXJsYXksIHRpbnkuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCwgaGlkZUNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh1bmRlcmxheSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIG1vZGFsIGNvbnRhaW5lciBhbmQgdGhlIHVuZGVybGF5LlxuICAgICAqIEBtZW1iZXJvZiEgY2guTW9kYWwucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsoU3RyaW5nIHwgSFRNTEVsZW1lbnQpfSBbY29udGVudF0gVGhlIGNvbnRlbnQgdGhhdCB3aWxsIGJlIHVzZWQgYnkgbW9kYWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGN1c3RvbSBvcHRpb25zIHRvIGJlIHVzZWQgd2l0aCBjb250ZW50IGxvYWRlZCBieSBhamF4LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2RdIFRoZSB0eXBlIG9mIHJlcXVlc3QgKFwiUE9TVFwiIG9yIFwiR0VUXCIpIHRvIGxvYWQgY29udGVudCBieSBhamF4LiBEZWZhdWx0OiBcIkdFVFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbXNdIFBhcmFtcyBsaWtlIHF1ZXJ5IHN0cmluZyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYWNoZV0gRm9yY2UgdG8gY2FjaGUgdGhlIHJlcXVlc3QgYnkgdGhlIGJyb3dzZXIuIERlZmF1bHQ6IHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hc3luY10gRm9yY2UgdG8gc2VudCByZXF1ZXN0IGFzeW5jaHJvbm91c2x5LiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IEhUTUxFbGVtZW50KX0gW29wdGlvbnMud2FpdGluZ10gVGVtcG9yYXJ5IGNvbnRlbnQgdG8gdXNlIHdoaWxlIHRoZSBhamF4IHJlcXVlc3QgaXMgbG9hZGluZy5cbiAgICAgKiBAcmV0dXJucyB7bW9kYWx9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaG93cyBhIGJhc2ljIG1vZGFsLlxuICAgICAqIG1vZGFsLnNob3coKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNob3dzIGEgbW9kYWwgd2l0aCBuZXcgY29udGVudFxuICAgICAqIG1vZGFsLnNob3coJ1NvbWUgbmV3IGNvbnRlbnQgaGVyZSEnKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNob3dzIGEgbW9kYWwgd2l0aCBhIG5ldyBjb250ZW50IHRoYXQgd2lsbCBiZSBsb2FkZWQgYnkgYWpheCB3aXRoIHNvbWUgY3VzdG9tIG9wdGlvbnNcbiAgICAgKiBtb2RhbC5zaG93KCdodHRwOi8vZG9tYWluLmNvbS9hamF4L3VybCcsIHtcbiAgICAgKiAgICAgJ2NhY2hlJzogZmFsc2UsXG4gICAgICogICAgICdwYXJhbXMnOiAneC1yZXF1ZXN0PXRydWUnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICAvLyBEb24ndCBleGVjdXRlIHdoZW4gaXQncyBkaXNhYmxlZFxuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQgfHwgdGhpcy5fc2hvd24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhpZGVCeVVuZGVybGF5KGUpIHtcbiAgICAgICAgICAgIHRoYXQuaGlkZSgpO1xuICAgICAgICAgICAgLy8gQWxsb3cgb25seSBvbmUgY2xpY2sgdG8gYW5hbHl6ZSB0aGUgY29uZmlnIGV2ZXJ5IHRpbWUgYW5kIHRvIGNsb3NlIE9OTFkgVEhJUyBtb2RhbFxuICAgICAgICAgICAgZS50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLnR5cGUsIGhpZGVCeVVuZGVybGF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0byB0aGUgdW5kZXJsYXkgdGhlIGFiaWxpdHkgdG8gaGlkZSB0aGUgY29tcG9uZW50XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmhpZGRlbmJ5ID09PSAnYWxsJyB8fCB0aGlzLl9vcHRpb25zLmhpZGRlbmJ5ID09PSAncG9pbnRlcnMnKSB7XG4gICAgICAgICAgICB0aW55Lm9uKHVuZGVybGF5LCBjaC5vbnBvaW50ZXJ0YXAsIGhpZGVCeVVuZGVybGF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3cgdGhlIHVuZGVybGF5XG4gICAgICAgIHRoaXMuX3Nob3dVbmRlcmxheSgpO1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSBvcmlnaW5hbCBzaG93KClcbiAgICAgICAgcGFyZW50LnNob3cuY2FsbCh0aGlzLCBjb250ZW50LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIG1vZGFsIGNvbnRhaW5lciBhbmQgdGhlIHVuZGVybGF5LlxuICAgICAqIEBtZW1iZXJvZiEgY2guTW9kYWwucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge21vZGFsfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ2xvc2UgYSBtb2RhbFxuICAgICAqIG1vZGFsLmhpZGUoKTtcbiAgICAgKi9cbiAgICBNb2RhbC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93bikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWxldGUgdGhlIHVuZGVybGF5IGxpc3RlbmVyXG4gICAgICAgIHRpbnkub2ZmKHVuZGVybGF5LCBjaC5vbnBvaW50ZXJ0YXApO1xuICAgICAgICAvLyBIaWRlIHRoZSB1bmRlcmxheSBlbGVtZW50XG4gICAgICAgIHRoaXMuX2hpZGVVbmRlcmxheSgpO1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSBvcmlnaW5hbCBoaWRlKClcbiAgICAgICAgcGFyZW50LmhpZGUuY2FsbCh0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgY2guZmFjdG9yeShNb2RhbCwgcGFyZW50Ll9ub3JtYWxpemVPcHRpb25zKTtcblxufSh0aGlzLCB0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAoY2gpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9uIGxldHMgeW91IGdpdmUgZmVlZGJhY2sgdG8gdGhlIHVzZXJzIHdoZW4gdGhlaXIgaGF2ZSB0byB3YWl0IGZvciBhbiBhY3Rpb24uXG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIGNoLlBvcG92ZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbZWxdIEEgSFRNTEVsZW1lbnQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIGNoLlRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRvIGN1c3RvbWl6ZSBhbiBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWRkQ2xhc3NdIENTUyBjbGFzcyBuYW1lcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGNvbnRhaW5lciBvbiB0aGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5meF0gRW5hYmxlIG9yIGRpc2FibGUgVUkgZWZmZWN0cy4gWW91IG11c3QgdXNlOiBcInNsaWRlRG93blwiLCBcImZhZGVJblwiIG9yIFwibm9uZVwiLiBEZWZhdWx0OiBcImZhZGVJblwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53aWR0aF0gU2V0IGEgd2lkdGggZm9yIHRoZSBjb250YWluZXIuIERlZmF1bHQ6IFwiNTAlXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhlaWdodF0gU2V0IGEgaGVpZ2h0IGZvciB0aGUgY29udGFpbmVyLiBEZWZhdWx0OiBcImF1dG9cIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2hvd25ieV0gRGV0ZXJtaW5lcyBob3cgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgdHJpZ2dlciB0byBzaG93IHRoZSBjb250YWluZXIuIFlvdSBtdXN0IHVzZTogXCJwb2ludGVydGFwXCIsIFwicG9pbnRlcmVudGVyXCIgb3IgXCJub25lXCIuIERlZmF1bHQ6IFwicG9pbnRlcnRhcFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5oaWRkZW5ieV0gRGV0ZXJtaW5lcyBob3cgdG8gaGlkZSB0aGUgY29tcG9uZW50LiBZb3UgbXVzdCB1c2U6IFwiYnV0dG9uXCIsIFwicG9pbnRlcnNcIiwgXCJwb2ludGVybGVhdmVcIiwgXCJhbGxcIiBvciBcIm5vbmVcIi4gRGVmYXVsdDogXCJub25lXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJlZmVyZW5jZV0gSXQncyBhIHJlZmVyZW5jZSB0byBwb3NpdGlvbiBhbmQgc2l6ZSBvZiBlbGVtZW50IHRoYXQgd2lsbCBiZSBjb25zaWRlcmVkIHRvIGNhcnJ5IG91dCB0aGUgcG9zaXRpb24uIERlZmF1bHQ6IGNoLnZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zaWRlXSBUaGUgc2lkZSBvcHRpb24gd2hlcmUgdGhlIHRhcmdldCBlbGVtZW50IHdpbGwgYmUgcG9zaXRpb25lZC4gSXRzIHZhbHVlIGNhbiBiZTogXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIiBvciBcImNlbnRlclwiLiBEZWZhdWx0OiBcImNlbnRlclwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbGlnbl0gVGhlIGFsaWduIG9wdGlvbnMgd2hlcmUgdGhlIHRhcmdldCBlbGVtZW50IHdpbGwgYmUgcG9zaXRpb25lZC4gSXRzIHZhbHVlIGNhbiBiZTogXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIiBvciBcImNlbnRlclwiLiBEZWZhdWx0OiBcImNlbnRlclwiLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRYXSBEaXN0YW5jZSB0byBkaXNwbGFjZSB0aGUgdGFyZ2V0IGhvcml6b250YWxseS4gRGVmYXVsdDogMC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WV0gRGlzdGFuY2UgdG8gZGlzcGxhY2UgdGhlIHRhcmdldCB2ZXJ0aWNhbGx5LiBEZWZhdWx0OiAwLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbl0gVGhlIHR5cGUgb2YgcG9zaXRpb25pbmcgdXNlZC4gSXRzIHZhbHVlIG11c3QgYmUgXCJhYnNvbHV0ZVwiIG9yIFwiZml4ZWRcIi4gRGVmYXVsdDogXCJmaXhlZFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2RdIFRoZSB0eXBlIG9mIHJlcXVlc3QgKFwiUE9TVFwiIG9yIFwiR0VUXCIpIHRvIGxvYWQgY29udGVudCBieSBhamF4LiBEZWZhdWx0OiBcIkdFVFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbXNdIFBhcmFtcyBsaWtlIHF1ZXJ5IHN0cmluZyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYWNoZV0gRm9yY2UgdG8gY2FjaGUgdGhlIHJlcXVlc3QgYnkgdGhlIGJyb3dzZXIuIERlZmF1bHQ6IHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hc3luY10gRm9yY2UgdG8gc2VudCByZXF1ZXN0IGFzeW5jaHJvbm91c2x5LiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7KEhUTUxFbGVtZW50IHwgU3RyaW5nKX0gW29wdGlvbnMud2FpdGluZ10gVGVtcG9yYXJ5IGNvbnRlbnQgdG8gdXNlIHdoaWxlIHRoZSBhamF4IHJlcXVlc3QgaXMgbG9hZGluZy4gRGVmYXVsdDogJyZsdDtkaXYgY2xhc3M9XCJjaC1sb2FkaW5nLWxhcmdlIGNoLWxvYWRpbmctY2VudGVyZWRcIiZndDsmbHQ7L2RpdiZndDsnLlxuICAgICAqIEBwYXJhbSB7KEhUTUxFbGVtZW50IHwgU3RyaW5nKX0gW29wdGlvbnMuY29udGVudF0gVGhlIGNvbnRlbnQgdG8gYmUgc2hvd24gaW50byB0aGUgVHJhbnNpdGlvbiBjb250YWluZXIuIERlZmF1bHQ6IFwiUGxlYXNlIHdhaXQuLi5cIlxuICAgICAqIEByZXR1cm5zIHt0cmFuc2l0aW9ufSBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIFRyYW5zaXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgVHJhbnNpdGlvbi5cbiAgICAgKiB2YXIgdHJhbnNpdGlvbiA9IG5ldyBjaC5UcmFuc2l0aW9uKFtlbF0sIFtvcHRpb25zXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgVHJhbnNpdGlvbiB3aXRoIGRpc2FibGVkIGVmZmVjdHMuXG4gICAgICogdmFyIHRyYW5zaXRpb24gPSBuZXcgY2guVHJhbnNpdGlvbih7XG4gICAgICogICAgICdmeCc6ICdub25lJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IFRyYW5zaXRpb24gdXNpbmcgdGhlIHNob3J0aGFuZCB3YXkgKGNvbnRlbnQgYXMgcGFyYW1ldGVyKS5cbiAgICAgKiB2YXIgdHJhbnNpdGlvbiA9IG5ldyBjaC5UcmFuc2l0aW9uKCdodHRwOi8vdWkubWwuY29tOjMwNDAvYWpheCcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb24oZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAoZWwgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMuY29udGVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHVtbXlFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICAgICAgY29udGVudCA9IG9wdGlvbnMud2FpdGluZyB8fCAnJztcblxuICAgICAgICAgICAgLy8gVE9ETzogb3B0aW9ucy5jb250ZW50IGNvdWxkIGJlIGEgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgIGR1bW15RWxlbWVudC5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImNoLWxvYWRpbmctbGFyZ2VcIj48L2Rpdj48cD4nICsgY29udGVudCArICc8L3A+JztcblxuICAgICAgICAgICAgcmV0dXJuIGR1bW15RWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgICB9KCkpO1xuXG4gICAgICAgIC8vIGVsIGlzIG5vdCBkZWZpbmVkXG4gICAgICAgIGlmIChlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbCA9IHRpbnkuZXh0ZW5kKHRpbnkuY2xvbmUodGhpcy5fZGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICAgICAgLy8gZWwgaXMgcHJlc2VudCBhcyBhIG9iamVjdCBjb25maWd1cmF0aW9uXG4gICAgICAgIH0gZWxzZSBpZiAoZWwubm9kZVR5cGUgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBlbCA9IHRpbnkuZXh0ZW5kKHRpbnkuY2xvbmUodGhpcy5fZGVmYXVsdHMpLCBlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdGlueS5leHRlbmQodGlueS5jbG9uZSh0aGlzLl9kZWZhdWx0cyksIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBjaC5Nb2RhbChlbCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlRyYW5zaXRpb24ucHJvdG90eXBlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5uYW1lID0gJ3RyYW5zaXRpb24nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQG1lbWJlcm9mISBjaC5UcmFuc2l0aW9uLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNpdGlvbjtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gYnkgZGVmYXVsdC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlRyYW5zaXRpb24ucHJvdG90eXBlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLl9kZWZhdWx0cyA9IHRpbnkuZXh0ZW5kKHRpbnkuY2xvbmUoY2guTW9kYWwucHJvdG90eXBlLl9kZWZhdWx0cyksIHtcbiAgICAgICAgJ19jbGFzc05hbWUnOiAnY2gtdHJhbnNpdGlvbiBjaC1ib3gtbGl0ZScsXG4gICAgICAgICdfYXJpYVJvbGUnOiAnYWxlcnQnLFxuICAgICAgICAnaGlkZGVuYnknOiAnbm9uZScsXG4gICAgICAgICdjb250ZW50JzogJ1BsZWFzZSB3YWl0Li4uJ1xuICAgIH0pO1xuXG4gICAgY2guZmFjdG9yeShUcmFuc2l0aW9uLCBjaC5Nb2RhbC5wcm90b3R5cGUuX25vcm1hbGl6ZU9wdGlvbnMpO1xuXG59KHRoaXMuY2gpKTtcblxuKGZ1bmN0aW9uICh3aW5kb3csIGNoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogWm9vbSBzaG93cyBhIGNvbnRleHR1YWwgcmVmZXJlbmNlIHRvIGFuIGF1Z21lbnRlZCB2ZXJzaW9uIG9mIGEgZGVjbGFyZWQgaW1hZ2UuXG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIGNoLkxheWVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIEEgQ1NTIFNlbGVjdG9yIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBjaC5ab29tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBjdXN0b21pemUgYW4gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFkZENsYXNzXSBDU1MgY2xhc3MgbmFtZXMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjb250YWluZXIgb24gdGhlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZnhdIEVuYWJsZSBvciBkaXNhYmxlIFVJIGVmZmVjdHMuIFlvdSBtdXN0IHVzZTogXCJzbGlkZURvd25cIiwgXCJmYWRlSW5cIiBvciBcIm5vbmVcIi4gRGVmYXVsdDogXCJub25lXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndpZHRoXSBTZXQgYSB3aWR0aCBmb3IgdGhlIGNvbnRhaW5lci4gRGVmYXVsdDogXCIzMDBweFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5oZWlnaHRdIFNldCBhIGhlaWdodCBmb3IgdGhlIGNvbnRhaW5lci4gRGVmYXVsdDogXCIzMDBweFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zaG93bmJ5XSBEZXRlcm1pbmVzIGhvdyB0byBpbnRlcmFjdCB3aXRoIHRoZSB0cmlnZ2VyIHRvIHNob3cgdGhlIGNvbnRhaW5lci4gWW91IG11c3QgdXNlOiBcInBvaW50ZXJ0YXBcIiwgXCJwb2ludGVyZW50ZXJcIiBvciBcIm5vbmVcIi4gRGVmYXVsdDogXCJwb2ludGVyZW50ZXJcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaGlkZGVuYnldIERldGVybWluZXMgaG93IHRvIGhpZGUgdGhlIGNvbXBvbmVudC4gWW91IG11c3QgdXNlOiBcImJ1dHRvblwiLCBcInBvaW50ZXJzXCIsIFwicG9pbnRlcmxlYXZlXCIsIFwiYWxsXCIgb3IgXCJub25lXCIuIERlZmF1bHQ6IFwicG9pbnRlcmxlYXZlXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJlZmVyZW5jZV0gSXQncyBhIENTUyBTZWxlY3RvciByZWZlcmVuY2UgdG8gcG9zaXRpb24gYW5kIHNpemUgb2YgZWxlbWVudCB0aGF0IHdpbGwgYmUgY29uc2lkZXJlZCB0byBjYXJyeSBvdXQgdGhlIHBvc2l0aW9uLiBEZWZhdWx0OiB0aGUgdHJpZ2dlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zaWRlXSBUaGUgc2lkZSBvcHRpb24gd2hlcmUgdGhlIHRhcmdldCBlbGVtZW50IHdpbGwgYmUgcG9zaXRpb25lZC4gSXRzIHZhbHVlIGNhbiBiZTogXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIiBvciBcImNlbnRlclwiLiBEZWZhdWx0OiBcInJpZ2h0XCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFsaWduXSBUaGUgYWxpZ24gb3B0aW9ucyB3aGVyZSB0aGUgdGFyZ2V0IGVsZW1lbnQgd2lsbCBiZSBwb3NpdGlvbmVkLiBJdHMgdmFsdWUgY2FuIGJlOiBcImxlZnRcIiwgXCJyaWdodFwiLCBcInRvcFwiLCBcImJvdHRvbVwiIG9yIFwiY2VudGVyXCIuIERlZmF1bHQ6IFwidG9wXCIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFhdIERpc3RhbmNlIHRvIGRpc3BsYWNlIHRoZSB0YXJnZXQgaG9yaXpvbnRhbGx5LiBEZWZhdWx0OiAyMC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WV0gRGlzdGFuY2UgdG8gZGlzcGxhY2UgdGhlIHRhcmdldCB2ZXJ0aWNhbGx5LiBEZWZhdWx0OiAwLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbl0gVGhlIHR5cGUgb2YgcG9zaXRpb25pbmcgdXNlZC4gSXRzIHZhbHVlIG11c3QgYmUgXCJhYnNvbHV0ZVwiIG9yIFwiZml4ZWRcIi4gRGVmYXVsdDogXCJhYnNvbHV0ZVwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2RdIFRoZSB0eXBlIG9mIHJlcXVlc3QgKFwiUE9TVFwiIG9yIFwiR0VUXCIpIHRvIGxvYWQgY29udGVudCBieSBhamF4LiBEZWZhdWx0OiBcIkdFVFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbXNdIFBhcmFtcyBsaWtlIHF1ZXJ5IHN0cmluZyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYWNoZV0gRm9yY2UgdG8gY2FjaGUgdGhlIHJlcXVlc3QgYnkgdGhlIGJyb3dzZXIuIERlZmF1bHQ6IHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hc3luY10gRm9yY2UgdG8gc2VudCByZXF1ZXN0IGFzeW5jaHJvbm91c2x5LiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IEhUTUxFbGVtZW50KX0gW29wdGlvbnMud2FpdGluZ10gVGVtcG9yYXJ5IGNvbnRlbnQgdG8gdXNlIHdoaWxlIHRoZSBhamF4IHJlcXVlc3QgaXMgbG9hZGluZy4gRGVmYXVsdDogJ0xvYWRpbmcgem9vbS4uLicuXG4gICAgICogQHBhcmFtIHsoSFRNTEVsZW1lbnQgfCBTdHJpbmcpfSBbb3B0aW9ucy5jb250ZW50XSBUaGUgY29udGVudCB0byBiZSBzaG93biBpbnRvIHRoZSBab29tIGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJucyB7em9vbX0gUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBab29tLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IFpvb20uXG4gICAgICogdmFyIHpvb20gPSBuZXcgY2guWm9vbShbc2VsZWN0b3JdLCBbb3B0aW9uc10pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IFpvb20gd2l0aCBhIGRlZmluZWQgd2lkdGggKGhhbGYgb2YgdGhlIHNjcmVlbikuXG4gICAgICogdmFyIHpvb20gPSBuZXcgY2guWm9vbSh7XG4gICAgICogICAgICd3aWR0aCc6IChjaC52aWV3cG9ydC53aWR0aCAvIDIpICsgJ3B4J1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFpvb20oc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2luaXQoc2VsZWN0b3IsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB5b3UgZGVmaW5lIGFuIGluaXRpYWxpemUgbWV0aG9kLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYSBuZXcgWm9vbSBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mISBjaC5ab29tLnByb3RvdHlwZVxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHJlYWR5IHRvIHVzZS5cbiAgICAgICAgICogQGV2ZW50IGNoLlpvb20jcmVhZHlcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwicmVhZHlcIiBldmVudC5cbiAgICAgICAgICogem9vbS5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRoYXQuZW1pdCgncmVhZHknKTsgfSwgNTApO1xuICAgIH1cblxuICAgIC8vIEluaGVyaXRhbmNlXG4gICAgdGlueS5pbmhlcml0cyhab29tLCBjaC5MYXllcik7XG5cbiAgICB2YXIgcGFyZW50ID0gWm9vbS5zdXBlcl8ucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlpvb20ucHJvdG90eXBlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBab29tLnByb3RvdHlwZS5uYW1lID0gJ3pvb20nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQG1lbWJlcm9mISBjaC5ab29tLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIFpvb20ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWm9vbTtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gYnkgZGVmYXVsdC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlpvb20ucHJvdG90eXBlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFpvb20ucHJvdG90eXBlLl9kZWZhdWx0cyA9IHRpbnkuZXh0ZW5kKHRpbnkuY2xvbmUocGFyZW50Ll9kZWZhdWx0cyksIHtcbiAgICAgICAgJ19jbGFzc05hbWUnOiAnY2gtem9vbScsXG4gICAgICAgICdfYXJpYVJvbGUnOiAndG9vbHRpcCcsXG4gICAgICAgICdfaGlkZURlbGF5JzogMCxcbiAgICAgICAgJ2Z4JzogJ25vbmUnLFxuICAgICAgICAnd2lkdGgnOiAnMzAwcHgnLFxuICAgICAgICAnaGVpZ2h0JzogJzMwMHB4JyxcbiAgICAgICAgJ3NpZGUnOiAncmlnaHQnLFxuICAgICAgICAnYWxpZ24nOiAndG9wJyxcbiAgICAgICAgJ29mZnNldFgnOiAyMCxcbiAgICAgICAgJ29mZnNldFknOiAwLFxuICAgICAgICAnd2FpdGluZyc6ICdMb2FkaW5nIHpvb20uLi4nXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IGluc3RhbmNlIG9mIFpvb20gYW5kIG1lcmdlIGN1c3RvbSBvcHRpb25zIHdpdGggZGVmYXVsdHMgb3B0aW9ucy5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlpvb20ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7em9vbX1cbiAgICAgKi9cbiAgICBab29tLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICAgICAvLyBDYWxsIHRvIGl0cyBwYXJlbnQgaW5pdCBtZXRob2RcbiAgICAgICAgcGFyZW50Ll9pbml0LmNhbGwodGhpcywgc2VsZWN0b3IsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gY29udGV4dCBvZiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmxhZyB0byBjb250cm9sIHdoZW4gem9vbWVkIGltYWdlIGlzIGxvYWRlZC5cbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmVlZGJhY2sgc2hvd2VkIGJlZm9yZSB0aGUgem9vbWVkIGltYWdlIGlzIGxvYWQuIEl0J3MgYSB0cmFuc2l0aW9uIG1lc3NhZ2UgYW5kIGl0cyBjb250ZW50IGNhbiBiZSBjb25maWd1cmVkIHRocm91Z2ggcGFyYW1ldGVyIFwid2FpdGluZ1wiLlxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIENoYW5naW5nIHRoZSBsb2FkaW5nIGZlZWRiYWNrLlxuICAgICAgICAgKiB2YXIgem9vbSA9IG5ldyBjaC5ab29tKHtcbiAgICAgICAgICogICAgICd3YWl0aW5nJzogJ015IGN1c3RvbSBtZXNzYWdlJ1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZHVtbXlFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBkdW1teUVsZW1lbnQuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJjaC16b29tLWxvYWRpbmcgY2gtaGlkZVwiPjxkaXYgY2xhc3M9XCJjaC1sb2FkaW5nLWxhcmdlXCI+PC9kaXY+PHA+JyArIHRoYXQuX29wdGlvbnMud2FpdGluZyArICc8L3A+PC9kaXY+JztcblxuICAgICAgICAgICAgcmV0dXJuIGR1bW15RWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgICB9KCkpO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlci5hcHBlbmRDaGlsZCh0aGlzLl9sb2FkaW5nKTtcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIVE1MIEVsZW1lbnQgc2hhcGUgd2l0aCB2aXN1YWwgZmVlZGJhY2sgdG8gdGhlIHJlbGF0aXZlIHNpemUgb2YgdGhlIHpvb21lZCBhcmVhLlxuICAgICAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZWVrZXIgPSAoZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICB2YXIgZHVtbXlFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBkdW1teUVsZW1lbnQuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJjaC16b29tLXNlZWtlciBjaC1oaWRlXCI+PC9kaXY+JztcblxuICAgICAgICAgICAgcmV0dXJuIGR1bW15RWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgICB9KCkpO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlci5hcHBlbmRDaGlsZCh0aGlzLl9zZWVrZXIpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWFpbiBzcGVjaWZpZWQgaW1hZ2Ugd2l0aCBvcmlnaW5hbCBzaXplIChub3Qgem9vbWVkKS5cbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb3JpZ2luYWwgPSB0aGlzLnRyaWdnZXIuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB6b29tZWQgaW1hZ2Ugc3BlY2lmaWVkIGFzIGEgbGluayBocmVmIChzZWUgdGhlIEhUTUwgc25pcHBldCkuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVXNlIGEgbmV3IEltYWdlIHRvIGNhbGN1bGF0ZSB0aGVcbiAgICAgICAgLy8gc2l6ZSBiZWZvcmUgYXBwZW5kIHRoZSBpbWFnZSB0byBET00sIGluIEFMTCB0aGUgYnJvd3NlcnMuXG4gICAgICAgIHRoaXMuX3pvb21lZCA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcblxuICAgICAgICAvLyBBc3NpZ24gZXZlbnQgaGFuZGxlcnMgdG8gdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgICAgIG9uSW1hZ2VzTG9hZHModGhpcy5fb3JpZ2luYWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuX29yaWdpbmFsTG9hZGVkKCk7XG5cbiAgICAgICAgICAgIHRpbnkub24od2luZG93LCAncmVzaXplJywgdGhhdC5fdXBkYXRlT2Zmc2V0LmJpbmQodGhhdCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBc3NpZ24gZXZlbnQgaGFuZGxlcnMgdG8gdGhlIHpvb21lZCBpbWFnZVxuICAgICAgICBvbkltYWdlc0xvYWRzKHRoaXMuX3pvb21lZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5fem9vbWVkTG9hZGVkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1ha2UgdGhlIGVudGlyZSBTaG93IHByb2Nlc3MgaWYgaXQgdHJpZWQgdG8gc2hvdyBiZWZvcmVcbiAgICAgICAgdGhpcy5vbignaW1hZ2Vsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aW55Lmhhc0NsYXNzKHRoaXMuX2xvYWRpbmcsICdjaC1oaWRlJykpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnNob3coKTtcbiAgICAgICAgICAgICAgICB0aW55LmFkZENsYXNzKHRoaXMuX2xvYWRpbmcsICdjaC1oaWRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFzc2lnbiBldmVudCBoYW5kbGVycyB0byB0aGUgYW5jaG9yXG4gICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy50cmlnZ2VyLCAnY2gtem9vbS10cmlnZ2VyJyk7XG5cbiAgICAgICAgLy8gUHJldmVudCB0byByZWRpcmVjdCB0byB0aGUgaHJlZlxuICAgICAgICB0aW55Lm9uKHRoaXMudHJpZ2dlciwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IH0sIGZhbHNlKTtcblxuICAgICAgICAvLyBCaW5kIG1vdmUgY2FsY3VsYXRpb25zXG4gICAgICAgIHRpbnkub24odGhpcy50cmlnZ2VyLCBjaC5vbnBvaW50ZXJtb3ZlLCBmdW5jdGlvbiAoZXZlbnQpIHsgdGhhdC5fbW92ZShldmVudCk7IH0sIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29ycmVjdCBzaXplIHRvIHRoZSB3cmFwcGVyIGFuY2hvci5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlpvb20ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBab29tLnByb3RvdHlwZS5fb3JpZ2luYWxMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5fb3JpZ2luYWwud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9vcmlnaW5hbC5oZWlnaHQ7XG5cbiAgICAgICAgLy8gU2V0IHRoZSB3cmFwcGVyIGFuY2hvciBzaXplIChzYW1lIGFzIGltYWdlKVxuICAgICAgICB0aGlzLnRyaWdnZXIuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMudHJpZ2dlci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIC8vIExvYWRpbmcgcG9zaXRpb24gY2VudGVyZWQgaW50byB0aGUgYW5jaG9yXG4gICAgICAgIHRoaXMuX2xvYWRpbmcuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuX2xvYWRpbmcuc3R5bGUubGVmdCA9ICh3aWR0aCAtIHRoaXMuX2xvYWRpbmcuY2xpZW50V2lkdGgpIC8gMiArICdweCc7XG4gICAgICAgIHRoaXMuX2xvYWRpbmcuc3R5bGUudG9wID0gKGhlaWdodCAtIHRoaXMuX2xvYWRpbmcuY2xpZW50SGVpZ2h0KSAvIDIgKyAncHgnO1xuICAgICAgICB0aGlzLl9sb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2lkdGggb2YgdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBpbWFnZS5cbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29yaWdpbmFsV2lkdGggPSB3aWR0aDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGVpZ2h0IG9mIHRoZSBvcmlnaW5hbCBzcGVjaWZpZWQgaW1hZ2UuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vcmlnaW5hbEhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLl91cGRhdGVPZmZzZXQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGUgYW4gb2Zmc2V0IG9mIHRoZSBvcmlnaW5hbCBpbWFnZSB0aGF0IGlzIHVzZWQgYXMgcmVmZXJlbmNlIGVsZW1lbnQgZm9yIFBvcG92ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFpvb20ucHJvdG90eXBlLl91cGRhdGVPZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRpbnkub2Zmc2V0KHRoaXMuX2VsKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGVmdCBwb3NpdGlvbiBvZiB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGFuY2hvci9pbWFnZS5cbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29yaWdpbmFsT2Zmc2V0TGVmdCA9IG9mZnNldC5sZWZ0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3AgcG9zaXRpb24gb2YgdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhbmNob3IvaW1hZ2UuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vcmlnaW5hbE9mZnNldFRvcCA9IG9mZnNldC50b3A7XG5cbiAgICAgICAgLy8gUmVmcmVzaCB6b29tZWQgaW1hZ2UgcG9zaXRpb24gdGhhdCBzdGF5cyBpbiBhIFBvcG92ZXJcbiAgICAgICAgdGhpcy5fcG9zaXRpb25lci5yZWZyZXNoKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBab29tIGNvbnRlbnQgYW5kIHNldHMgdGhlIFNlZWtlciBzaXplLlxuICAgICAqIEBtZW1iZXJvZiEgY2guWm9vbS5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFpvb20ucHJvdG90eXBlLl96b29tZWRMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbGF0aW9uIGJldHdlZW4gdGhlIHpvb21lZCBhbmQgdGhlIG9yaWdpbmFsIGltYWdlIHdpZHRoLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmF0aW9YID0gKHRoaXMuX3pvb21lZC53aWR0aCAvIHRoaXMuX29yaWdpbmFsV2lkdGgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWxhdGlvbiBiZXR3ZWVuIHRoZSB6b29tZWQgYW5kIHRoZSBvcmlnaW5hbCBpbWFnZSBoZWlnaHQuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yYXRpb1kgPSAodGhpcy5fem9vbWVkLmhlaWdodCAvIHRoaXMuX29yaWdpbmFsSGVpZ2h0KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2lkdGggb2YgdGhlIFNlZWtlciwgY2FsY3VsYXRlZCBmcm9tIHJhdGlvLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2Vla2VyV2lkdGggPSB3aW5kb3cuTWF0aC5mbG9vcih3aW5kb3cucGFyc2VJbnQodGhpcy5fb3B0aW9ucy53aWR0aCwgMTApIC8gdGhpcy5fcmF0aW9YKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGVpZ2h0IG9mIHRoZSBTZWVrZXIsIGNhbGN1bGF0ZWQgZnJvbSByYXRpby5cbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NlZWtlckhlaWdodCA9IHdpbmRvdy5NYXRoLmZsb29yKHdpbmRvdy5wYXJzZUludCh0aGlzLl9vcHRpb25zLmhlaWdodCwgMTApIC8gdGhpcy5fcmF0aW9ZKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFsZiBvZiB0aGUgd2lkdGggb2YgdGhlIFNlZWtlci4gVXNlZCB0byBwb3NpdGlvbiBpdC5cbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NlZWtlckhhbGZXaWR0aCA9IHdpbmRvdy5NYXRoLmZsb29yKHRoaXMuX3NlZWtlcldpZHRoIC8gMik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbGYgb2YgdGhlIGhlaWdodCBvZiB0aGUgU2Vla2VyLiBVc2VkIHRvIHBvc2l0aW9uIGl0LlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2Vla2VySGFsZkhlaWdodCA9IHdpbmRvdy5NYXRoLmZsb29yKHRoaXMuX3NlZWtlckhlaWdodCAvIDIpO1xuXG4gICAgICAgIC8vIFNldCBzaXplIG9mIHRoZSBTZWVrZXJcbiAgICAgICAgdGhpcy5fc2Vla2VyLnN0eWxlLmNzc1RleHQgPSAnd2lkdGg6JyArIHRoaXMuX3NlZWtlcldpZHRoICsgJ3B4O2hlaWdodDonICsgdGhpcy5fc2Vla2VySGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAvLyBVc2UgdGhlIHpvb21lZCBpbWFnZSBhcyBjb250ZW50IGZvciB0aGUgZmxvYXRlZCBlbGVtZW50XG4gICAgICAgIHRoaXMuY29udGVudCh0aGlzLl96b29tZWQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZmxhZyB0byBhbGxvdyB0byB6b29tXG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgem9vbWVkIGltYWdlIGlzIGRvd25sb2FkZWQuXG4gICAgICAgICAqIEBldmVudCBjaC5ab29tI2ltYWdlbG9hZFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJpbWFnZWxvYWRcIiBldmVudC5cbiAgICAgICAgICogem9vbS5vbignaW1hZ2Vsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgYWxlcnQoJ1pvb21lZCBpbWFnZSByZWFkeSEnKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoJ2ltYWdlbG9hZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIG1vdmVtZW50IGxpbWl0cyBhbmQgc2V0cyBpdCB0byBTZWVrZXIgYW5kIHpvb21lZCBpbWFnZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlpvb20ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBVc2VkIHRvIHRha2UgdGhlIGN1cnNvciBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBab29tLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBEb24ndCBleGVjdXRlIHdoZW4gaXQncyBkaXNhYmxlZCBvciBpdCdzIG5vdCBsb2FkZWRcbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkIHx8ICF0aGlzLl9sb2FkZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ5IGRlZmluaW5nIHRoZXNlIHZhcmlhYmxlcyBpbiBoZXJlLCBpdCBhdm9pZHMgdG8gbWFrZVxuICAgICAgICAvLyB0aGUgc3Vic3RyYWN0aW9uIHR3aWNlIGlmIGl0J3MgYSBmcmVlIG1vdmVtZW50XG4gICAgICAgIHZhciBwYWdlWCA9IChldmVudC5wYWdlWCB8fCBldmVudC5jbGllbnRYICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQpLFxuICAgICAgICAgICAgcGFnZVkgPSAoZXZlbnQucGFnZVkgfHwgZXZlbnQuY2xpZW50WSArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApLFxuICAgICAgICAgICAgc2Vla2VyTGVmdCA9IHBhZ2VYIC0gdGhpcy5fc2Vla2VySGFsZldpZHRoLFxuICAgICAgICAgICAgc2Vla2VyVG9wID0gcGFnZVkgLSB0aGlzLl9zZWVrZXJIYWxmSGVpZ2h0LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHk7XG5cbiAgICAgICAgLy8gTGVmdCBzaWRlIG9mIHNlZWtlciBMRVNTIFRIQU4gbGVmdCBzaWRlIG9mIGltYWdlXG4gICAgICAgIGlmIChzZWVrZXJMZWZ0IDw9IHRoaXMuX29yaWdpbmFsT2Zmc2V0TGVmdCkge1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgIC8vIFJpZ2h0IHNpZGUgb2Ygc2Vla2VyIEdSRUFURVIgVEhBTiByaWdodCBzaWRlIG9mIGltYWdlXG4gICAgICAgIH0gZWxzZSBpZiAocGFnZVggKyB0aGlzLl9zZWVrZXJIYWxmV2lkdGggPiB0aGlzLl9vcmlnaW5hbFdpZHRoICsgdGhpcy5fb3JpZ2luYWxPZmZzZXRMZWZ0KSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5fb3JpZ2luYWxXaWR0aCAtIHRoaXMuX3NlZWtlcldpZHRoIC0gMjtcbiAgICAgICAgLy8gRnJlZSBtb3ZlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gc2Vla2VyTGVmdCAtIHRoaXMuX29yaWdpbmFsT2Zmc2V0TGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvcCBzaWRlIG9mIHNlZWtlciBMRVNTIFRIQU4gdG9wIHNpZGUgb2YgaW1hZ2VcbiAgICAgICAgaWYgKHNlZWtlclRvcCA8PSB0aGlzLl9vcmlnaW5hbE9mZnNldFRvcCkge1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgIC8vIEJvdHRvbSBzaWRlIG9mIHNlZWtlciBHUkVBVEVSIFRIQU4gYm90dG9tIHNpZGUgb2YgaW1hZ2VcbiAgICAgICAgfSBlbHNlIGlmIChwYWdlWSArIHRoaXMuX3NlZWtlckhhbGZIZWlnaHQgPiB0aGlzLl9vcmlnaW5hbEhlaWdodCArIHRoaXMuX29yaWdpbmFsT2Zmc2V0VG9wKSB7XG4gICAgICAgICAgICB5ID0gdGhpcy5fb3JpZ2luYWxIZWlnaHQgLSB0aGlzLl9zZWVrZXJIZWlnaHQgLSAyO1xuICAgICAgICAvLyBGcmVlIG1vdmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkgPSBzZWVrZXJUb3AgLSB0aGlzLl9vcmlnaW5hbE9mZnNldFRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmUgc2Vla2VyIGFuZCB0aGUgem9vbWVkIGltYWdlXG4gICAgICAgIHRoaXMuX3NlZWtlci5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgIHRoaXMuX3NlZWtlci5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICAgICAgdGhpcy5fem9vbWVkLnN0eWxlLmNzc1RleHQgPSAnbGVmdDonICsgKC10aGlzLl9yYXRpb1ggKiB4KSArICdweDt0b3A6JyArICgtdGhpcy5fcmF0aW9ZICogeSkgKyAncHgnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgem9vbSBjb250YWluZXIgYW5kIHRoZSBTZWVrZXIsIG9yIHNob3cgYSBsb2FkaW5nIGZlZWRiYWNrIHVudGlsIHRoZSB6b29tZWQgaW1hZ2UgbG9hZHMuXG4gICAgICogQG1lbWJlcm9mISBjaC5ab29tLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IEhUTUxFbGVtZW50KX0gW2NvbnRlbnRdIFRoZSBjb250ZW50IHRoYXQgd2lsbCBiZSB1c2VkIGJ5IGRyb3Bkb3duLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBjdXN0b20gb3B0aW9ucyB0byBiZSB1c2VkIHdpdGggY29udGVudCBsb2FkZWQgYnkgYWpheC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWV0aG9kXSBUaGUgdHlwZSBvZiByZXF1ZXN0IChcIlBPU1RcIiBvciBcIkdFVFwiKSB0byBsb2FkIGNvbnRlbnQgYnkgYWpheC4gRGVmYXVsdDogXCJHRVRcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFyYW1zXSBQYXJhbXMgbGlrZSBxdWVyeSBzdHJpbmcgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2FjaGVdIEZvcmNlIHRvIGNhY2hlIHRoZSByZXF1ZXN0IGJ5IHRoZSBicm93c2VyLiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXN5bmNdIEZvcmNlIHRvIHNlbnQgcmVxdWVzdCBhc3luY2hyb25vdXNseS4gRGVmYXVsdDogdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyhTdHJpbmcgfCBIVE1MRWxlbWVudCl9IFtvcHRpb25zLndhaXRpbmddIFRlbXBvcmFyeSBjb250ZW50IHRvIHVzZSB3aGlsZSB0aGUgYWpheCByZXF1ZXN0IGlzIGxvYWRpbmcuXG4gICAgICogQHJldHVybnMge3pvb219XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaG93cyBhIGJhc2ljIHpvb20uXG4gICAgICogem9vbS5zaG93KCk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaG93cyBhIHpvb20gd2l0aCBuZXcgY29udGVudFxuICAgICAqIHpvb20uc2hvdygnU29tZSBuZXcgY29udGVudCBoZXJlIScpO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gU2hvd3MgYSB6b29tIHdpdGggYSBuZXcgY29udGVudCB0aGF0IHdpbGwgYmUgbG9hZGVkIGJ5IGFqYXggd2l0aCBzb21lIGN1c3RvbSBvcHRpb25zXG4gICAgICogem9vbS5zaG93KCdodHRwOi8vZG9tYWluLmNvbS9hamF4L3VybCcsIHtcbiAgICAgKiAgICAgJ2NhY2hlJzogZmFsc2UsXG4gICAgICogICAgICdwYXJhbXMnOiAneC1yZXF1ZXN0PXRydWUnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgWm9vbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIERvbid0IGV4ZWN1dGUgd2hlbiBpdCdzIGRpc2FibGVkXG4gICAgICAgIGlmICghdGhpcy5fZW5hYmxlZCB8fCB0aGlzLl9zaG93bikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG93IGZlZWRiYWNrIGFuZCB0cmlnZ2VyIHRoZSBpbWFnZSBsb2FkLCBpZiBpdCdzIG5vdCBsb2FkZWRcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHtcbiAgICAgICAgICAgIHRpbnkucmVtb3ZlQ2xhc3ModGhpcy5fbG9hZGluZywgJ2NoLWhpZGUnKTtcbiAgICAgICAgICAgIHRoaXMubG9hZEltYWdlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlbGV0ZSB0aGUgTG9hZGluZyBhbmQgc2hvdyB0aGUgU2Vla2VyXG4gICAgICAgIHRpbnkucmVtb3ZlQ2xhc3ModGhpcy5fc2Vla2VyLCAnY2gtaGlkZScpO1xuXG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIG9yaWdpbmFsIHNob3coKVxuICAgICAgICBwYXJlbnQuc2hvdy5jYWxsKHRoaXMsIGNvbnRlbnQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgem9vbSBjb250YWluZXIgYW5kIHRoZSBTZWVrZXIuXG4gICAgICogQG1lbWJlcm9mISBjaC5ab29tLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHt6b29tfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ2xvc2UgYSB6b29tXG4gICAgICogem9vbS5oaWRlKCk7XG4gICAgICovXG4gICAgWm9vbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93bikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBleGVjdXRpb25cbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHtcbiAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy5fbG9hZGluZywgJ2NoLWhpZGUnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGlueS5hZGRDbGFzcyh0aGlzLl9zZWVrZXIsICdjaC1oaWRlJyk7XG5cbiAgICAgICAgcGFyZW50LmhpZGUuY2FsbCh0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgem9vbWVkIGltYWdlIHNvdXJjZSB0byB0aGUgPGltZz4gdGFnIHRvIHRyaWdnZXIgdGhlIHJlcXVlc3QuXG4gICAgICogQG1lbWJlcm9mISBjaC5ab29tLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHt6b29tfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTG9hZCB0aGUgem9vbWVkIGltYWdlIG9uIGRlbWFuZC5cbiAgICAgKiBjb21wb25lbnQubG9hZEltYWdlKCk7XG4gICAgICovXG4gICAgWm9vbS5wcm90b3R5cGUubG9hZEltYWdlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMuX3pvb21lZC5zcmMgPSB0aGlzLl9lbC5ocmVmO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhIFpvb20gaW5zdGFuY2UuXG4gICAgICogQG1lbWJlcm9mISBjaC5ab29tLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHt6b29tfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRGVzdHJveSBhIHpvb21cbiAgICAgKiB6b29tLmRlc3Ryb3koKTtcbiAgICAgKiAvLyBFbXB0eSB0aGUgem9vbSByZWZlcmVuY2VcbiAgICAgKiB6b29tID0gdW5kZWZpbmVkO1xuICAgICAqL1xuICAgIFpvb20ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50O1xuXG4gICAgICAgIHBhcmVudEVsZW1lbnQgPSB0aW55LnBhcmVudCh0aGlzLl9zZWVrZXIpO1xuICAgICAgICBwYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3NlZWtlcik7XG5cbiAgICAgICAgcGFyZW50LmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgY2guZmFjdG9yeShab29tLCBwYXJlbnQuX25vcm1hbGl6ZU9wdGlvbnMpO1xuXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGltYWdlcyBvZiBhIHF1ZXJ5IHNlbGVjdGlvbiBsb2Fkcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1hZ2UgQW4gaW1hZ2Ugb3IgYSBjb2xsZWN0aW9uIG9mIGltYWdlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBoYW5kbGVyIHRoZSBjb21wb25lbnQgd2lsbCBmaXJlIGFmdGVyIHRoZSBpbWFnZXMgbG9hZHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG9uSW1hZ2VzTG9hZHMoSFRNTEltYWdlRWxlbWVudCwgZnVuY3Rpb24gKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnVGhlIHNpemUgb2YgdGhlIGxvYWRlZCBpbWFnZSBpcyAnICsgdGhpcy53aWR0aCk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25JbWFnZXNMb2FkcyhpbWFnZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGltYWdlcztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbWFnZSkpIHtcbiAgICAgICAgICAgIGltYWdlcyA9IGltYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW1hZ2VzID0gW2ltYWdlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGltYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICAgICAgdGlueS5vbihpbWFnZSwgJ2xvYWQnLCBmdW5jdGlvbiBvbkltZ0xvYWQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGltYWdlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDIwMCk7XG5cbiAgICAgICAgICAgICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25JbWdMb2FkKTtcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKGltYWdlLmNvbXBsZXRlIHx8IGltYWdlLmNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3JjID0gaW1hZ2Uuc3JjO1xuICAgICAgICAgICAgICAgIC8vIERhdGEgdXJpIGZpeCBidWcgaW4gd2ViLWtpdCBicm93c2Vyc1xuICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3l3QUFBQUFBUUFCQUFBQ0FVd0FPdz09JztcbiAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSBzcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufSh0aGlzLCB0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAod2luZG93LCBjaCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgJ3NlbGVjdGVkJzogb3B0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdCBsZXRzIHlvdSBtb3ZlIGFjcm9zcyB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCBhbGxvdyB0byBzZXQgZGF0ZXMgYXMgc2VsZWN0ZWQuXG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIGNoLkNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEEgSFRNTEVsZW1lbnQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIGNoLkNhbGVuZGFyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBjdXN0b21pemUgYW4gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZvcm1hdF0gU2V0cyB0aGUgZGF0ZSBmb3JtYXQuIFlvdSBtdXN0IHVzZSBcIkREL01NL1lZWVlcIiwgXCJNTS9ERC9ZWVlZXCIgb3IgXCJZWVlZL01NL0REXCIuIERlZmF1bHQ6IFwiREQvTU0vWVlZWVwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RlZF0gU2V0cyBhIGRhdGUgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQgYnkgZGVmYXVsdC4gRGVmYXVsdDogVGhlIGRhdGUgb2YgdG9kYXkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZyb21dIFNldCBhIG1pbmltdW0gc2VsZWN0YWJsZSBkYXRlLiBUaGUgZm9ybWF0IG9mIHRoZSBnaXZlbiBkYXRlIHNob3VsZCBiZSBZWVlZL01NL0RELlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50b10gU2V0IGEgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuIFRoZSBmb3JtYXQgb2YgdGhlIGdpdmVuIGRhdGUgc2hvdWxkIGJlIFlZWVkvTU0vREQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubW9udGhzTmFtZXNdIEEgY29sbGVjdGlvbiBvZiBtb250aHMgbmFtZXMuIERlZmF1bHQ6IFtcIkVuZXJvXCIsIC4uLiAsIFwiRGljaWVtYnJlXCJdLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLndlZWtkYXlzXSBBIGNvbGxlY3Rpb24gb2Ygd2Vla2RheXMuIERlZmF1bHQ6IFtcIkRvbVwiLCAuLi4gLCBcIlNhYlwiXS5cbiAgICAgKiBAcmV0dXJucyB7Y2FsZW5kYXJ9IFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgQ2FsZW5kYXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgQ2FsZW5kYXIuXG4gICAgICogdmFyIGNhbGVuZGFyID0gbmV3IGNoLkNhbGVuZGFyKFtlbF0sIFtvcHRpb25zXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGVzIGEgbmV3IENhbGVuZGFyIHdpdGggY3VzdG9tIG9wdGlvbnMuXG4gICAgICogdmFyIGNhbGVuZGFyID0gIG5ldyBjaC5DYWxlbmRhcih7XG4gICAgICogICAgICdmb3JtYXQnOiAnTU0vREQvWVlZWScsXG4gICAgICogICAgICdzZWxlY3RlZCc6ICcyMDExLzEyLzI1JyxcbiAgICAgKiAgICAgJ2Zyb20nOiAnMjAxMC8xMi8yNScsXG4gICAgICogICAgICd0byc6ICcyMDEyLzEyLzI1JyxcbiAgICAgKiAgICAgJ21vbnRoc05hbWVzJzogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICAgICAqICAgICAnd2Vla2RheXMnOiBbJ1N1JywgJ01vJywgJ1R1JywgJ1dlJywgJ1RodScsICdGcicsICdTYSddXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGVzIGEgbmV3IENhbGVuZGFyIHVzaW5nIGEgc2hvcnRoYW5kIHdheSAoc2VsZWN0ZWQgZGF0ZSBhcyBwYXJhbWV0ZXIpLlxuICAgICAqIHZhciBjYWxlbmRhciA9IG5ldyBjaC5DYWxlbmRhcignMjAxMS8xMi8yNScpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhbGVuZGFyKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gY29udGV4dCBvZiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICB0aGlzLl9pbml0KGVsLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgeW91IGRlZmluZSBhbiBpbml0aWFsaXplIG1ldGhvZCwgaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGEgbmV3IENhbGVuZGFyIGlzIGNyZWF0ZWQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YhIGNoLkNhbGVuZGFyLnByb3RvdHlwZVxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHJlYWR5IHRvIHVzZS5cbiAgICAgICAgICogQGV2ZW50IGNoLkNhbGVuZGFyI3JlYWR5XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcInJlYWR5XCIgZXZlbnQuXG4gICAgICAgICAqIGNhbGVuZGFyLm9uKCdyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhhdC5lbWl0KCdyZWFkeScpOyB9LCA1MCk7XG4gICAgfVxuXG4gICAgLy8gSW5oZXJpdGFuY2VcbiAgICB0aW55LmluaGVyaXRzKENhbGVuZGFyLCBjaC5Db21wb25lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcGxldGVzIHdpdGggemVybyB0aGUgbnVtYmVycyBsZXNzIHRoYW4gMTAuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHZhciBhZGRaZXJvID0gZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgcmV0dXJuIChwYXJzZUludChudW0sIDEwKSA8IDEwKSA/ICcwJyArIG51bSA6IG51bTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIG9mIGRhdGUgZm9ybWF0cy5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIEZPUk1BVF9kYXRlcyA9IHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyBhIGdpdmVuIGRhdGUgdG8gXCJZWVlZL01NL0REXCIgZm9ybWF0LlxuICAgICAgICAgICAgICogQHBhcmFtcyB7RGF0ZX0gZGF0ZSBBIGdpdmVuIGRhdGUgdG8gY29udmVydC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ1lZWVkvTU0vREQnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbZGF0ZS55ZWFyLCBhZGRaZXJvKGRhdGUubW9udGgpLCBhZGRaZXJvKGRhdGUuZGF5KV0uam9pbignLycpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyBhIGdpdmVuIGRhdGUgdG8gXCJERC9NTS9ZWVlZXCIgZm9ybWF0LlxuICAgICAgICAgICAgICogQHBhcmFtcyB7RGF0ZX0gZGF0ZSBBIGdpdmVuIGRhdGUgdG8gY29udmVydC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ0REL01NL1lZWVknOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbYWRkWmVybyhkYXRlLmRheSksIGFkZFplcm8oZGF0ZS5tb250aCksIGRhdGUueWVhcl0uam9pbignLycpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyBhIGdpdmVuIGRhdGUgdG8gXCJNTS9ERC9ZWVlZXCIgZm9ybWF0LlxuICAgICAgICAgICAgICogQHBhcmFtcyB7RGF0ZX0gZGF0ZSBBIGdpdmVuIGRhdGUgdG8gY29udmVydC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ01NL0REL1lZWVknOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbYWRkWmVybyhkYXRlLm1vbnRoKSwgYWRkWmVybyhkYXRlLmRheSksIGRhdGUueWVhcl0uam9pbignLycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgSlNPTiBPYmplY3Qgd2l0aCByZWZlcmVuY2UgdG8gZGF5LCBtb250aCBhbmQgeWVhciwgZnJvbSBhIGRldGVybWluYXRlZCBkYXRlLlxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZURhdGVPYmplY3QgPSBmdW5jdGlvbiAoZGF0ZSkge1xuXG4gICAgICAgICAgICAvLyBVc2VzIGRhdGUgcGFyYW1ldGVyIG9yIGNyZWF0ZSBhIGRhdGUgZnJvbSB0b2RheVxuICAgICAgICAgICAgZGF0ZSA9IChkYXRlID09PSAndG9kYXknKSA/IG5ldyBEYXRlKCkgOiBuZXcgRGF0ZShkYXRlKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5lZCBjdXN0b20gRGF0ZSBvYmplY3QuXG4gICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byBuYXRpdmUgRGF0ZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0RhdGV9XG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAnbmF0aXZlJzogZGF0ZSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE51bWJlciBvZiBkYXkuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICdkYXknOiBkYXRlLmdldERhdGUoKSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE9yZGVyIG9mIGRheSBpbiBhIHdlZWsuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICdvcmRlcic6IGRhdGUuZ2V0RGF5KCksXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBOdW1iZXIgb2YgbW9udGguXG4gICAgICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICdtb250aCc6IGRhdGUuZ2V0TW9udGgoKSArIDEsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBOdW1iZXIgb2YgZnVsbCB5ZWFyLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAneWVhcic6IGRhdGUuZ2V0RnVsbFllYXIoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJlbnQgPSBDYWxlbmRhci5zdXBlcl8ucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNhbGVuZGFyLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm5hbWUgPSAnY2FsZW5kYXInO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQG1lbWJlcm9mISBjaC5DYWxlbmRhci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYWxlbmRhcjtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gYnkgZGVmYXVsdC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLl9kZWZhdWx0cyA9IHtcbiAgICAgICAgJ21vbnRoc05hbWVzJzogWydFbmVybycsICdGZWJyZXJvJywgJ01hcnpvJywgJ0FicmlsJywgJ01heW8nLCAnSnVuaW8nLCAnSnVsaW8nLCAnQWdvc3RvJywgJ1NlcHRpZW1icmUnLCAnT2N0dWJyZScsICdOb3ZpZW1icmUnLCAnRGljaWVtYnJlJ10sXG4gICAgICAgICd3ZWVrZGF5cyc6IFsnRG9tJywgJ0x1bicsICdNYXInLCAnTWllJywgJ0p1ZScsICdWaWUnLCAnU2FiJ10sXG4gICAgICAgICdmb3JtYXQnOiAnREQvTU0vWVlZWSdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBpbnN0YW5jZSBvZiBDYWxlbmRhciBhbmQgbWVyZ2UgY3VzdG9tIG9wdGlvbnMgd2l0aCBkZWZhdWx0cyBvcHRpb25zLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ2FsZW5kYXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7Y2FsZW5kYXJ9XG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENhbGwgdG8gaXRzIHBhcmVudCBpbml0IG1ldGhvZFxuICAgICAgICBwYXJlbnQuX2luaXQuY2FsbCh0aGlzLCBlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIC8vIGNsb25lTm9kZSh0cnVlKSA+IHBhcmFtZXRlcnMgaXMgcmVxdWlyZWQuIE9wZXJhICYgSUUgdGhyb3dzIGFuZCBpbnRlcm5hbCBlcnJvci4gT3BlcmEgbW9iaWxlIGJyZWFrcy5cbiAgICAgICAgdGhpcy5fc25pcHBldCA9IHRoaXMuX2VsLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT2JqZWN0IHRvIG1hbmdlIHRoZSBkYXRlIGFuZCBpdHMgcmFuZ2VzLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGF0ZXMgPSB7XG4gICAgICAgICAgICAncmFuZ2UnOiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2RhdGVzLnRvZGF5ID0gY3JlYXRlRGF0ZU9iamVjdCgndG9kYXknKTtcblxuICAgICAgICB0aGlzLl9kYXRlcy5jdXJyZW50ID0gdGhpcy5fZGF0ZXMudG9kYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGUgb2Ygc2VsZWN0ZWQgZGF5LlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGF0ZXMuc2VsZWN0ZWQgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAvLyBHZXQgZGF0ZSBmcm9tIGNvbmZpZ3VyYXRpb24gb3IgaW5wdXQgdmFsdWUsIGlmIGNvbmZpZ3VyZWQgY291bGQgYmUgYW4gQXJyYXkgd2l0aCBtdWx0aXBsZSBzZWxlY3Rpb25zXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGF0Ll9vcHRpb25zLnNlbGVjdGVkO1xuXG4gICAgICAgICAgICAvLyBEbyBpdCBvbmx5IGlmIHRoZXJlIGFyZSBhIFwic2VsZWN0ZWRcIiBwYXJhbWV0ZXJcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHsgcmV0dXJuIHNlbGVjdGVkOyB9XG5cbiAgICAgICAgICAgIC8vIFNpbXBsZSBkYXRlIHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNlbGVjdGVkKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkICE9PSAndG9kYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBkYXRlIG9iamVjdCBhbmQgdXBkYXRlIGN1cnJlbnREYXRlXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdGhhdC5fZGF0ZXMuY3VycmVudCA9IGNyZWF0ZURhdGVPYmplY3Qoc2VsZWN0ZWQpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB0aGF0Ll9kYXRlcy50b2RheTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE11bHRpcGxlIGRhdGUgc2VsZWN0aW9uXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkLmZvckVhY2goZnVuY3Rpb24gKGUsIGkpe1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbGUgZGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkW2ldID0gKHNlbGVjdGVkW2ldICE9PSAndG9kYXknKSA/IGNyZWF0ZURhdGVPYmplY3QoZSkgOiB0aGF0Ll9kYXRlcy50b2RheTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkW2ldWzBdID0gKHNlbGVjdGVkW2ldWzBdICE9PSAndG9kYXknKSA/IGNyZWF0ZURhdGVPYmplY3QoZVswXSkgOiB0aGF0Ll9kYXRlcy50b2RheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkW2ldWzFdID0gKHNlbGVjdGVkW2ldWzFdICE9PSAndG9kYXknKSA/IGNyZWF0ZURhdGVPYmplY3QoZVsxXSkgOiB0aGF0Ll9kYXRlcy50b2RheTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH0oKSk7XG5cbiAgICAgICAgLy8gVG9kYXkncyBkYXRlIG9iamVjdFxuICAgICAgICB0aGlzLl9kYXRlcy50b2RheSA9IGNyZWF0ZURhdGVPYmplY3QoJ3RvZGF5Jyk7XG5cbiAgICAgICAgLy8gTWluaW11bSBzZWxlY3RhYmxlIGRhdGVcbiAgICAgICAgdGhpcy5fZGF0ZXMucmFuZ2UuZnJvbSA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgd29ya3Mgd2hlbiB0aGVyZSBhcmUgYSBcImZyb21cIiBwYXJhbWV0ZXIgb24gY29uZmlndXJhdGlvblxuICAgICAgICAgICAgaWYgKHRoYXQuX29wdGlvbnMuZnJvbSA9PT0gdW5kZWZpbmVkIHx8ICF0aGF0Ll9vcHRpb25zLmZyb20pIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBkYXRlIG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuICh0aGF0Ll9vcHRpb25zLmZyb20gPT09ICd0b2RheScpID8gdGhhdC5fZGF0ZXMudG9kYXkgOiBjcmVhdGVEYXRlT2JqZWN0KHRoYXQuX29wdGlvbnMuZnJvbSk7XG5cbiAgICAgICAgfSgpKTtcblxuICAgICAgICAvLyBNYXhpbXVtIHNlbGVjdGFibGUgZGF0ZVxuICAgICAgICB0aGlzLl9kYXRlcy5yYW5nZS50byA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgd29ya3Mgd2hlbiB0aGVyZSBhcmUgYSBcInRvXCIgcGFyYW1ldGVyIG9uIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgIGlmICh0aGF0Ll9vcHRpb25zLnRvID09PSB1bmRlZmluZWQgfHwgIXRoYXQuX29wdGlvbnMudG8pIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBkYXRlIG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuICh0aGF0Ll9vcHRpb25zLnRvID09PSAndG9kYXknKSA/IHRoYXQuX2RhdGVzLnRvZGF5IDogY3JlYXRlRGF0ZU9iamVjdCh0aGF0Ll9vcHRpb25zLnRvKTtcblxuICAgICAgICB9KCkpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW1wbGF0ZSBvZiBwcmV2aW91cyBhcnJvdy5cbiAgICAgICAgICogQHR5cGUge0hUTUxEaXZFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcHJldiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9wcmV2LnNldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycsICdjaC1jYWxlbmRhci1ncmlkLScgKyB0aGlzLnVpZCk7XG4gICAgICAgIHRoaXMuX3ByZXYuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xuICAgICAgICB0aGlzLl9wcmV2LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcbiAgICAgICAgdGlueS5hZGRDbGFzcyh0aGlzLl9wcmV2LCAnY2gtY2FsZW5kYXItcHJldicpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW1wbGF0ZSBvZiBuZXh0IGFycm93LlxuICAgICAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX25leHQuc2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJywgJ2NoLWNhbGVuZGFyLWdyaWQtJyArIHRoaXMudWlkKTtcbiAgICAgICAgdGhpcy5fbmV4dC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuX25leHQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuICAgICAgICB0aW55LmFkZENsYXNzKHRoaXMuX25leHQsICdjaC1jYWxlbmRhci1uZXh0Jyk7XG5cblxuICAgICAgICAvLyBTaG93IG9yIGhpZGUgYXJyb3dzIGRlcGVuZGluZyBvbiBcImZyb21cIiBhbmQgXCJ0b1wiIGxpbWl0c1xuICAgICAgICB0aW55Lm9uKHRoaXMuX3ByZXYsIGNoLm9ucG9pbnRlcnRhcCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhhdC5wcmV2TW9udGgoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRpbnkub24odGhpcy5fbmV4dCwgY2gub25wb2ludGVydGFwLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGF0Lm5leHRNb250aCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbGVuZGFyIGNvbnRhaW5lci5cbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLl9lbDtcbiAgICAgICAgdGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKHRoaXMuX3ByZXYsIHRoaXMuY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUodGhpcy5fbmV4dCwgdGhpcy5jb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsICdjaC1jYWxlbmRhcicpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIHRoaXMuX2NyZWF0ZVRlbXBsYXRlKHRoaXMuX2RhdGVzLmN1cnJlbnQpKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVDb250cm9scygpO1xuXG4gICAgICAgIC8vIEF2b2lkIHNlbGVjdGlvbiBvbiB0aGUgY29tcG9uZW50XG4gICAgICAgIHRoYXQuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgndW5zZWxlY3RhYmxlJywgJ29uJyk7XG4gICAgICAgIHRpbnkuYWRkQ2xhc3ModGhhdC5jb250YWluZXIsICdjaC11c2VyLW5vLXNlbGVjdCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgaXQgaGFzIGdvdCBhIHByZXZpb3VzIG1vbnRoIHRvIHNob3cgZGVwZW5kaW5nIG9uIFwiZnJvbVwiIGxpbWl0LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLl9oYXNQcmV2TW9udGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlcy5yYW5nZS5mcm9tID09PSB1bmRlZmluZWQgfHwgISh0aGlzLl9kYXRlcy5yYW5nZS5mcm9tLm1vbnRoID49IHRoaXMuX2RhdGVzLmN1cnJlbnQubW9udGggJiYgdGhpcy5fZGF0ZXMucmFuZ2UuZnJvbS55ZWFyID49IHRoaXMuX2RhdGVzLmN1cnJlbnQueWVhcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBpdCBoYXMgZ290IGEgbmV4dCBtb250aCB0byBzaG93IGRlcGVuZGluZyBvbiBcInRvXCIgbGltaXRzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLl9oYXNOZXh0TW9udGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlcy5yYW5nZS50byA9PT0gdW5kZWZpbmVkIHx8ICEodGhpcy5fZGF0ZXMucmFuZ2UudG8ubW9udGggPD0gdGhpcy5fZGF0ZXMuY3VycmVudC5tb250aCAmJiB0aGlzLl9kYXRlcy5yYW5nZS50by55ZWFyIDw9IHRoaXMuX2RhdGVzLmN1cnJlbnQueWVhcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZnJlc2ggYXJyb3dzIHZpc2liaWxpdHkgZGVwZW5kaW5nIG9uIFwiZnJvbVwiIGFuZCBcInRvXCIgbGltaXRzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLl91cGRhdGVDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvLyBTaG93IHByZXZpb3VzIGFycm93IHdoZW4gaXQncyBvdXQgb2YgbGltaXRcbiAgICAgICAgaWYgKHRoaXMuX2hhc1ByZXZNb250aCgpKSB7XG4gICAgICAgICAgICB0aW55LnJlbW92ZUNsYXNzKHRoaXMuX3ByZXYsICdjaC1oaWRlJyk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICAvLyBIaWRlIHByZXZpb3VzIGFycm93IHdoZW4gaXQncyBvdXQgb2YgbGltaXRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy5fcHJldiwgJ2NoLWhpZGUnKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXYuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG93IG5leHQgYXJyb3cgd2hlbiBpdCdzIG91dCBvZiBsaW1pdFxuICAgICAgICBpZiAodGhpcy5faGFzTmV4dE1vbnRoKCkpIHtcbiAgICAgICAgICAgIHRpbnkucmVtb3ZlQ2xhc3ModGhpcy5fbmV4dCwgJ2NoLWhpZGUnKTtcbiAgICAgICAgICAgIHRoaXMuX25leHQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgIC8vIEhpZGUgbmV4dCBhcnJvdyB3aGVuIGl0J3Mgb3V0IG9mIGxpbWl0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW55LmFkZENsYXNzKHRoaXMuX25leHQsICdjaC1oaWRlJyk7XG4gICAgICAgICAgICB0aGlzLl9uZXh0LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZnJlc2ggdGhlIHN0cnVjdHVyZSBvZiBDYWxlbmRhcidzIHRhYmxlIHdpdGggYSBuZXcgZGF0ZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5fdXBkYXRlVGVtcGxhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICB2YXIgbW9udGg7XG5cbiAgICAgICAgLy8gVXBkYXRlIFwiY3VycmVudERhdGVcIiBvYmplY3RcbiAgICAgICAgdGhpcy5fZGF0ZXMuY3VycmVudCA9ICh0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpID8gY3JlYXRlRGF0ZU9iamVjdChkYXRlKSA6IGRhdGU7XG5cbiAgICAgICAgLy8gRGVsZXRlIG9sZCB0YWJsZVxuICAgICAgICBtb250aCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJyk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKG1vbnRoKTtcblxuICAgICAgICAvLyBBcHBlbmQgbmV3IHRhYmxlIHRvIGNvbnRlbnRcbiAgICAgICAgdGhpcy5jb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCB0aGlzLl9jcmVhdGVUZW1wbGF0ZSh0aGlzLl9kYXRlcy5jdXJyZW50KSk7XG5cbiAgICAgICAgLy8gUmVmcmVzaCBhcnJvd3NcbiAgICAgICAgdGhpcy5fdXBkYXRlQ29udHJvbHMoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBsZXRlIG1vbnRoIGluIGEgdGFibGUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUuX2NyZWF0ZVRlbXBsYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBjZWxsLFxuICAgICAgICAgICAgcG9zaXRpdmUsXG4gICAgICAgICAgICBkYXksXG4gICAgICAgICAgICBpc1NlbGVjdGVkLFxuICAgICAgICAgICAgdGhlYWQgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZWFkIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIHZhciB0ID0gWyc8dGhlYWQ+PHRyIHJvbGU9XCJyb3dcIj4nXSxcbiAgICAgICAgICAgICAgICAgICAgZGF5SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgd2VlayBuYW1lc1xuICAgICAgICAgICAgICAgIGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IDc7IGRheUluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5wdXNoKCc8dGggcm9sZT1cImNvbHVtbmhlYWRlclwiPicgKyB0aGF0Ll9kZWZhdWx0cy53ZWVrZGF5c1tkYXlJbmRleF0gKyAnPC90aD4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDbG9zZSB0aGVhZCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICB0LnB1c2goJzwvdHI+PC90aGVhZD4nKTtcblxuICAgICAgICAgICAgICAgIC8vIEpvaW4gc3RydWN0dXJlIGFuZCByZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gdC5qb2luKCcnKTtcblxuICAgICAgICAgICAgfSgpKSxcblxuICAgICAgICAgICAgdGFibGUgPSBbXG4gICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cImNoLWNhbGVuZGFyLW1vbnRoXCIgcm9sZT1cImdyaWRcIiBpZD1cImNoLWNhbGVuZGFyLWdyaWQtJyArIHRoYXQudWlkICsgJ1wiPicsXG4gICAgICAgICAgICAgICAgJzxjYXB0aW9uPicgKyB0aGF0Ll9kZWZhdWx0cy5tb250aHNOYW1lc1tkYXRlLm1vbnRoIC0gMV0gKyAnIC0gJyArIGRhdGUueWVhciArICc8L2NhcHRpb24+JyxcbiAgICAgICAgICAgICAgICB0aGVhZFxuICAgICAgICAgICAgXSxcblxuICAgICAgICAgICAgLy8gVG90YWwgYW1vdW50IG9mIGRheXMgaW50byBtb250aFxuICAgICAgICAgICAgY2VsbHMgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgLy8gQW1vdW50IG9mIGRheXMgb2YgY3VycmVudCBtb250aFxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TW9udGggPSBuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGgsIDApLmdldERhdGUoKSxcblxuICAgICAgICAgICAgICAgIC8vIEFtb3VudCBvZiBkYXlzIG9mIHByZXZpb3VzIG1vbnRoXG4gICAgICAgICAgICAgICAgICAgIHByZXZNb250aCA9IG5ldyBEYXRlKFtkYXRlLnllYXIsIGRhdGUubW9udGgsICcwMSddLmpvaW4oJy8nKSkuZ2V0RGF5KCksXG5cbiAgICAgICAgICAgICAgICAvLyBNZXJnZSBhbW91bnQgb2YgcHJldmlvdXMgYW5kIGN1cnJlbnQgbW9udGhcbiAgICAgICAgICAgICAgICAgICAgc3VidG90YWwgPSBwcmV2TW9udGggKyBjdXJyZW50TW9udGgsXG5cbiAgICAgICAgICAgICAgICAvLyBBbW91bnQgb2YgZGF5cyBpbnRvIGxhc3Qgd2VlayBvZiBtb250aFxuICAgICAgICAgICAgICAgICAgICBsYXRlc3QgPSBzdWJ0b3RhbCAlIDcsXG5cbiAgICAgICAgICAgICAgICAvLyBBbW91bnQgb2YgZGF5cyBvZiBuZXh0IG1vbnRoXG4gICAgICAgICAgICAgICAgICAgIG5leHRNb250aCA9IChsYXRlc3QgPiAwKSA/IDcgLSBsYXRlc3QgOiAwO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgJ3ByZXZpb3VzJzogcHJldk1vbnRoLFxuICAgICAgICAgICAgICAgICAgICAnc3VidG90YWwnOiBzdWJ0b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgJ3RvdGFsJzogc3VidG90YWwgKyBuZXh0TW9udGhcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB9KCkpO1xuXG4gICAgICAgIHRhYmxlLnB1c2goJzx0Ym9keT48dHIgY2xhc3M9XCJjaC1jYWxlbmRhci13ZWVrXCIgcm9sZT1cInJvd1wiPicpO1xuXG4gICAgICAgIC8vIEl0ZXJhdGlvbiBvZiB3ZWVrZGF5c1xuICAgICAgICBmb3IgKGNlbGwgPSAwOyBjZWxsIDwgY2VsbHMudG90YWw7IGNlbGwgKz0gMSkge1xuXG4gICAgICAgICAgICAvLyBQdXNoIGFuIGVtcHR5IGNlbGwgb24gcHJldmlvdXMgYW5kIG5leHQgbW9udGhcbiAgICAgICAgICAgIGlmIChjZWxsIDwgY2VsbHMucHJldmlvdXMgfHwgY2VsbCA+IGNlbGxzLnN1YnRvdGFsIC0gMSkge1xuICAgICAgICAgICAgICAgIHRhYmxlLnB1c2goJzx0ZCByb2xlPVwiZ3JpZGNlbGxcIiBjbGFzcz1cImNoLWNhbGVuZGFyLW90aGVyXCI+WDwvdGQ+Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gUG9zaXRpdmUgbnVtYmVyIG9mIGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIHBvc2l0aXZlID0gY2VsbCArIDE7XG5cbiAgICAgICAgICAgICAgICAvLyBEYXkgbnVtYmVyXG4gICAgICAgICAgICAgICAgZGF5ID0gcG9zaXRpdmUgLSBjZWxscy5wcmV2aW91cztcblxuICAgICAgICAgICAgICAgIC8vIERlZmluZSBpZiBpdCdzIHRoZSBkYXkgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkID0gdGhpcy5faXNTZWxlY3RlZChkYXRlLnllYXIsIGRhdGUubW9udGgsIGRheSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgY2VsbFxuICAgICAgICAgICAgICAgIHRhYmxlLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIC8vIE9wZW4gY2VsbCBzdHJ1Y3R1cmUgaW5jbHVkaW5nIFdBSS1BUklBIGFuZCBjbGFzc25hbWVzIHNwYWNlIG9wZW5pbmdcbiAgICAgICAgICAgICAgICAgICAgJzx0ZCByb2xlPVwiZ3JpZGNlbGxcIicgKyAoaXNTZWxlY3RlZCA/ICcgYXJpYS1zZWxlY3RlZD1cInRydWVcIicgOiAnJykgKyAnIGNsYXNzPVwiY2gtY2FsZW5kYXItZGF5JyxcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgVG9kYXkgY2xhc3NuYW1lIGlmIGl0J3MgbmVjZXNhcnlcbiAgICAgICAgICAgICAgICAgICAgKGRhdGUueWVhciA9PT0gdGhhdC5fZGF0ZXMudG9kYXkueWVhciAmJiBkYXRlLm1vbnRoID09PSB0aGF0Ll9kYXRlcy50b2RheS5tb250aCAmJiBkYXkgPT09IHRoYXQuX2RhdGVzLnRvZGF5LmRheSkgPyAnIGNoLWNhbGVuZGFyLXRvZGF5JyA6IG51bGwsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIFNlbGVjdGVkIGNsYXNzbmFtZSBpZiBpdCdzIG5lY2VzYXJ5XG4gICAgICAgICAgICAgICAgICAgIChpc1NlbGVjdGVkID8gJyBjaC1jYWxlbmRhci1zZWxlY3RlZCAnIDogbnVsbCksXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRnJvbS90byByYW5nZS4gRGlzYWJsaW5nIGNlbGxzXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGUgY2VsbCBpZiBpdCdzIG91dCBvZiBGUk9NIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhhdC5fZGF0ZXMucmFuZ2UuZnJvbSAmJiBkYXkgPCB0aGF0Ll9kYXRlcy5yYW5nZS5mcm9tLmRheSAmJiBkYXRlLm1vbnRoID09PSB0aGF0Ll9kYXRlcy5yYW5nZS5mcm9tLm1vbnRoICYmIGRhdGUueWVhciA9PT0gdGhhdC5fZGF0ZXMucmFuZ2UuZnJvbS55ZWFyKSB8fFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIGNlbGwgaWYgaXQncyBvdXQgb2YgVE8gcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGF0Ll9kYXRlcy5yYW5nZS50byAmJiBkYXkgPiB0aGF0Ll9kYXRlcy5yYW5nZS50by5kYXkgJiYgZGF0ZS5tb250aCA9PT0gdGhhdC5fZGF0ZXMucmFuZ2UudG8ubW9udGggJiYgZGF0ZS55ZWFyID09PSB0aGF0Ll9kYXRlcy5yYW5nZS50by55ZWFyKVxuXG4gICAgICAgICAgICAgICAgICAgICkgPyAnIGNoLWNhbGVuZGFyLWRpc2FibGVkJyA6IG51bGwsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2UgY2xhc3NuYW1lcyBhdHRyaWJ1dGUgYW5kIHByaW50IGNvbnRlbnQgY2xvc2luZyBjZWxsIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICAnXCI+JyArIGRheSArICc8L3RkPidcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3V0IHdlZWsgaWYgdGhlcmUgYXJlIHNldmVuIGRheXNcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpdmUgJSA3ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlLnB1c2goJzwvdHI+PHRyIGNsYXNzPVwiY2gtY2FsZW5kYXItd2Vla1wiIHJvbGU9XCJyb3dcIj4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdGFibGUucHVzaCgnPC90cj48L3Rib2R5PjwvdGFibGU+Jyk7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRhYmxlIG9iamVjdFxuICAgICAgICByZXR1cm4gdGFibGUuam9pbignJyk7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gZGF0ZSBpcyBpbnRvICdmcm9tJyBhbmQgJ3RvJyBkYXRlcy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5faXNJblJhbmdlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdmFyIGluUmFuZ2VGcm9tID0gdHJ1ZSxcbiAgICAgICAgICAgIGluUmFuZ2VUbyA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2RhdGVzLnJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgIGluUmFuZ2VGcm9tID0gKHRoaXMuX2RhdGVzLnJhbmdlLmZyb20ubmF0aXZlIDw9IGRhdGUubmF0aXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9kYXRlcy5yYW5nZS50bykge1xuICAgICAgICAgICAgaW5SYW5nZVRvID0gKHRoaXMuX2RhdGVzLnJhbmdlLnRvLm5hdGl2ZSA+PSBkYXRlLm5hdGl2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5SYW5nZUZyb20gJiYgaW5SYW5nZVRvO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgYW4gc3BlY2lmaWMgZGF0ZSBpcyBzZWxlY3RlZCBvciBub3QgKGluY2x1ZGluZyBkYXRlIHJhbmdlcyBhbmQgc2ltcGxlIGRhdGVzKS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5faXNTZWxlY3RlZCA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgICAgIHZhciB5ZXBub3BlO1xuXG4gICAgICAgIGlmICghdGhpcy5fZGF0ZXMuc2VsZWN0ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgeWVwbm9wZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNpbXBsZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuX2RhdGVzLnNlbGVjdGVkKSkge1xuICAgICAgICAgICAgaWYgKHllYXIgPT09IHRoaXMuX2RhdGVzLnNlbGVjdGVkLnllYXIgJiYgbW9udGggPT09IHRoaXMuX2RhdGVzLnNlbGVjdGVkLm1vbnRoICYmIGRheSA9PT0gdGhpcy5fZGF0ZXMuc2VsZWN0ZWQuZGF5KSB7XG4gICAgICAgICAgICAgICAgeWVwbm9wZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHllcG5vcGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLy8gTXVsdGlwbGUgc2VsZWN0aW9uIChyYW5nZXMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRlcy5zZWxlY3RlZC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIGRhdGVcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHllYXIgPT09IGUueWVhciAmJiBtb250aCA9PT0gZS5tb250aCAmJiBkYXkgPT09IGUuZGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ZXBub3BlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5ZXBub3BlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmFuZ2VcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoeWVhciA+PSBlWzBdLnllYXIgJiYgbW9udGggPj0gZVswXS5tb250aCAmJiBkYXkgPj0gZVswXS5kYXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHllYXIgPD0gZVsxXS55ZWFyICYmIG1vbnRoIDw9IGVbMV0ubW9udGggJiYgZGF5IDw9IGVbMV0uZGF5KVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHllcG5vcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHllcG5vcGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB5ZXBub3BlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgc3BlY2lmaWMgZGF0ZSBvciByZXR1cm5zIHRoZSBzZWxlY3RlZCBkYXRlLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ2FsZW5kYXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRlXSBBIGdpdmVuIGRhdGUgdG8gc2VsZWN0LiBUaGUgZm9ybWF0IG9mIHRoZSBnaXZlbiBkYXRlIHNob3VsZCBiZSBcIllZWVkvTU0vRERcIi5cbiAgICAgKiBAcmV0dXJucyB7Y2FsZW5kYXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBSZXR1cm5zIHRoZSBzZWxlY3RlZCBkYXRlLlxuICAgICAqIGNhbGVuZGFyLnNlbGVjdCgpO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gU2VsZWN0IGEgc3BlY2lmaWMgZGF0ZS5cbiAgICAgKiBjYWxlbmRhci5zZWxlY3QoJzIwMTQvMDUvMjgnKTtcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgLy8gR2V0dGVyXG4gICAgICAgIGlmICghZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RhdGVzLnNlbGVjdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRk9STUFUX2RhdGVzW3RoaXMuX29wdGlvbnMuZm9ybWF0XSh0aGlzLl9kYXRlcy5zZWxlY3RlZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR0ZXJcbiAgICAgICAgdmFyIG5ld0RhdGUgPSBjcmVhdGVEYXRlT2JqZWN0KGRhdGUpO1xuXG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc0luUmFuZ2UobmV3RGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGVkIGRhdGVcbiAgICAgICAgdGhpcy5fZGF0ZXMuc2VsZWN0ZWQgPSAoZGF0ZSA9PT0gJ3RvZGF5JykgPyB0aGlzLl9kYXRlcy50b2RheSA6IG5ld0RhdGU7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHRhYmxlIG9mIHNlbGVjdGVkIG1vbnRoXG4gICAgICAgIHRoaXMuX3VwZGF0ZVRlbXBsYXRlKHRoaXMuX2RhdGVzLnNlbGVjdGVkKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIGEgZGF0ZSBpcyBzZWxlY3RlZC5cbiAgICAgICAgICogQGV2ZW50IGNoLkNhbGVuZGFyI3NlbGVjdFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJzZWxlY3RcIiBldmVudC5cbiAgICAgICAgICogY2FsZW5kYXIub24oJ3NlbGVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1pdCgnc2VsZWN0Jyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0ZSBvZiB0b2RheVxuICAgICAqIEBtZW1iZXJvZiEgY2guQ2FsZW5kYXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGRhdGUgb2YgdG9kYXlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEdldCB0aGUgZGF0ZSBvZiB0b2RheS5cbiAgICAgKiB2YXIgdG9kYXkgPSBjYWxlbmRhci5nZXRUb2RheSgpO1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRUb2RheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEZPUk1BVF9kYXRlc1t0aGlzLl9vcHRpb25zLmZvcm1hdF0odGhpcy5fZGF0ZXMudG9kYXkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0byB0aGUgbmV4dCBtb250aC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNhbGVuZGFyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtjYWxlbmRhcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIE1vdmVzIHRvIHRoZSBuZXh0IG1vbnRoLlxuICAgICAqIGNhbGVuZGFyLm5leHRNb250aCgpO1xuICAgICAqL1xuICAgIENhbGVuZGFyLnByb3RvdHlwZS5uZXh0TW9udGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZW5hYmxlZCB8fCAhdGhpcy5faGFzTmV4dE1vbnRoKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmV4dCB5ZWFyXG4gICAgICAgIGlmICh0aGlzLl9kYXRlcy5jdXJyZW50Lm1vbnRoID09PSAxMikge1xuICAgICAgICAgICAgdGhpcy5fZGF0ZXMuY3VycmVudC5tb250aCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9kYXRlcy5jdXJyZW50LnllYXIgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyB0YWJsZSBvZiBzZWxlY3RlZCBtb250aFxuICAgICAgICB0aGlzLl91cGRhdGVUZW1wbGF0ZShbdGhpcy5fZGF0ZXMuY3VycmVudC55ZWFyLCB0aGlzLl9kYXRlcy5jdXJyZW50Lm1vbnRoICsgMSwgJzAxJ10uam9pbignLycpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIGEgbmV4dCBtb250aCBpcyBzaG93bi5cbiAgICAgICAgICogQGV2ZW50IGNoLkNhbGVuZGFyI25leHRtb250aFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJuZXh0bW9udGhcIiBldmVudC5cbiAgICAgICAgICogY2FsZW5kYXIub24oJ25leHRtb250aCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1pdCgnbmV4dG1vbnRoJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gdGhlIHByZXZpb3VzIG1vbnRoLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ2FsZW5kYXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2NhbGVuZGFyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTW92ZXMgdG8gdGhlIHByZXYgbW9udGguXG4gICAgICogY2FsZW5kYXIucHJldk1vbnRoKCk7XG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnByZXZNb250aCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQgfHwgIXRoaXMuX2hhc1ByZXZNb250aCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXZpb3VzIHllYXJcbiAgICAgICAgaWYgKHRoaXMuX2RhdGVzLmN1cnJlbnQubW9udGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGVzLmN1cnJlbnQubW9udGggPSAxMztcbiAgICAgICAgICAgIHRoaXMuX2RhdGVzLmN1cnJlbnQueWVhciAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHRhYmxlIHRvIHRoZSBwcmV2IG1vbnRoXG4gICAgICAgIHRoaXMuX3VwZGF0ZVRlbXBsYXRlKFt0aGlzLl9kYXRlcy5jdXJyZW50LnllYXIsIHRoaXMuX2RhdGVzLmN1cnJlbnQubW9udGggLSAxLCAnMDEnXS5qb2luKCcvJykpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gYSBwcmV2aW91cyBtb250aCBpcyBzaG93bi5cbiAgICAgICAgICogQGV2ZW50IGNoLkNhbGVuZGFyI3ByZXZtb250aFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJwcmV2bW9udGhcIiBldmVudC5cbiAgICAgICAgICogY2FsZW5kYXIub24oJ3ByZXZtb250aCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1pdCgncHJldm1vbnRoJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gdGhlIG5leHQgeWVhci5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNhbGVuZGFyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtjYWxlbmRhcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIE1vdmVzIHRvIHRoZSBuZXh0IHllYXIuXG4gICAgICogY2FsZW5kYXIubmV4dFllYXIoKTtcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUubmV4dFllYXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkIHx8ICF0aGlzLl9oYXNOZXh0TW9udGgoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgdGFibGUgb2Ygc2VsZWN0ZWQgbW9udGhcbiAgICAgICAgdGhpcy5fdXBkYXRlVGVtcGxhdGUoW3RoaXMuX2RhdGVzLmN1cnJlbnQueWVhciArIDEsIHRoaXMuX2RhdGVzLmN1cnJlbnQubW9udGgsICcwMSddLmpvaW4oJy8nKSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBhIG5leHQgeWVhciBpcyBzaG93bi5cbiAgICAgICAgICogQGV2ZW50IGNoLkNhbGVuZGFyI25leHR5ZWFyXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcIm5leHR5ZWFyXCIgZXZlbnQuXG4gICAgICAgICAqIGNhbGVuZGFyLm9uKCduZXh0eWVhcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1pdCgnbmV4dHllYXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZSB0byB0aGUgcHJldmlvdXMgeWVhci5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNhbGVuZGFyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtjYWxlbmRhcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIE1vdmVzIHRvIHRoZSBwcmV2IHllYXIuXG4gICAgICogY2FsZW5kYXIucHJldlllYXIoKTtcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUucHJldlllYXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkIHx8ICF0aGlzLl9oYXNQcmV2TW9udGgoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgdGFibGUgdG8gdGhlIHByZXYgeWVhclxuICAgICAgICB0aGlzLl91cGRhdGVUZW1wbGF0ZShbdGhpcy5fZGF0ZXMuY3VycmVudC55ZWFyIC0gMSwgdGhpcy5fZGF0ZXMuY3VycmVudC5tb250aCwgJzAxJ10uam9pbignLycpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIGEgcHJldmlvdXMgeWVhciBpcyBzaG93bi5cbiAgICAgICAgICogQGV2ZW50IGNoLkNhbGVuZGFyI3ByZXZ5ZWFyXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcInByZXZ5ZWFyXCIgZXZlbnQuXG4gICAgICAgICAqIGNhbGVuZGFyLm9uKCdwcmV2eWVhcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1pdCgncHJldnllYXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgbWluaW11bSBzZWxlY3RhYmxlIGRhdGUuXG4gICAgICogQG1lbWJlcm9mISBjaC5DYWxlbmRhci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0ZSBBIGdpdmVuIGRhdGUgdG8gc2V0IGFzIG1pbmltdW0gc2VsZWN0YWJsZSBkYXRlLiBUaGUgZm9ybWF0IG9mIHRoZSBnaXZlbiBkYXRlIHNob3VsZCBiZSBcIllZWVkvTU0vRERcIi5cbiAgICAgKiBAcmV0dXJucyB7Y2FsZW5kYXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTZXQgYSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS5cbiAgICAgKiBjYWxlbmRhci5zZXRGcm9tKCcyMDEwLzA1LzI4Jyk7XG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnNldEZyb20gPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAvLyB0aGlzIGZyb20gaXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBmb3JtXG4gICAgICAgIHRoaXMuX2RhdGVzLnJhbmdlLmZyb20gPSAoZGF0ZSA9PT0gJ2F1dG8nKSA/IHVuZGVmaW5lZCA6IGNyZWF0ZURhdGVPYmplY3QoZGF0ZSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRlbXBsYXRlKHRoaXMuX2RhdGVzLmN1cnJlbnQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBtYXhpbXVtIHNlbGVjdGFibGUgZGF0ZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNhbGVuZGFyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRlIEEgZ2l2ZW4gZGF0ZSB0byBzZXQgYXMgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuIFRoZSBmb3JtYXQgb2YgdGhlIGdpdmVuIGRhdGUgc2hvdWxkIGJlIFwiWVlZWS9NTS9ERFwiLlxuICAgICAqIEByZXR1cm5zIHtjYWxlbmRhcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNldCBhIG1heGltdW0gc2VsZWN0YWJsZSBkYXRlLlxuICAgICAqIGNhbGVuZGFyLnNldFRvKCcyMDE0LzA1LzI4Jyk7XG4gICAgICovXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnNldFRvID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgLy8gdGhpcyB0byBpcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIHRvXG4gICAgICAgIHRoaXMuX2RhdGVzLnJhbmdlLnRvID0gKGRhdGUgPT09ICdhdXRvJykgPyB1bmRlZmluZWQgOiBjcmVhdGVEYXRlT2JqZWN0KGRhdGUpO1xuICAgICAgICB0aGlzLl91cGRhdGVUZW1wbGF0ZSh0aGlzLl9kYXRlcy5jdXJyZW50KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBDYWxlbmRhciBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNhbGVuZGFyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRGVzdHJveSBhIGNhbGVuZGFyXG4gICAgICogY2FsZW5kYXIuZGVzdHJveSgpO1xuICAgICAqIC8vIEVtcHR5IHRoZSBjYWxlbmRhciByZWZlcmVuY2VcbiAgICAgKiBjYWxlbmRhciA9IHVuZGVmaW5lZDtcbiAgICAgKi9cbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLl9lbC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0aGlzLl9zbmlwcGV0LCB0aGlzLl9lbCk7XG5cbiAgICAgICAgdGlueS50cmlnZ2VyKHdpbmRvdy5kb2N1bWVudCwgY2gub25sYXlvdXRjaGFuZ2UpO1xuXG4gICAgICAgIHBhcmVudC5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICAvLyBGYWN0b3JpemVcbiAgICBjaC5mYWN0b3J5KENhbGVuZGFyLCBub3JtYWxpemVPcHRpb25zKTtcblxufSh0aGlzLCB0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAod2luZG93LCBjaCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIERyb3Bkb3duIHNob3dzIGEgbGlzdCBvZiBvcHRpb25zIGZvciBuYXZpZ2F0aW9uLlxuICAgICAqIEBtZW1iZXJvZiBjaFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhdWdtZW50cyBjaC5MYXllclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEEgSFRNTEVsZW1lbnQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIGNoLkRyb3Bkb3duLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBjdXN0b21pemUgYW4gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFkZENsYXNzXSBDU1MgY2xhc3MgbmFtZXMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjb250YWluZXIgb24gdGhlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZnhdIEVuYWJsZSBvciBkaXNhYmxlIFVJIGVmZmVjdHMuIFlvdSBtdXN0IHVzZTogXCJzbGlkZURvd25cIiwgXCJmYWRlSW5cIiBvciBcIm5vbmVcIi4gRGVmYXVsdDogXCJub25lXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndpZHRoXSBTZXQgYSB3aWR0aCBmb3IgdGhlIGNvbnRhaW5lci4gRGVmYXVsdDogXCJhdXRvXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhlaWdodF0gU2V0IGEgaGVpZ2h0IGZvciB0aGUgY29udGFpbmVyLiBEZWZhdWx0OiBcImF1dG9cIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2hvd25ieV0gRGV0ZXJtaW5lcyBob3cgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgdHJpZ2dlciB0byBzaG93IHRoZSBjb250YWluZXIuIFlvdSBtdXN0IHVzZTogXCJwb2ludGVydGFwXCIsIFwicG9pbnRlcmVudGVyXCIgb3IgXCJub25lXCIuIERlZmF1bHQ6IFwicG9pbnRlcnRhcFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5oaWRkZW5ieV0gRGV0ZXJtaW5lcyBob3cgdG8gaGlkZSB0aGUgY29tcG9uZW50LiBZb3UgbXVzdCB1c2U6IFwiYnV0dG9uXCIsIFwicG9pbnRlcnNcIiwgXCJwb2ludGVybGVhdmVcIiwgXCJhbGxcIiBvciBcIm5vbmVcIi4gRGVmYXVsdDogXCJwb2ludGVyc1wiLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtvcHRpb25zLnJlZmVyZW5jZV0gSXQncyBhIHJlZmVyZW5jZSB0byBwb3NpdGlvbiBhbmQgc2l6ZSBvZiBlbGVtZW50IHRoYXQgd2lsbCBiZSBjb25zaWRlcmVkIHRvIGNhcnJ5IG91dCB0aGUgcG9zaXRpb24uIERlZmF1bHQ6IHRoZSB0cmlnZ2VyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNpZGVdIFRoZSBzaWRlIG9wdGlvbiB3aGVyZSB0aGUgdGFyZ2V0IGVsZW1lbnQgd2lsbCBiZSBwb3NpdGlvbmVkLiBJdHMgdmFsdWUgY2FuIGJlOiBcImxlZnRcIiwgXCJyaWdodFwiLCBcInRvcFwiLCBcImJvdHRvbVwiIG9yIFwiY2VudGVyXCIuIERlZmF1bHQ6IFwiYm90dG9tXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFsaWduXSBUaGUgYWxpZ24gb3B0aW9ucyB3aGVyZSB0aGUgdGFyZ2V0IGVsZW1lbnQgd2lsbCBiZSBwb3NpdGlvbmVkLiBJdHMgdmFsdWUgY2FuIGJlOiBcImxlZnRcIiwgXCJyaWdodFwiLCBcInRvcFwiLCBcImJvdHRvbVwiIG9yIFwiY2VudGVyXCIuIERlZmF1bHQ6IFwibGVmdFwiLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRYXSBUaGUgb2Zmc2V0WCBvcHRpb24gc3BlY2lmaWVzIGEgZGlzdGFuY2UgdG8gZGlzcGxhY2UgdGhlIHRhcmdldCBob3Jpem9udGFsbHkuIERlZmF1bHQ6IDAuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFldIFRoZSBvZmZzZXRZIG9wdGlvbiBzcGVjaWZpZXMgYSBkaXN0YW5jZSB0byBkaXNwbGFjZSB0aGUgdGFyZ2V0IHZlcnRpY2FsbHkuIERlZmF1bHQ6IC0xLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbl0gVGhlIHBvc2l0aW9uIG9wdGlvbiBzcGVjaWZpZXMgdGhlIHR5cGUgb2YgcG9zaXRpb25pbmcgdXNlZC4gSXRzIHZhbHVlIG11c3QgYmUgXCJhYnNvbHV0ZVwiIG9yIFwiZml4ZWRcIi4gRGVmYXVsdDogXCJhYnNvbHV0ZVwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2RdIFRoZSB0eXBlIG9mIHJlcXVlc3QgKFwiUE9TVFwiIG9yIFwiR0VUXCIpIHRvIGxvYWQgY29udGVudCBieSBhamF4LiBEZWZhdWx0OiBcIkdFVFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbXNdIFBhcmFtcyBsaWtlIHF1ZXJ5IHN0cmluZyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYWNoZV0gRm9yY2UgdG8gY2FjaGUgdGhlIHJlcXVlc3QgYnkgdGhlIGJyb3dzZXIuIERlZmF1bHQ6IHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hc3luY10gRm9yY2UgdG8gc2VudCByZXF1ZXN0IGFzeW5jaHJvbm91c2x5LiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IEhUTUxFbGVtZW50KX0gW29wdGlvbnMud2FpdGluZ10gVGVtcG9yYXJ5IGNvbnRlbnQgdG8gdXNlIHdoaWxlIHRoZSBhamF4IHJlcXVlc3QgaXMgbG9hZGluZy4gRGVmYXVsdDogJyZsdDtkaXYgY2xhc3M9XCJjaC1sb2FkaW5nIGNoLWxvYWRpbmctY2VudGVyZWRcIiZndDsmbHQ7L2RpdiZndDsnLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpbl0gU2V0cyBhIENTUyBjbGFzcyBuYW1lIHRvIHRoZSB0cmlnZ2VyIGFuZCBjb250YWluZXIgdG8gZ2V0IGEgdmFyaWF0aW9uIG9mIERyb3Bkb3duLiBEZWZhdWx0OiBmYWxzZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNob3J0Y3V0c10gQ29uZmlndXJlcyBuYXZpZ2F0aW9uIHNob3J0Y3V0cy4gRGVmYXVsdDogdHJ1ZS5cbiAgICAgKiBAcGFyYW0geyhTdHJpbmcgfCBIVE1MRWxlbWVudCl9IFtvcHRpb25zLmNvbnRlbnRdIFRoZSBjb250ZW50IHRvIGJlIHNob3duIGludG8gdGhlIERyb3Bkb3duIGNvbnRhaW5lci5cbiAgICAgKiBAcmV0dXJucyB7ZHJvcGRvd259IFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgRHJvcGRvd24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgRHJvcGRvd24uXG4gICAgICogdmFyIGRyb3Bkb3duID0gbmV3IGNoLkRyb3Bkb3duKFtlbF0sIFtvcHRpb25zXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgc2tpbm5lZCBEcm9wZG93bi5cbiAgICAgKiB2YXIgZHJvcGRvd24gPSBuZXcgY2guRHJvcGRvd24oe1xuICAgICAqICAgICAnc2tpbic6IHRydWVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEcm9wZG93bihlbCwgb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5faW5pdChlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHlvdSBkZWZpbmUgYW4gaW5pdGlhbGl6ZSBtZXRob2QsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhIG5ldyBEcm9wZG93biBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mISBjaC5Ecm9wZG93bi5wcm90b3R5cGVcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZWFkeSB0byB1c2UuXG4gICAgICAgICAqIEBldmVudCBjaC5Ecm9wZG93biNyZWFkeVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJyZWFkeVwiIGV2ZW50LlxuICAgICAgICAgKiBkcm9wZG93bi5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRoYXQuZW1pdCgncmVhZHknKTsgfSwgNTApO1xuICAgIH1cblxuICAgIC8vIEluaGVyaXRhbmNlXG4gICAgdGlueS5pbmhlcml0cyhEcm9wZG93biwgY2guTGF5ZXIpO1xuXG4gICAgdmFyIHBhcmVudCA9IERyb3Bkb3duLnN1cGVyXy5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBtZW1iZXJvZiEgY2guRHJvcGRvd24ucHJvdG90eXBlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBEcm9wZG93bi5wcm90b3R5cGUubmFtZSA9ICdkcm9wZG93bic7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkRyb3Bkb3duLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyb3Bkb3duO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBieSBkZWZhdWx0LlxuICAgICAqIEBtZW1iZXJvZiEgY2guRHJvcGRvd24ucHJvdG90eXBlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5fZGVmYXVsdHMgPSB0aW55LmV4dGVuZCh0aW55LmNsb25lKHBhcmVudC5fZGVmYXVsdHMpLCB7XG4gICAgICAgICdfY2xhc3NOYW1lJzogJ2NoLWRyb3Bkb3duIGNoLWJveC1saXRlJyxcbiAgICAgICAgJ19hcmlhUm9sZSc6ICdjb21ib2JveCcsXG4gICAgICAgICdmeCc6ICdub25lJyxcbiAgICAgICAgJ3Nob3duYnknOiAncG9pbnRlcnRhcCcsXG4gICAgICAgICdoaWRkZW5ieSc6ICdwb2ludGVycycsXG4gICAgICAgICdvZmZzZXRZJzogLTEsXG4gICAgICAgICdza2luJzogZmFsc2UsXG4gICAgICAgICdzaG9ydGN1dHMnOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IGluc3RhbmNlIG9mIERyb3Bkb3duIGFuZCBtZXJnZSBjdXN0b20gb3B0aW9ucyB3aXRoIGRlZmF1bHRzIG9wdGlvbnMuXG4gICAgICogQG1lbWJlcm9mISBjaC5Ecm9wZG93bi5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtkcm9wZG93bn1cbiAgICAgKi9cbiAgICBEcm9wZG93bi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ2FsbCB0byBpdHMgcGFyZW50IGluaXQgbWV0aG9kXG4gICAgICAgIHBhcmVudC5faW5pdC5jYWxsKHRoaXMsIGVsLCBvcHRpb25zKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAvLyBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIEhUTUwgc25pcHBldCAodGhlIGRyb3Bkb3duIGNvbnRlbnQpXG4gICAgICAgICAgICBjb250ZW50ID0gdGlueS5uZXh0KHRoaXMudHJpZ2dlcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkcm9wZG93biB0cmlnZ2VyLiBJdCdzIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBzaG93IGFuZCBoaWRlIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsICdjaC1kcm9wZG93bicgKyB0aGlzLnVpZCArICctc2VsZWN0ZWQnKTtcbiAgICAgICAgdGlueS5hZGRDbGFzcyh0aGlzLnRyaWdnZXIsICdjaC1kcm9wZG93bi10cmlnZ2VyJyk7XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyLnNldEF0dHJpYnV0ZSgndW5zZWxlY3RhYmxlJywgJ29uJyk7XG4gICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy50cmlnZ2VyLCAnY2gtdXNlci1uby1zZWxlY3QnKTtcblxuICAgICAgICAvLyBTa2lubmVkIGRyb3Bkb3duXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNraW4pIHtcbiAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy50cmlnZ2VyLCAnY2gtZHJvcGRvd24tdHJpZ2dlci1za2luJyk7XG4gICAgICAgICAgICB0aW55LmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCAnY2gtZHJvcGRvd24tc2tpbicpO1xuICAgICAgICAvLyBEZWZhdWx0IFNraW5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy50cmlnZ2VyLCAnY2gtYnRuLXNraW4nKTtcbiAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy50cmlnZ2VyLCAnY2gtYnRuLXNtYWxsJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGxpbmtzIHdpdGggdGhlIG5hdmlnYXRpb24gb3B0aW9ucyBvZiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKiBAdHlwZSB7Tm9kZUxpc3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnYScpO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChpdGVtcywgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnb3B0aW9uJyk7XG4gICAgICAgICAgICAgICAgdGlueS5vbihpdGVtLCBjaC5vbnBvaW50ZXJlbnRlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9uYXZpZ2F0aW9uW3RoYXQuX3NlbGVjdGVkID0gaW5kZXhdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfSgpKTtcblxuXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNob3J0Y3V0cyAmJiB0aGlzLl9uYXZpZ2F0aW9uU2hvcnRjdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdmlnYXRpb25TaG9ydGN1dHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29wdGlvbnMuY29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcmlnaW5hbCBhbmQgZW50aXJlIGVsZW1lbnQgYW5kIGl0cyBzdGF0ZSwgYmVmb3JlIGluaXRpYWxpemF0aW9uLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICAvLyBjbG9uZU5vZGUodHJ1ZSkgPiBwYXJhbWV0ZXJzIGlzIHJlcXVpcmVkLiBPcGVyYSAmIElFIHRocm93cyBhbmQgaW50ZXJuYWwgZXJyb3IuIE9wZXJhIG1vYmlsZSBicmVha3MuXG4gICAgICAgIHRoaXMuX3NuaXBwZXQgPSB0aGlzLl9vcHRpb25zLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgZHJvcGRvd24gY29udGFpbmVyLlxuICAgICAqIEBtZW1iZXJvZiEgY2guRHJvcGRvd24ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsoU3RyaW5nIHwgSFRNTEVsZW1lbnQpfSBbY29udGVudF0gVGhlIGNvbnRlbnQgdGhhdCB3aWxsIGJlIHVzZWQgYnkgZHJvcGRvd24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGN1c3RvbSBvcHRpb25zIHRvIGJlIHVzZWQgd2l0aCBjb250ZW50IGxvYWRlZCBieSBhamF4LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2RdIFRoZSB0eXBlIG9mIHJlcXVlc3QgKFwiUE9TVFwiIG9yIFwiR0VUXCIpIHRvIGxvYWQgY29udGVudCBieSBhamF4LiBEZWZhdWx0OiBcIkdFVFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbXNdIFBhcmFtcyBsaWtlIHF1ZXJ5IHN0cmluZyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYWNoZV0gRm9yY2UgdG8gY2FjaGUgdGhlIHJlcXVlc3QgYnkgdGhlIGJyb3dzZXIuIERlZmF1bHQ6IHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hc3luY10gRm9yY2UgdG8gc2VudCByZXF1ZXN0IGFzeW5jaHJvbm91c2x5LiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IEhUTUxFbGVtZW50KX0gW29wdGlvbnMud2FpdGluZ10gVGVtcG9yYXJ5IGNvbnRlbnQgdG8gdXNlIHdoaWxlIHRoZSBhamF4IHJlcXVlc3QgaXMgbG9hZGluZy5cbiAgICAgKiBAcmV0dXJucyB7ZHJvcGRvd259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaG93cyBhIGJhc2ljIGRyb3Bkb3duLlxuICAgICAqIGRyb3Bkb3duLnNob3coKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNob3dzIGEgZHJvcGRvd24gd2l0aCBuZXcgY29udGVudFxuICAgICAqIGRyb3Bkb3duLnNob3coJ1NvbWUgbmV3IGNvbnRlbnQgaGVyZSEnKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNob3dzIGEgZHJvcGRvd24gd2l0aCBhIG5ldyBjb250ZW50IHRoYXQgd2lsbCBiZSBsb2FkZWQgYnkgYWpheCB3aXRoIHNvbWUgY3VzdG9tIG9wdGlvbnNcbiAgICAgKiBkcm9wZG93bi5zaG93KCdodHRwOi8vZG9tYWluLmNvbS9hamF4L3VybCcsIHtcbiAgICAgKiAgICAgJ2NhY2hlJzogZmFsc2UsXG4gICAgICogICAgICdwYXJhbXMnOiAneC1yZXF1ZXN0PXRydWUnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgRHJvcGRvd24ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICAvLyBEb24ndCBleGVjdXRlIHdoZW4gaXQncyBkaXNhYmxlZFxuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhlY3V0ZSB0aGUgb3JpZ2luYWwgc2hvdygpXG4gICAgICAgIHBhcmVudC5zaG93LmNhbGwodGhpcywgY29udGVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSAtMTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBEcm9wZG93biBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkRyb3Bkb3duLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRGVzdHJveSBhIGRyb3Bkb3duXG4gICAgICogZHJvcGRvd24uZGVzdHJveSgpO1xuICAgICAqIC8vIEVtcHR5IHRoZSBkcm9wZG93biByZWZlcmVuY2VcbiAgICAgKiBkcm9wZG93biA9IHVuZGVmaW5lZDtcbiAgICAgKi9cbiAgICBEcm9wZG93bi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyaWdnZXIgPSB0aGlzLnRyaWdnZXI7XG5cbiAgICAgICAgW1xuICAgICAgICAgICAgJ2NoLWRyb3Bkb3duLXRyaWdnZXInLFxuICAgICAgICAgICAgJ2NoLWRyb3Bkb3duLXRyaWdnZXItc2tpbicsXG4gICAgICAgICAgICAnY2gtdXNlci1uby1zZWxlY3QnLFxuICAgICAgICAgICAgJ2NoLWJ0bi1za2luJyxcbiAgICAgICAgICAgICdjaC1idG4tc21hbGwnXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbihjbGFzc05hbWUpe1xuICAgICAgICAgICAgdGlueS5yZW1vdmVDbGFzcyh0cmlnZ2VyLCBjbGFzc05hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0cmlnZ2VyLnJlbW92ZUF0dHJpYnV0ZSgndW5zZWxlY3RhYmxlJyk7XG4gICAgICAgIHRyaWdnZXIucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJyk7XG5cbiAgICAgICAgdHJpZ2dlci5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyZW5kJywgdGhpcy5fc25pcHBldCk7XG5cbiAgICAgICAgdGlueS50cmlnZ2VyKHdpbmRvdy5kb2N1bWVudCwgY2gub25sYXlvdXRjaGFuZ2UpO1xuXG4gICAgICAgIHBhcmVudC5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICBjaC5mYWN0b3J5KERyb3Bkb3duKTtcblxufSh0aGlzLCB0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAoY2gpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBIaWdobGlnaHRzIHRoZSBjdXJyZW50IG9wdGlvbiB3aGVuIG5hdmlnYXRlcyBieSBrZXlib2FyZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNoLkRyb3Bkb3duLnByb3RvdHlwZS5faGlnaGxpZ2h0T3B0aW9uID0gZnVuY3Rpb24gKGtleSkge1xuXG4gICAgICAgIHZhciBvcHRpb25zTGVuZ3RoID0gdGhpcy5fbmF2aWdhdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zaG93bikgeyByZXR1cm47IH1cblxuICAgICAgICAvLyBTZXRzIGxpbWl0cyBiZWhhdmlvclxuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWQgPT09IChrZXkgPT09IGNoLm9ua2V5ZG93bmFycm93ID8gb3B0aW9uc0xlbmd0aCAtIDEgOiAwKSkgeyByZXR1cm47IH1cblxuICAgICAgICAvLyBVbnNlbGVjdHMgY3VycmVudCBvcHRpb25cbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fbmF2aWdhdGlvblt0aGlzLl9zZWxlY3RlZF0uYmx1cigpO1xuICAgICAgICAgICAgdGhpcy5fbmF2aWdhdGlvblt0aGlzLl9zZWxlY3RlZF0ucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSA9PT0gY2gub25rZXlkb3duYXJyb3cpIHsgdGhpcy5fc2VsZWN0ZWQgKz0gMTsgfSBlbHNlIHsgdGhpcy5fc2VsZWN0ZWQgLT0gMTsgfVxuXG4gICAgICAgIC8vIFNlbGVjdHMgbmV3IGN1cnJlbnQgb3B0aW9uXG4gICAgICAgIHRoaXMuX25hdmlnYXRpb25bdGhpcy5fc2VsZWN0ZWRdLmZvY3VzKCk7XG4gICAgICAgIHRoaXMuX25hdmlnYXRpb25bdGhpcy5fc2VsZWN0ZWRdLmlkID0gJ2NoLWRyb3Bkb3duJyArIHRoaXMudWlkICsgJy1zZWxlY3RlZCc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBoYW5kbGVycyB0byBtYW5hZ2UgdGhlIGtleWJvYXJkIG9uIERyb3Bkb3duIG5hdmlnYXRpb24uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjaC5Ecm9wZG93bi5wcm90b3R5cGUuX25hdmlnYXRpb25TaG9ydGN1dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gY29udGV4dCBvZiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICBjaC5zaG9ydGN1dHMuYWRkKGNoLm9ua2V5dXBhcnJvdywgdGhpcy51aWQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB0aGF0Ll9oaWdobGlnaHRPcHRpb24oZXZlbnQuc2hvcnRjdXQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjaC5zaG9ydGN1dHMuYWRkKGNoLm9ua2V5ZG93bmFycm93LCB0aGlzLnVpZCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHRoYXQuX2hpZ2hsaWdodE9wdGlvbihldmVudC5zaG9ydGN1dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMub25jZSgnZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNoLnNob3J0Y3V0cy5yZW1vdmUoY2gub25rZXl1cGFycm93LCB0aGF0LnVpZCk7XG4gICAgICAgICAgICBjaC5zaG9ydGN1dHMucmVtb3ZlKGNoLm9ua2V5ZG93bmFycm93LCB0aGF0LnVpZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbn0odGhpcy5jaCkpO1xuXG4oZnVuY3Rpb24gKHdpbmRvdywgY2gpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBUYWJzIGxldHMgeW91IGNyZWF0ZSB0YWJzIGZvciBzdGF0aWMgYW5kIGR5bmFtaWMgY29udGVudC5cbiAgICAgKiBAbWVtYmVyb2YgY2hcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgY2guQ29tcG9uZW50XG4gICAgICogQHJlcXVpcmVzIGNoLkV4cGFuZGFibGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBBIEhUTUxFbGVtZW50IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBjaC5UYWJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBjdXN0b21pemUgYW4gaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge3RhYnN9IFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgVGFicy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBUYWJzLlxuICAgICAqIHZhciB0YWJzID0gbmV3IGNoLlRhYnMoZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRhYnMoZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5faW5pdChlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHlvdSBkZWZpbmUgYW4gaW5pdGlhbGl6ZSBtZXRob2QsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhIG5ldyBUYWJzIGlzIGNyZWF0ZWQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YhIGNoLlRhYnMucHJvdG90eXBlXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgdGhlIGV2ZW50ICdyZWFkeScgd2hlbiB0aGUgY29tcG9uZW50IGlzIHJlYWR5IHRvIHVzZS5cbiAgICAgICAgICogQGV2ZW50IGNoLlRhYnMjcmVhZHlcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwicmVhZHlcIiBldmVudC5cbiAgICAgICAgICogdGFicy5vbigncmVhZHknLGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhhdC5lbWl0KCdyZWFkeScpOyB9LCA1MCk7XG4gICAgfVxuXG4gICAgLy8gSW5oZXJpdGFuY2VcbiAgICB0aW55LmluaGVyaXRzKFRhYnMsIGNoLkNvbXBvbmVudCk7XG5cbiAgICAvLyBJbmhlcml0YW5jZVxuICAgIHZhciBwYXJlbnQgPSBUYWJzLnN1cGVyXy5wcm90b3R5cGUsXG5cbiAgICAgICAgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG5cbiAgICAgICAgLy8gQ3JlYXRlcyBtZXRob2RzIGVuYWJsZSBhbmQgZGlzYWJsZSBpbnRvIHRoZSBwcm90b3R5cGUuXG4gICAgICAgIG1ldGhvZHMgPSBbJ2VuYWJsZScsICdkaXNhYmxlJ10sXG4gICAgICAgIGxlbiA9IG1ldGhvZHMubGVuZ3RoLFxuXG4gICAgICAgIC8vIFJlZ3VsYXIgZXhwcmVzaW9uIHRvIGdldCBoYXNoXG4gICAgICAgIGhhc2hSZWdFeHAgPSBuZXcgUmVnRXhwKCdcXFxcIyE/XFxcXC8/KC5bXlxcXFw/fFxcXFwmfFxcXFxzXSspJyk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVNZXRob2RzKG1ldGhvZCkge1xuICAgICAgICBUYWJzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKHRhYikge1xuICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgIC8vIEVuYWJsZXMgb3IgZGlzYWJsZXMgYW4gc3BlY2lmYyB0YWIgcGFuZWxcbiAgICAgICAgICAgIGlmICh0YWIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFicGFuZWxzW3RhYiAtIDFdW21ldGhvZF0oKTtcblxuICAgICAgICAgICAgLy8gRW5hYmxlcyBvciBkaXNhYmxlcyBUYWJzXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaSA9IHRoaXMudGFicGFuZWxzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFicGFuZWxzW2kgLT0gMV1bbWV0aG9kXSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGVzIHBhcmVudCBtZXRob2RcbiAgICAgICAgICAgICAgICBwYXJlbnRbbWV0aG9kXS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlcyBcImFyaWEtZGlzYWJsZWRcIiBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICB0aGlzLl9lbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAhdGhpcy5fZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQG1lbWJlcm9mISBjaC5UYWJzLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBZb3UgY2FuIHJlYWNoIHRoZSBhc3NvY2lhdGVkIGluc3RhbmNlLlxuICAgICAqIHZhciB0YWJzID0gJChzZWxlY3RvcikuZGF0YSgndGFicycpO1xuICAgICAqL1xuICAgIFRhYnMucHJvdG90eXBlLm5hbWUgPSAndGFicyc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlRhYnMucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgVGFicy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUYWJzO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBpbnN0YW5jZSBvZiBUYWJzIGFuZCBtZXJnZSBjdXN0b20gb3B0aW9ucyB3aXRoIGRlZmF1bHRzIG9wdGlvbnMuXG4gICAgICogQG1lbWJlcm9mISBjaC5UYWJzLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3RhYnN9XG4gICAgICovXG4gICAgVGFicy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgcGFyZW50Ll9pbml0LmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gY29udGV4dCBvZiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgKiBUaGUgYWN0dWFsIGxvY2F0aW9uIGhhc2gsIGlzIHVzZWQgdG8ga25vdyBpZiB0aGVyZSdzIGEgc3BlY2lmaWMgdGFiIHBhbmVsIHNod293bi5cbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX2N1cnJlbnRIYXNoID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaC5tYXRjaChoYXNoUmVnRXhwKTtcbiAgICAgICAgICAgIHJldHVybiAoaGFzaCAhPT0gbnVsbCkgPyBoYXNoWzFdIDogJyc7XG4gICAgICAgIH0oKSk7XG5cbiAgICAgICAgLy8gY2xvbmVOb2RlKHRydWUpID4gcGFyYW1ldGVycyBpcyByZXF1aXJlZC4gT3BlcmEgJiBJRSB0aHJvd3MgYW5kIGludGVybmFsIGVycm9yLiBPcGVyYSBtb2JpbGUgYnJlYWtzLlxuICAgICAgICB0aGlzLl9zbmlwcGV0ID0gdGhpcy5fZWwuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFicyBjb250YWluZXIuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5fZWw7XG4gICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsICdjaC10YWJzJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0YWJzIHRyaWdnZXJzLlxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXJzID0gdGhpcy5jb250YWluZXIuY2hpbGRyZW5bMF07XG4gICAgICAgIHRoaXMudHJpZ2dlcnMuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RhYmxpc3QnKTtcbiAgICAgICAgdGlueS5hZGRDbGFzcyh0aGlzLnRyaWdnZXJzLCAnY2gtdGFicy10cmlnZ2VycycpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNvbGxlY3Rpb24gb2YgdGFiIHBhbmVsLlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYnBhbmVscyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29udGFpbmVyIG9mIHRhYiBwYW5lbHMuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFuZWwgPSB0aGlzLmNvbnRhaW5lci5jaGlsZHJlblsxXTtcbiAgICAgICAgdGhpcy5wYW5lbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XG4gICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy5wYW5lbCwgJ2NoLXRhYnMtcGFuZWwnKTtcbiAgICAgICAgdGlueS5hZGRDbGFzcyh0aGlzLnBhbmVsLCAnY2gtYm94LWxpdGUnKTtcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFiIHBhbmVsJ3MgY29udGFpbmVycy5cbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGFic1BhbmVscyA9IHRoaXMucGFuZWwuY2hpbGRyZW47XG5cbiAgICAgICAgLy8gQ3JlYXRlcyB0YWJcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCh0aGlzLnRyaWdnZXJzLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJyksIGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoYXQuX2NyZWF0ZVRhYihpbmRleCwgZWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTZXQgdGhlIGRlZmF1bHQgc2hvd24gdGFiLlxuICAgICAgICB0aGlzLl9zaG93biA9IDE7XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSB1cmwgaGFzIGEgaGFzaCB0byBzaG93biB0aGUgYXNzb2NpYXRlZCB0YWIuXG4gICAgICAgIHRoaXMuX2hhc0hhc2goKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRhYiBwYW5lbHMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUYWJzLnByb3RvdHlwZS5fY3JlYXRlVGFiID0gZnVuY3Rpb24gKGksIGUpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICB0YWIsXG5cbiAgICAgICAgICAgIHBhbmVsID0gdGhpcy5fdGFic1BhbmVsc1tpXSxcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIFRhYiBwYW5lbCdzIG9wdGlvbnNcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgJ19jbGFzc05hbWVJY29uJzogbnVsbCxcbiAgICAgICAgICAgICAgICAnX2NsYXNzTmFtZVRyaWdnZXInOiAnY2gtdGFiJyxcbiAgICAgICAgICAgICAgICAnX2NsYXNzTmFtZUNvbnRhaW5lcic6ICdjaC10YWJwYW5lbCcsXG4gICAgICAgICAgICAgICAgJ3RvZ2dsZSc6IGZhbHNlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRhYiBwYW5lbCBhc3luYyBjb25maWd1cmF0aW9uXG4gICAgICAgIGlmIChwYW5lbCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIHBhbmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBwYW5lbC5zZXRBdHRyaWJ1dGUoJ2lkJywgZS5ocmVmLnNwbGl0KCcjJylbMV0pO1xuXG4gICAgICAgICAgICB0aGlzLnBhbmVsLmFwcGVuZENoaWxkKHBhbmVsKTtcblxuICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50ID0gZS5ocmVmO1xuICAgICAgICAgICAgb3B0aW9ucy53YWl0aW5nID0gdGhpcy5fb3B0aW9ucy53YWl0aW5nO1xuICAgICAgICAgICAgb3B0aW9ucy5jYWNoZSA9IHRoaXMuX29wdGlvbnMuY2FjaGU7XG4gICAgICAgICAgICBvcHRpb25zLm1ldGhvZCA9IHRoaXMuX29wdGlvbnMubWV0aG9kO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGFiIHBhbmVsIGNvbnRhaW5lciBjb25maWd1cmF0aW9uXG4gICAgICAgIG9wdGlvbnMuY29udGFpbmVyID0gcGFuZWw7XG5cbiAgICAgICAgLy8gQ3JlYXRlcyBuZXcgVGFiIHBhbmVsXG4gICAgICAgIHRhYiA9IG5ldyBjaC5FeHBhbmRhYmxlKGUsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIENyZWF0ZXMgdGFiJ3MgaGFzaFxuICAgICAgICB0YWIuX2hhc2ggPSBlLmhyZWYuc3BsaXQoJyMnKVsxXTtcblxuICAgICAgICAvLyBBZGQgQVJJQSByb2xlc1xuICAgICAgICB0YWIudHJpZ2dlci5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndGFiJyk7XG4gICAgICAgIHRhYi5jb250YWluZXIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RhYnBhbmVsJyk7XG5cbiAgICAgICAgLy8gQmluZHMgc2hvdyBldmVudFxuICAgICAgICB0YWIub24oJ3Nob3cnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Ll91cGRhdGVTaG93bihpICsgMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZHMgdGFiIHBhbmVsIHRvIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgIHRoaXMudGFicGFuZWxzLnB1c2godGFiKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSB1cmwgaGFzIGEgaGFzaCB0byBzaG93biB0aGUgYXNzb2NpYXRlZCB0YWIgcGFuZWwuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUYWJzLnByb3RvdHlwZS5faGFzSGFzaCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIGEgdGFiIGhpZGUgYSB0YWIgcGFuZWwgY29udGFpbmVyLlxuICAgICAgICAgKiBAZXZlbnQgY2guVGFicyNoaWRlXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcImhpZGVcIiBldmVudC5cbiAgICAgICAgICogdGFicy5vbignaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1pdCgnaGlkZScsIHRoaXMuX3Nob3duKTtcblxuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICAvLyBTaG93cyB0aGUgZmlyc3QgdGFiIHBhbmVsIGlmIG5vdCBoYXNoIG9yIGl0J3MgaGFzaCBhbmQgaXQgaXNuJ3QgZnJvbSB0aGUgY3VycmVudCB0YWIgcGFuZWwsXG4gICAgICAgICAgICBsID0gdGhpcy50YWJwYW5lbHMubGVuZ3RoO1xuXG4gICAgICAgIC8vIElmIGhhc2ggb3BlbiB0aGF0IHRhYiBwYW5lbFxuICAgICAgICBmb3IgKGk7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhYnBhbmVsc1tpXS5faGFzaCA9PT0gdGhpcy5fY3VycmVudEhhc2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG93biA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50YWJwYW5lbHNbdGhpcy5fc2hvd24gLSAxXS5zaG93KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdGFicyBzaG93cyBhIHRhYiBwYW5lbCBjb250YWluZXIuXG4gICAgICAgICAqIEBldmVudCBjaC5UYWJzI3Nob3dcbiAgICAgICAgICogQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWl0KCdzaG93JywgdGhpcy5fc2hvd24pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIHNwZWNpZmljIHRhYiBwYW5lbC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlRhYnMucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRhYiAtIEEgZ2l2ZW4gbnVtYmVyIG9mIHRhYiBwYW5lbC5cbiAgICAgKiBAcmV0dXJucyB7dGFic31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNob3dzIHRoZSBzZWNvbmQgdGFiIHBhbmVsLlxuICAgICAqIHRhYnMuc2hvdygyKTtcbiAgICAgKi9cbiAgICBUYWJzLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKHRhYikge1xuXG4gICAgICAgIC8vIFNob3dzIHRoZSBjdXJyZW50IHRhYlxuICAgICAgICB0aGlzLnRhYnBhbmVsc1t0YWIgLSAxXS5zaG93KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHNob3duIHRhYiBwYW5lbCwgaGlkZXMgdGhlIHByZXZpb3VzIHRhYiBwYW5lbCwgY2hhbmdlcyB3aW5kb3cgbG9jYXRpb24gYW5kIGVtaXRzIFwic2hvd1wiIGV2ZW50LlxuICAgICAqIEBtZW1iZXJvZiEgY2guVGFicy5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0YWIgLSBBIGdpdmVuIG51bWJlciBvZiB0YWIgcGFuZWwuXG4gICAgICovXG4gICAgVGFicy5wcm90b3R5cGUuX3VwZGF0ZVNob3duID0gZnVuY3Rpb24gKHRhYikge1xuXG4gICAgICAgIC8vIElmIHRhYiBkb2Vzbid0IGV4aXN0IG9yIGlmIGl0J3Mgc2hvd24gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5fc2hvd24gPT09IHRhYikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIGEgdGFiIGhpZGUgYSB0YWIgcGFuZWwgY29udGFpbmVyLlxuICAgICAgICAgKiBAZXZlbnQgY2guVGFicyNoaWRlXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcImhpZGVcIiBldmVudC5cbiAgICAgICAgICogdGFicy5vbignaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1pdCgnaGlkZScsIHRoaXMuX3Nob3duKTtcblxuICAgICAgICAvLyBIaWRlcyB0aGUgc2hvd24gdGFiXG4gICAgICAgIHRoaXMudGFicGFuZWxzW3RoaXMuX3Nob3duIC0gMV0uaGlkZSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgd2ljaCB0YWIgcGFuZWwgaXMgc2hvd24uXG4gICAgICAgICAqIEBuYW1lIGNoLlRhYnMjX3Nob3duXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zaG93biA9IHRhYjtcblxuICAgICAgICAvLyBVcGRhdGUgd2luZG93IGxvY2F0aW9uIGhhc2hcbiAgICAgICAgbG9jYXRpb24uaGFzaCA9IHRoaXMuX2N1cnJlbnRIYXNoID0gKHRoaXMuX2N1cnJlbnRIYXNoID09PSAnJylcbiAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGhhc2ggaXMgZW1wdHksIGNyZWF0ZSBpdC5cbiAgICAgICAgICAgID8gJyMhLycgKyB0aGlzLnRhYnBhbmVsc1t0aGlzLl9zaG93biAtIDFdLl9oYXNoXG4gICAgICAgICAgICAvLyB1cGRhdGUgb25seSB0aGUgcHJldmlvdXMgaGFzaFxuICAgICAgICAgICAgOiBsb2NhdGlvbi5oYXNoLnJlcGxhY2UobG9jYXRpb24uaGFzaC5tYXRjaChoYXNoUmVnRXhwKVsxXSwgdGhpcy50YWJwYW5lbHNbdGhpcy5fc2hvd24gLSAxXS5faGFzaCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdGFicyBzaG93cyBhIHRhYiBwYW5lbCBjb250YWluZXIuXG4gICAgICAgICAqIEBldmVudCBjaC5UYWJzI3Nob3dcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwic2hvd1wiIGV2ZW50LlxuICAgICAgICAgKiB0YWJzLm9uKCdzaG93JywgZnVuY3Rpb24gKHNob3duVGFiKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoJ3Nob3cnLCB0aGlzLl9zaG93bik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0aGUgc2hvd24gdGFiIHBhbmVsLlxuICAgICAqIEBtZW1iZXJvZiEgY2guVGFicy5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlmICh0YWJzLmdldFNob3duKCkgPT09IDEpIHtcbiAgICAgKiAgICAgZm4oKTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgVGFicy5wcm90b3R5cGUuZ2V0U2hvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93bjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRvIG1hbmFnZSB0aGUgdGFicyBjb250ZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0YWIgQSBnaXZlbiB0YWIgdG8gY2hhbmdlIGl0cyBjb250ZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRlbnQgVGhlIGNvbnRlbnQgdGhhdCB3aWxsIGJlIHVzZWQgYnkgYSB0YWJwYW5lbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgY3VzdG9tIG9wdGlvbnMgdG8gYmUgdXNlZCB3aXRoIGNvbnRlbnQgbG9hZGVkIGJ5IGFqYXguXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1ldGhvZF0gVGhlIHR5cGUgb2YgcmVxdWVzdCAoXCJQT1NUXCIgb3IgXCJHRVRcIikgdG8gbG9hZCBjb250ZW50IGJ5IGFqYXguIERlZmF1bHQ6IFwiR0VUXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhcmFtc10gUGFyYW1zIGxpa2UgcXVlcnkgc3RyaW5nIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNhY2hlXSBGb3JjZSB0byBjYWNoZSB0aGUgcmVxdWVzdCBieSB0aGUgYnJvd3Nlci4gRGVmYXVsdDogdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFzeW5jXSBGb3JjZSB0byBzZW50IHJlcXVlc3QgYXN5bmNocm9ub3VzbHkuIERlZmF1bHQ6IHRydWUuXG4gICAgICogQHBhcmFtIHsoU3RyaW5nIHwgSFRNTEVsZW1lbnQpfSBbb3B0aW9ucy53YWl0aW5nXSBUZW1wb3JhcnkgY29udGVudCB0byB1c2Ugd2hpbGUgdGhlIGFqYXggcmVxdWVzdCBpcyBsb2FkaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gVXBkYXRlcyB0aGUgY29udGVudCBvZiB0aGUgc2Vjb25kIHRhYiB3aXRoIHNvbWUgc3RyaW5nLlxuICAgICAqIHRhYnMuY29udGVudCgyLCAnaHR0cDovL2FqYXguY29tJywgeydjYWNoZSc6IGZhbHNlfSk7XG4gICAgICovXG4gICAgVGFicy5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uICh0YWIsIGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRhYiA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0YWIgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgd2luZG93LkVycm9yKCdUYWJzLmNvbnRlbnQodGFiLCBjb250ZW50LCBvcHRpb25zKTogRXhwZWN0ZWQgYSBudW1iZXIgb2YgdGFiLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFiW3RhYiAtIDFdLmNvbnRlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGFicGFuZWxzW3RhYiAtIDFdLmNvbnRlbnQoY29udGVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgYW4gaW5zdGFuY2Ugb2YgVGFicyBvciBhIHNwZWNpZmljIHRhYiBwYW5lbC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlRhYnMucHJvdG90eXBlXG4gICAgICogQG5hbWUgZW5hYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0YWJdIC0gQSBnaXZlbiBudW1iZXIgb2YgdGFiIHBhbmVsIHRvIGVuYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7dGFic30gUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBUYWJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRW5hYmxpbmcgYW4gaW5zdGFuY2Ugb2YgVGFicy5cbiAgICAgKiB0YWJzLmVuYWJsZSgpO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRW5hYmxpbmcgdGhlIHNlY29uZCB0YWIgcGFuZWwgb2YgYSB0YWJzLlxuICAgICAqIHRhYnMuZW5hYmxlKDIpO1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgYW4gaW5zdGFuY2Ugb2YgVGFicyBvciBhIHNwZWNpZmljIHRhYiBwYW5lbC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLlRhYnMucHJvdG90eXBlXG4gICAgICogQG5hbWUgZGlzYWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGFiXSAtIEEgZ2l2ZW4gbnVtYmVyIG9mIHRhYiBwYW5lbCB0byBkaXNhYmxlLlxuICAgICAqIEByZXR1cm5zIHt0YWJzfSBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIFRhYnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBEaXNhYmxpbmcgYW4gaW5zdGFuY2Ugb2YgVGFicy5cbiAgICAgKiB0YWJzLmRpc2FibGUoKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIERpc2FibGluZyB0aGUgc2Vjb25kIHRhYiBwYW5lbC5cbiAgICAgKiB0YWJzLmRpc2FibGUoMik7XG4gICAgICovXG4gICAgd2hpbGUgKGxlbikge1xuICAgICAgICBjcmVhdGVNZXRob2RzKG1ldGhvZHNbbGVuIC09IDFdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhIFRhYnMgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlcm9mISBjaC5UYWJzLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRGVzdHJveWluZyBhbiBpbnN0YW5jZSBvZiBUYWJzLlxuICAgICAqIHRhYnMuZGVzdHJveSgpO1xuICAgICAqL1xuICAgIFRhYnMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5fZWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5fc25pcHBldCwgdGhpcy5fZWwpO1xuXG4gICAgICAgIHRpbnkudHJpZ2dlcih3aW5kb3cuZG9jdW1lbnQsIGNoLm9ubGF5b3V0Y2hhbmdlKTtcblxuICAgICAgICBwYXJlbnQuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGYWN0b3J5XG4gICAgICovXG4gICAgY2guZmFjdG9yeShUYWJzKTtcblxufSh0aGlzLCB0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAod2luZG93LCBjaCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEEgbGFyZ2UgbGlzdCBvZiBlbGVtZW50cy4gU29tZSBlbGVtZW50cyB3aWxsIGJlIHNob3duIGluIGEgcHJlc2V0IGFyZWEsIGFuZCBvdGhlcnMgd2lsbCBiZSBoaWRkZW4gd2FpdGluZyBmb3IgdGhlIHVzZXIgaW50ZXJhY3Rpb24gdG8gc2hvdyBpdC5cbiAgICAgKiBAbWVtYmVyb2YgY2hcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBBIEhUTUxFbGVtZW50IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBjaC5DYXJvdXNlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gY3VzdG9taXplIGFuIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hc3luY10gRGVmaW5lcyB0aGUgbnVtYmVyIG9mIGZ1dHVyZSBhc3luY2hyb25vdXMgaXRlbXMgdG8gYWRkIHRvIHRoZSBjb21wb25lbnQuIERlZmF1bHQ6IDAuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hcnJvd3NdIERlZmluZXMgaWYgdGhlIGFycm93LWJ1dHRvbnMgbXVzdCBiZSBjcmVhdGVkIG9yIG5vdCBhdCBpbml0aWFsaXphdGlvbi4gRGVmYXVsdDogdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBhZ2luYXRpb25dIERlZmluZXMgaWYgYSBwYWdpbmF0aW9uIG11c3QgYmUgY3JlYXRlZCBvciBub3QgYXQgaW5pdGlhbGl6YXRpb24uIERlZmF1bHQ6IGZhbHNlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZnhdIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBzbGlkZSBlZmZlY3QuIERlZmF1bHQ6IHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvSGVpZ2h0XSBFbmFibGUgb3IgZGlzYWJsZSB0aGUgcmVjYWxjdWxhdGlvbiBvZiBpdGVtIGhlaWdodCBvbiBhIHByb3BvcnRpb25hbCBiYXNpcyBtYWludGFpbmluZyB0aGUgcHJvcG9ydGlvbnMgb2YgYW4gaXRlbS4gRGVmYXVsdDogdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9NYXJnaW5dIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBhZGRpdGlvbiBvZiBhIHByb3BvcnRpb25hbCBtYXJnaW4gdG8gZWFjaCBpdGVtLiBEZWZhdWx0OiB0cnVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5saW1pdFBlclBhZ2VdIFNldCB0aGUgbWF4aW11bSBhbW91bnQgb2YgaXRlbXMgdG8gc2hvdyBpbiBlYWNoIHBhZ2UuXG4gICAgICogQHJldHVybnMge2Nhcm91c2VsfSBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIENhcm91c2VsLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IGNhcm91c2VsLlxuICAgICAqIHZhciBjYXJvdXNlbCA9IG5ldyBjaC5DYXJvdXNlbChlbCwgW29wdGlvbnNdKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBDYXJvdXNlbCB3aXRoIGRpc2FibGVkIGVmZmVjdHMuXG4gICAgICogdmFyIGNhcm91c2VsID0gbmV3IGNoLkNhcm91c2VsKGVsLCB7XG4gICAgICogICAgICdmeCc6IGZhbHNlXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgQ2Fyb3VzZWwgd2l0aCBpdGVtcyBhc3luY2hyb25vdXNseSBsb2FkZWQuXG4gICAgICogdmFyIGNhcm91c2VsID0gbmV3IGNoLkNhcm91c2VsKGVsLCB7XG4gICAgICogICAgICdhc3luYyc6IDEwXG4gICAgICogfSkub24oJ2l0ZW1zYWRkJywgZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgKiAgICAgLy8gSW5qZWN0IGNvbnRlbnQgaW50byB0aGUgYWRkZWQgPGxpPiBlbGVtZW50c1xuICAgICAqICAgICAkLmVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgKiAgICAgICAgIGUuaW5uZXJIVE1MID0gJ0NvbnRlbnQgaW50byBvbmUgb2YgbmV3bHkgaW5zZXJ0ZWQgPGxpPiBlbGVtZW50cy4nO1xuICAgICAqICAgICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDYXJvdXNlbChlbCwgb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5faW5pdChlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHlvdSBkZWZpbmUgYW4gaW5pdGlhbGl6ZSBtZXRob2QsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhIG5ldyBDYXJvdXNlbCBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mISBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZWFkeSB0byB1c2UuXG4gICAgICAgICAqIEBldmVudCBjaC5DYXJvdXNlbCNyZWFkeVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJyZWFkeVwiIGV2ZW50LlxuICAgICAgICAgKiBjYXJvdXNlbC5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRoYXQuZW1pdCgncmVhZHknKTsgfSwgNTApO1xuICAgIH1cblxuICAgIC8vIEluaGVyaXRhbmNlXG4gICAgdGlueS5pbmhlcml0cyhDYXJvdXNlbCwgY2guQ29tcG9uZW50KTtcblxuICAgIHZhciBwb2ludGVydGFwID0gY2gub25wb2ludGVydGFwLFxuICAgICAgICBNYXRoID0gd2luZG93Lk1hdGgsXG4gICAgICAgIHNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCxcbiAgICAgICAgcGFyZW50ID0gQ2Fyb3VzZWwuc3VwZXJfLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgdmVuZG9yIHByZWZpeCBvZiB0aGUgY3VycmVudCBicm93c2VyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBsaW5rIGh0dHA6Ly9sZWEudmVyb3UubWUvMjAwOS8wMi9maW5kLXRoZS12ZW5kb3ItcHJlZml4LW9mLXRoZS1jdXJyZW50LWJyb3dzZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFZFTkRPUl9QUkVGSVggPT09ICd3ZWJraXQnO1xuICAgICAqL1xuICAgIHZhciBWRU5ET1JfUFJFRklYID0gKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgcmVnZXggPSAvXihXZWJraXR8S2h0bWx8TW96fG1zfE8pKD89W0EtWl0pLyxcbiAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF0uc3R5bGUsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBzdHlsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAocmVnZXgudGVzdChwcm9wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wLm1hdGNoKHJlZ2V4KVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90aGluZyBmb3VuZCBzbyBmYXI/IFdlYmtpdCBkb2VzIG5vdCBlbnVtZXJhdGUgb3ZlciB0aGUgQ1NTIHByb3BlcnRpZXMgb2YgdGhlIHN0eWxlIG9iamVjdC5cbiAgICAgICAgLy8gSG93ZXZlciAocHJvcCBpbiBzdHlsZSkgcmV0dXJucyB0aGUgY29ycmVjdCB2YWx1ZSwgc28gd2UnbGwgaGF2ZSB0byB0ZXN0IGZvclxuICAgICAgICAvLyB0aGUgcHJlY2VuY2Ugb2YgYSBzcGVjaWZpYyBwcm9wZXJ0eVxuICAgICAgICBpZiAoJ1dlYmtpdE9wYWNpdHknIGluIHN0eWxlRGVjbGFyYXRpb24pIHsgcmV0dXJuICd3ZWJraXQnOyB9XG4gICAgICAgIGlmICgnS2h0bWxPcGFjaXR5JyBpbiBzdHlsZURlY2xhcmF0aW9uKSB7IHJldHVybiAna2h0bWwnOyB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ2Fyb3VzZWwucHJvdG90eXBlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUubmFtZSA9ICdjYXJvdXNlbCc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNhcm91c2VsLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhcm91c2VsO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBieSBkZWZhdWx0LlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ2Fyb3VzZWwucHJvdG90eXBlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5fZGVmYXVsdHMgPSB7XG4gICAgICAgICdhc3luYyc6IDAsXG4gICAgICAgICdhcnJvd3MnOiB0cnVlLFxuICAgICAgICAncGFnaW5hdGlvbic6IGZhbHNlLFxuICAgICAgICAnZngnOiB0cnVlLFxuICAgICAgICAnYXV0b0hlaWdodCc6IHRydWUsXG4gICAgICAgICdhdXRvTWFyZ2luJzogdHJ1ZVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IGluc3RhbmNlIG9mIENhcm91c2VsIGFuZCBtZXJnZSBjdXN0b20gb3B0aW9ucyB3aXRoIGRlZmF1bHRzIG9wdGlvbnMuXG4gICAgICogQG1lbWJlcm9mISBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtjYXJvdXNlbH1cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ2FsbCB0byBpdHMgcGFyZW50cyBpbml0IG1ldGhvZFxuICAgICAgICBwYXJlbnQuX2luaXQuY2FsbCh0aGlzLCBlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3JpZ2luYWwgYW5kIGVudGlyZSBlbGVtZW50IGFuZCBpdHMgc3RhdGUsIGJlZm9yZSBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICogQHR5cGUge0hUTUxEaXZFbGVtZW50fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gY2xvbmVOb2RlKHRydWUpID4gcGFyYW1ldGVycyBpcyByZXF1aXJlZC4gT3BlcmEgJiBJRSB0aHJvd3MgYW5kIGludGVybmFsIGVycm9yLiBPcGVyYSBtb2JpbGUgYnJlYWtzLlxuICAgICAgICB0aGlzLl9zbmlwcGV0ID0gdGhpcy5fZWwuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbGVtZW50IHRoYXQgbW92ZXMgKHNsaWRlcykgYWNyb3NzIHRoZSBjb21wb25lbnQgKGluc2lkZSB0aGUgbWFzaykuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xpc3QgPSB0aGlzLl9lbC5jaGlsZHJlblswXTtcblxuICAgICAgICB0aW55LmFkZENsYXNzKHRoaXMuX2VsLCAnY2gtY2Fyb3VzZWwnKTtcbiAgICAgICAgdGlueS5hZGRDbGFzcyh0aGlzLl9saXN0LCAnY2gtY2Fyb3VzZWwtbGlzdCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGVhY2ggY2hpbGQgb2YgdGhlIHNsaWRlciBsaXN0LlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7SFRNTENvbGxlY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pdGVtcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IHRoYXQuX2xpc3QucXVlcnlTZWxlY3RvckFsbCgnbGknKTtcblxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChjb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3MoaXRlbSwgJ2NoLWNhcm91c2VsLWl0ZW0nKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfSgpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRWxlbWVudCB0aGF0IHdyYXBzIHRoZSBsaXN0IGFuZCBkZW5pZXMgaXRzIG92ZXJmbG93LlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX21hc2suc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RhYnBhbmVsJyk7XG4gICAgICAgIHRoaXMuX21hc2suc2V0QXR0cmlidXRlKCdjbGFzcycsJ2NoLWNhcm91c2VsLW1hc2snKTtcbiAgICAgICAgdGhpcy5fbWFzay5hcHBlbmRDaGlsZCh0aGlzLl9saXN0KTtcblxuICAgICAgICB0aGlzLl9lbC5hcHBlbmRDaGlsZCh0aGlzLl9tYXNrKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2l6ZSBvZiB0aGUgbWFzayAod2lkdGgpLiBVcGRhdGVkIGluIGVhY2ggcmVmcmVzaC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hc2tXaWR0aCA9IHRoaXMuX2dldE91dGVyRGltZW5zaW9ucyh0aGlzLl9tYXNrKS53aWR0aDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIG9mIGVhY2ggaXRlbSwgaW5jbHVkaW5nIHBhZGRpbmdzLCBtYXJnaW5zIGFuZCBib3JkZXJzLiBJZGVhbCBmb3IgbWFrZSBjYWxjdWxhdGlvbnMuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pdGVtV2lkdGggPSB0aGlzLl9nZXRPdXRlckRpbWVuc2lvbnModGhpcy5faXRlbXNbMF0pLndpZHRoO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggb2YgZWFjaCBpdGVtLCB3aXRob3V0IHBhZGRpbmdzLCBtYXJnaW5zIG9yIGJvcmRlcnMuIElkZWFsIGZvciBtYW5pcHVsYXRlIENTUyB3aWR0aCBwcm9wZXJ0eS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2l0ZW1PdXRlcldpZHRoID0gcGFyc2VJbnQodGlueS5jc3ModGhpcy5faXRlbXNbMF0sICd3aWR0aCcpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpemUgYWRkZWQgdG8gZWFjaCBpdGVtIHRvIG1ha2UgaXQgZWxhc3RpYy9yZXNwb25zaXZlLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXRlbUV4dHJhV2lkdGggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIGVhY2ggaXRlbSwgaW5jbHVkaW5nIHBhZGRpbmdzLCBtYXJnaW5zIGFuZCBib3JkZXJzLiBJZGVhbCBmb3IgbWFrZSBjYWxjdWxhdGlvbnMuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pdGVtSGVpZ2h0ID0gdGhpcy5fZ2V0T3V0ZXJEaW1lbnNpb25zKHRoaXMuX2l0ZW1zWzBdKS5oZWlnaHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXJnaW4gb2YgYWxsIGl0ZW1zLiBVcGRhdGVkIGluIGVhY2ggcmVmcmVzaCBvbmx5IGlmIGl0J3MgbmVjZXNzYXJ5LlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXRlbU1hcmdpbiA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgdG8gY29udHJvbCB3aGVuIGFycm93cyB3ZXJlIGNyZWF0ZWQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXJyb3dzQ3JlYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIHRvIGNvbnRyb2wgd2hlbiBwYWdpbmF0aW9uIHdhcyBjcmVhdGVkLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3BhZ2luYXRpb25DcmVhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFtb3VudCBvZiBpdGVtcyBpbiBlYWNoIHBhZ2UuIFVwZGF0ZWQgaW4gZWFjaCByZWZyZXNoLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGltaXRQZXJQYWdlID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFnZSBjdXJyZW50bHkgc2hvd2VkLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VycmVudFBhZ2UgPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3RhbCBhbW91bnQgb2YgcGFnZXMuIERhdGEgdXBkYXRlZCBpbiBlYWNoIHJlZnJlc2guXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wYWdlcyA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3RhbmNlIG5lZWRlZCB0byBtb3ZlIE9OTFkgT05FIFBBR0UuIERhdGEgdXBkYXRlZCBpbiBlYWNoIHJlZnJlc2guXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wYWdlV2lkdGggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGl0ZW1zIHRoYXQgc2hvdWxkIGJlIGxvYWRlZCBhc3luY2hyb25vdXNseSBvbiBwYWdlIG1vdmVtZW50LlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXN5bmMgPSB0aGlzLl9vcHRpb25zLmFzeW5jO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVSSBlbGVtZW50IG9mIGFycm93IHRoYXQgbW92ZXMgdGhlIENhcm91c2VsIHRvIHRoZSBwcmV2aW91cyBwYWdlLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcmV2QXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fcHJldkFycm93LnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcbiAgICAgICAgdGhpcy5fcHJldkFycm93LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLl9wcmV2QXJyb3cuc2V0QXR0cmlidXRlKCdjbGFzcycsICdjaC1jYXJvdXNlbC1wcmV2IGNoLWNhcm91c2VsLWRpc2FibGVkJyk7XG4gICAgICAgIHRpbnkub24odGhpcy5fcHJldkFycm93LCBwb2ludGVydGFwLCBmdW5jdGlvbiAoKSB7IHRoYXQucHJldigpOyB9LCBmYWxzZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVJIGVsZW1lbnQgb2YgYXJyb3cgdGhhdCBtb3ZlcyB0aGUgQ2Fyb3VzZWwgdG8gdGhlIG5leHQgcGFnZS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0hUTUxEaXZFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmV4dEFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX25leHRBcnJvdy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuX25leHRBcnJvdy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5fbmV4dEFycm93LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnY2gtY2Fyb3VzZWwtbmV4dCcpO1xuICAgICAgICB0aW55Lm9uKHRoaXMuX25leHRBcnJvdywgcG9pbnRlcnRhcCwgZnVuY3Rpb24gKCkgeyB0aGF0Lm5leHQoKTsgfSwgZmFsc2UpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVSSBlbGVtZW50IHRoYXQgY29udGFpbnMgYWxsIHRoZSB0aHVtYm5haWxzIGZvciBwYWdpbmF0aW9uLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wYWdpbmF0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX3BhZ2luYXRpb24uc2V0QXR0cmlidXRlKCdyb2xlJywgJ25hdmlnYXRpb24nKTtcbiAgICAgICAgdGhpcy5fcGFnaW5hdGlvbi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2NoLWNhcm91c2VsLXBhZ2VzJyk7XG5cbiAgICAgICAgdGlueS5vbih0aGlzLl9wYWdpbmF0aW9uLCBwb2ludGVydGFwLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcGFnZSBmcm9tIHRoZSBlbGVtZW50XG4gICAgICAgICAgICB2YXIgcGFnZSA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFnZScpO1xuICAgICAgICAgICAgLy8gQWxsb3cgaW50ZXJhY3Rpb25zIGZyb20gYSB2YWxpZCBwYWdlIG9mIHBhZ2luYXRpb25cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSBudWxsKSB7IHRoYXQuc2VsZWN0KHdpbmRvdy5wYXJzZUludChwYWdlLCAxMCkpOyB9XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICAvLyBSZWZyZXNoIGNhbGN1bGF0aW9uIHdoZW4gdGhlIHZpZXdwb3J0IHJlc2l6ZXNcbiAgICAgICAgY2gudmlld3BvcnQub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHsgdGhhdC5yZWZyZXNoKCk7IH0pO1xuXG4gICAgICAgIC8vIElmIGVmZWN0cyBhcmVuJ3QgbmVlZGVkLCBhdm9pZCB0cmFuc2l0aW9uIG9uIGxpc3RcbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmZ4KSB7IHRpbnkuYWRkQ2xhc3ModGhpcy5fbGlzdCwgJ2NoLWNhcm91c2VsLW5vZngnKTsgfVxuXG4gICAgICAgIC8vIFBvc2l0aW9uIGFic29sdXRlbGx5IHRoZSBsaXN0IHdoZW4gQ1NTIHRyYW5zaXRpb25zIGFyZW4ndCBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKCF0aW55LnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbGlzdC5zdHlsZS5jc3NUZXh0ICs9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcGFyYW1ldGVyIHNwZWNpZnlpbmcgYSBwYWdpbmF0aW9uLCBhZGQgaXRcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbikgeyB0aGlzLl9hZGRQYWdpbmF0aW9uKCk7IH1cblxuICAgICAgICAvLyBBbGxvdyB0byByZW5kZXIgdGhlIGFycm93c1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5hcnJvd3MgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9vcHRpb25zLmFycm93cyAhPT0gZmFsc2UpIHsgdGhpcy5fYWRkQXJyb3dzKCk7IH1cblxuICAgICAgICAvLyBTZXQgV0FJLUFSSUEgcHJvcGVydGllcyB0byBlYWNoIGl0ZW0gZGVwZW5kaW5nIG9uIHRoZSBwYWdlIGluIHdoaWNoIHRoZXNlIGFyZVxuICAgICAgICB0aGlzLl91cGRhdGVBUklBKCk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGl0ZW1zIHBlciBwYWdlIGFuZCBjYWxjdWxhdGUgcGFnZXMsIG9ubHkgd2hlbiB0aGUgYW1vdW50IG9mIGl0ZW1zIHdhcyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxpbWl0UGVyUGFnZSgpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFyZ2luIGJldHdlZW4gaXRlbXMgYW5kIGl0cyBzaXplXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpc3RyaWJ1dGlvbigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYWNjZXNpYmlsaXR5IHByb3BlcnRpZXMgdG8gZWFjaCBpdGVtIGRlcGVuZGluZyBvbiB0aGUgcGFnZSBpbiB3aGljaCB0aGVzZSBhcmUuXG4gICAgICogQG1lbWJlcm9mISBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5fdXBkYXRlQVJJQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBhbiBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2UsIHNhdmVzIGFsbCB0aGUgaW5mb3JtYXRpb24gYW5kIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcy5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIC8vIEFtb3VudCBvZiBpdGVtcyB3aGVuIEFSSUEgaXMgdXBkYXRlZFxuICAgICAgICAgICAgdG90YWwgPSB0aGlzLl9pdGVtcy5sZW5ndGggKyB0aGlzLl9hc3luYyxcbiAgICAgICAgICAgIC8vIFBhZ2Ugd2hlcmUgZWFjaCBpdGVtIGlzIGluXG4gICAgICAgICAgICBwYWdlO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBXQUktQVJJQSBwcm9wZXJ0aWVzIG9uIGFsbCBpdGVtc1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRoaXMuX2l0ZW1zLCBmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHBhZ2Ugd2hlcmUgdGhpcyBpdGVtIGlzIGluXG4gICAgICAgICAgICBwYWdlID0gTWF0aC5mbG9vcihpIC8gdGhhdC5fbGltaXRQZXJQYWdlKSArIDE7XG4gICAgICAgICAgICAvLyBVcGRhdGUgQVJJQSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAocGFnZSAhPT0gdGhhdC5fY3VycmVudFBhZ2UpKTtcbiAgICAgICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLXNldHNpemUnLCB0b3RhbCk7XG4gICAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnYXJpYS1wb3NpbnNldCcsIChpICsgMSkpO1xuICAgICAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAncGFnZScgKyBwYWdlKTtcbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBpdGVtcyB3aGVuIHBhZ2UvcGFnZXMgbmVlZHMgdG8gbG9hZCBpdCBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNhcm91c2VsLnByb3RvdHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9sb2FkQXN5bmNJdGVtcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvLyBMb2FkIG9ubHkgd2hlbiB0aGVyZSBhcmUgaXRlbXMgdG8gbG9hZFxuICAgICAgICBpZiAodGhpcy5fYXN5bmMgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgLy8gQW1vdW50IG9mIGl0ZW1zIGZyb20gdGhlIGJlZ2lubmluZyB0byBjdXJyZW50IHBhZ2VcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5fY3VycmVudFBhZ2UgKiB0aGlzLl9saW1pdFBlclBhZ2UsXG4gICAgICAgICAgICAvLyBIb3cgbWFueSBpdGVtcyBuZWVkcyB0byBhZGQgdG8gaXRlbXMgcmVuZGVyZWQgdG8gY29tcGxldGUgdG8gdGhpcyBwYWdlXG4gICAgICAgICAgICBhbW91bnQgPSB0b3RhbCAtIHRoaXMuX2l0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgd2lkdGggY2FsY3VsYXRlZCBmcm9tIGN1cnJlbnQgd2lkdGggcGx1cyBleHRyYVdpZHRoXG4gICAgICAgICAgICB3aWR0aCA9ICh0aGlzLl9pdGVtV2lkdGggKyB0aGlzLl9pdGVtRXh0cmFXaWR0aCksXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGhlaWdodCB1c2luZyBuZXcgd2lkdGggYW5kIHJlbGF0aW9uIGJldHdlZW4gd2lkdGggYW5kIGhlaWdodCBvZiBpdGVtIChyYXRpbylcbiAgICAgICAgICAgIGhlaWdodCA9ICgod2lkdGggKiB0aGlzLl9pdGVtSGVpZ2h0KSAvIHRoaXMuX2l0ZW1XaWR0aCkudG9GaXhlZCgzKSxcbiAgICAgICAgICAgIC8vIEdlbmVyaWMgPExJPiBIVE1MIEVsZW1lbnQgdG8gYmUgYWRkZWQgdG8gdGhlIENhcm91c2VsXG4gICAgICAgICAgICBpdGVtID0gW1xuICAgICAgICAgICAgICAgICc8bGknLFxuICAgICAgICAgICAgICAgICcgY2xhc3M9XCJjaC1jYXJvdXNlbC1pdGVtXCInLFxuICAgICAgICAgICAgICAgICcgc3R5bGU9XCJ3aWR0aDonICsgKHdpZHRoICUgMSA9PT0gMCA/IHdpZHRoIDogd2lkdGgudG9GaXhlZCg0KSkgKyAncHg7JyxcbiAgICAgICAgICAgICAgICAodGhpcy5fb3B0aW9ucy5hdXRvSGVpZ2h0ID8gJ2hlaWdodDonICsgaGVpZ2h0ICsgJ3B4OycgOiAnJyksXG4gICAgICAgICAgICAgICAgKHRoaXMuX29wdGlvbnMuYXV0b01hcmdpbiA/ICdtYXJnaW4tcmlnaHQ6JyArICh0aGlzLl9pdGVtTWFyZ2luICUgMSA9PT0gMCA/IHRoaXMuX2l0ZW1NYXJnaW4gOiB0aGlzLl9pdGVtTWFyZ2luLnRvRml4ZWQoNCkpICsgJ3B4XCInIDogJ1wiJyksXG4gICAgICAgICAgICAgICAgJz48L2xpPidcbiAgICAgICAgICAgIF0uam9pbignJyksXG4gICAgICAgICAgICAvLyBJdCBzdG9yZXMgPExJPiB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIERPTSBjb2xsZWN0aW9uXG4gICAgICAgICAgICBpdGVtcyA9ICcnLFxuICAgICAgICAgICAgLy8gSXQgc3RvcmVzIHRoZSBpdGVtcyB0aGF0IG11c3QgYmUgYWRkZWQsIGl0IGhlbHBzIHRvIHNsaWNlIHRoZSBpdGVtcyBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgY291bnRlciA9IDA7XG5cbiAgICAgICAgLy8gTG9hZCBvbmx5IHdoZW4gdGhlcmUgYXJlIGl0ZW1zIHRvIGFkZFxuICAgICAgICBpZiAoYW1vdW50IDwgMSkgeyByZXR1cm47IH1cblxuICAgICAgICAvLyBJZiBuZXh0IHBhZ2UgbmVlZHMgbGVzcyBpdGVtcyB0aGFuIGl0IHN1cHBvcnQsIHRoZW4gYWRkIHRoYXQgYW1vdW50XG4gICAgICAgIGFtb3VudCA9ICh0aGlzLl9hc3luYyA8IGFtb3VudCkgPyB0aGlzLl9hc3luYyA6IGFtb3VudDtcblxuICAgICAgICAvLyBBZGQgdGhlIG5lY2Vzc2FyeSBhbW91bnQgb2YgaXRlbXNcbiAgICAgICAgd2hpbGUgKGFtb3VudCkge1xuICAgICAgICAgICAgaXRlbXMgKz0gaXRlbTtcbiAgICAgICAgICAgIGFtb3VudCAtPSAxO1xuICAgICAgICAgICAgY291bnRlciArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHNhbXBsZSBpdGVtcyB0byB0aGUgbGlzdFxuICAgICAgICB0aGlzLl9saXN0Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgaXRlbXMpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBpdGVtcyBjb2xsZWN0aW9uXG4gICAgICAgIC8vIHVzZXMgcXVlcnlTZWxlY3RvckFsbCBiZWNhdXNlIGl0IG5lZWQgYSBzdGF0aWMgY29sbGVjdGlvblxuICAgICAgICB0aGlzLl9pdGVtcyA9IHRoaXMuX2xpc3QucXVlcnlTZWxlY3RvckFsbCgnbGknKTtcblxuICAgICAgICAvLyBTZXQgV0FJLUFSSUEgcHJvcGVydGllcyB0byBlYWNoIGl0ZW1cbiAgICAgICAgdGhpcy5fdXBkYXRlQVJJQSgpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBhbW91bnQgb2YgaXRlbXMgdG8gYWRkIGFzeW5jaHJvbm91c2x5XG4gICAgICAgIHRoaXMuX2FzeW5jIC09IGFtb3VudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBjb21wb25lbnQgY3JlYXRlcyBuZXcgYXN5bmNocm9ub3VzIGVtcHR5IGl0ZW1zLlxuICAgICAgICAgKiBAZXZlbnQgY2guQ2Fyb3VzZWwjaXRlbXNhZGRcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gQ3JlYXRlIGEgbmV3IENhcm91c2VsIHdpdGggaXRlbXMgYXN5bmNocm9ub3VzbHkgbG9hZGVkLlxuICAgICAgICAgKiB2YXIgY2Fyb3VzZWwgPSBuZXcgY2guQ2Fyb3VzZWwoe1xuICAgICAgICAgKiAgICAgJ2FzeW5jJzogMTBcbiAgICAgICAgICogfSkub24oJ2l0ZW1zYWRkJywgZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICogICAgIC8vIEluamVjdCBjb250ZW50IGludG8gdGhlIGFkZGVkIDxsaT4gZWxlbWVudHNcbiAgICAgICAgICogICAgICQuZWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgKiAgICAgICAgIGUuaW5uZXJIVE1MID0gJ0NvbnRlbnQgaW50byBvbmUgb2YgbmV3bHkgaW5zZXJ0ZWQgPGxpPiBlbGVtZW50cy4nO1xuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWl0KCdpdGVtc2FkZCcsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2l0ZW1zLCAtY291bnRlcikpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWdpbmF0aW9uIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQG1lbWJlcm9mISBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5fYWRkUGFnaW5hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBjdXJyZW50IHBhZ2luYXRpb24gaWYgaXQncyBuZWNlc3NhcnkgdG8gY3JlYXRlIGFnYWluXG4gICAgICAgIGlmICh0aGlzLl9wYWdpbmF0aW9uQ3JlYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlUGFnaW5hdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgdGh1bWJzID0gW10sXG4gICAgICAgICAgICBwYWdlID0gdGhhdC5fcGFnZXMsXG4gICAgICAgICAgICBpc1NlbGVjdGVkO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIGEgdGh1bWJuYWlsIGZvciBlYWNoIHBhZ2Ugb24gQ2Fyb3VzZWxcbiAgICAgICAgd2hpbGUgKHBhZ2UpIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGlzIHRodW1ibmFpbCBpcyBzZWxlY3RlZCBvciBub3RcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSAocGFnZSA9PT0gdGhhdC5fY3VycmVudFBhZ2UpO1xuICAgICAgICAgICAgLy8gQWRkIHN0cmluZyB0byBjb2xsZWN0aW9uXG4gICAgICAgICAgICB0aHVtYnMudW5zaGlmdChcbiAgICAgICAgICAgICAgICAnPHNwYW4nLFxuICAgICAgICAgICAgICAgICcgcm9sZT1cImJ1dHRvblwiJyxcbiAgICAgICAgICAgICAgICAnIGFyaWEtc2VsZWN0ZWQ9XCInICsgaXNTZWxlY3RlZCArICdcIicsXG4gICAgICAgICAgICAgICAgJyBhcmlhLWNvbnRyb2xzPVwicGFnZScgKyBwYWdlICsgJ1wiJyxcbiAgICAgICAgICAgICAgICAnIGRhdGEtcGFnZT1cIicgKyBwYWdlICsgJ1wiJyxcbiAgICAgICAgICAgICAgICAnIGNsYXNzPVwiJyArIChpc1NlbGVjdGVkID8gJ2NoLWNhcm91c2VsLXNlbGVjdGVkJyA6ICcnKSArICdcIicsXG4gICAgICAgICAgICAgICAgJz4nICsgcGFnZSArICc8L3NwYW4+J1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcGFnZSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwZW5kIHRodW1ibmFpbHMgdG8gcGFnaW5hdGlvbiBhbmQgYXBwZW5kIHRoaXMgdG8gQ2Fyb3VzZWxcbiAgICAgICAgdGhhdC5fcGFnaW5hdGlvbi5pbm5lckhUTUwgPSB0aHVtYnMuam9pbignJyk7XG4gICAgICAgIHRoYXQuX2VsLmFwcGVuZENoaWxkKHRoYXQuX3BhZ2luYXRpb24pO1xuXG4gICAgICAgIC8vIEF2b2lkIHNlbGVjdGlvbiBvbiB0aGUgcGFnaW5hdGlvblxuICAgICAgICB0aGF0Ll9wYWdpbmF0aW9uLnNldEF0dHJpYnV0ZSgndW5zZWxlY3RhYmxlJywgJ29uJyk7XG4gICAgICAgIHRpbnkuYWRkQ2xhc3ModGhhdC5fcGFnaW5hdGlvbiwgJ2NoLXVzZXItbm8tc2VsZWN0Jyk7XG5cbiAgICAgICAgLy8gQ2hlY2sgcGFnaW5hdGlvbiBhcyBjcmVhdGVkXG4gICAgICAgIHRoYXQuX3BhZ2luYXRpb25DcmVhdGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgcGFnaW5hdGlvbiBmcm9tIHRoZSBjb21wb25lbnQuXG4gICAgICogQG1lbWJlcm9mISBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5fcmVtb3ZlUGFnaW5hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQXZvaWQgdG8gY2hhbmdlIHNvbWV0aGluZyB0aGF0IG5vdCBleGlzdHNcbiAgICAgICAgaWYgKCF0aGlzLl9wYWdpbmF0aW9uQ3JlYXRlZCkgeyByZXR1cm47IH1cbiAgICAgICAgLy8gRGVsZXRlIHRodW1ibmFpbHNcbiAgICAgICAgdGhpcy5fcGFnaW5hdGlvbi5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgLy8gQ2hlY2sgcGFnaW5hdGlvbiBhcyBkZWxldGVkXG4gICAgICAgIHRoaXMuX3BhZ2luYXRpb25DcmVhdGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEl0IHN0b3BzIHRoZSBzbGlkZSBlZmZlY3Qgd2hpbGUgdGhlIGxpc3QgbW92ZXMuXG4gICAgICogQG1lbWJlcm9mISBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBkaXNhYmxlIHRoZSBlZmZlY3RzLlxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5fc3RhbmRieUZYID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gY29udGV4dCBvZiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAvLyBEbyBpdCBpZiBpcyByZXF1aXJlZFxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5meCAmJiB0aW55LnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgLy8gRGVsZXRlIGVmZWN0cyBvbiBsaXN0IHRvIG1ha2UgY2hhbmdlcyBpbnN0YW50bHlcbiAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy5fbGlzdCwgJ2NoLWNhcm91c2VsLW5vZngnKTtcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGN1c3RvbSBtZXRob2RcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvLyBSZXN0b3JlIGVmZWN0cyB0byBsaXN0XG4gICAgICAgICAgICAvLyBVc2UgYSBzZXRUaW1lb3V0IHRvIGJlIHN1cmUgdG8gZG8gdGhpcyBBRlRFUiBjaGFuZ2VzXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGlueS5yZW1vdmVDbGFzcyh0aGF0Ll9saXN0LCAnY2gtY2Fyb3VzZWwtbm9meCcpOyB9LCAwKTtcbiAgICAgICAgLy8gQXZvaWQgdG8gYWRkL3JlbW92ZSBjbGFzc2VzIGlmIGl0IGhhc24ndCBlZmZlY3RzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHRvdGFsIGFtb3VudCBvZiBwYWdlcyBhbmQgZXhlY3V0ZXMgaW50ZXJuYWwgbWV0aG9kcyB0byBsb2FkIGFzeW5jaHJvbm91cyBpdGVtcywgdXBkYXRlIFdBSS1BUklBLCB1cGRhdGUgdGhlIGFycm93cyBhbmQgdXBkYXRlIHBhZ2luYXRpb24uXG4gICAgICogQG1lbWJlcm9mISBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5fdXBkYXRlUGFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYW1vdW50IG9mIHRvdGFsIHBhZ2VzXG4gICAgICAgIC8vIFRoZSByYXRpbyBiZXR3ZWVuIHRvdGFsIGFtb3VudCBvZiBpdGVtcyBhbmQgaXRlbXMgaW4gZWFjaCBwYWdlXG4gICAgICAgIHRoaXMuX3BhZ2VzID0gTWF0aC5jZWlsKCh0aGlzLl9pdGVtcy5sZW5ndGggKyB0aGlzLl9hc3luYykgLyB0aGlzLl9saW1pdFBlclBhZ2UpO1xuICAgICAgICAvLyBBZGQgaXRlbXMgdG8gdGhlIGxpc3QsIGlmIGl0J3MgbmVjZXNzYXJ5XG4gICAgICAgIHRoaXMuX2xvYWRBc3luY0l0ZW1zKCk7XG4gICAgICAgIC8vIFNldCBXQUktQVJJQSBwcm9wZXJ0aWVzIHRvIGVhY2ggaXRlbVxuICAgICAgICB0aGlzLl91cGRhdGVBUklBKCk7XG4gICAgICAgIC8vIFVwZGF0ZSBhcnJvd3MgKHdoZW4gcGFnZXMgPT09IDEsIHRoZXJlIGlzIG5vIGFycm93cylcbiAgICAgICAgdGhpcy5fdXBkYXRlQXJyb3dzKCk7XG4gICAgICAgIC8vIFVwZGF0ZSBwYWdpbmF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnBhZ2luYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFBhZ2luYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBjb3JyZWN0IGl0ZW1zIHBlciBwYWdlIGFuZCBjYWxjdWxhdGUgcGFnZXMsIG9ubHkgd2hlbiB0aGUgYW1vdW50IG9mIGl0ZW1zIHdhcyBjaGFuZ2VkLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ2Fyb3VzZWwucHJvdG90eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3VwZGF0ZUxpbWl0UGVyUGFnZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgbWF4ID0gdGhpcy5fb3B0aW9ucy5saW1pdFBlclBhZ2UsXG4gICAgICAgICAgICAvLyBHbyB0byB0aGUgY3VycmVudCBmaXJzdCBpdGVtIG9uIHRoZSBjdXJyZW50IHBhZ2UgdG8gcmVzdG9yZSBpZiBwYWdlcyBhbW91bnQgY2hhbmdlc1xuICAgICAgICAgICAgZmlyc3RJdGVtT25QYWdlLFxuICAgICAgICAgICAgLy8gVGhlIHdpZHRoIG9mIGVhY2ggaXRlbSBpbnRvIHRoZSB3aWR0aCBvZiB0aGUgbWFza1xuICAgICAgICAgICAgLy8gQXZvaWQgemVybyBpdGVtcyBpbiBhIHBhZ2VcbiAgICAgICAgICAgIGxpbWl0UGVyUGFnZSA9IE1hdGguZmxvb3IodGhpcy5fbWFza1dpZHRoIC8gdGhpcy5faXRlbU91dGVyV2lkdGgpIHx8IDE7XG5cbiAgICAgICAgLy8gTGltaXQgYW1vdW50IG9mIGl0ZW1zIHdoZW4gdXNlciBzZXQgYSBsaW1pdFBlclBhZ2UgYW1vdW50XG4gICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBsaW1pdFBlclBhZ2UgPiBtYXgpIHsgbGltaXRQZXJQYWdlID0gbWF4OyB9XG5cbiAgICAgICAgLy8gU2V0IGRhdGEgYW5kIGNhbGN1bGF0ZSBwYWdlcywgb25seSB3aGVuIHRoZSBhbW91bnQgb2YgaXRlbXMgd2FzIGNoYW5nZWRcbiAgICAgICAgaWYgKGxpbWl0UGVyUGFnZSA9PT0gdGhpcy5fbGltaXRQZXJQYWdlKSB7IHJldHVybjsgfVxuXG4gICAgICAgIC8vIFJlc3RvcmUgaWYgbGltaXRQZXJQYWdlIGlzIE5PVCB0aGUgc2FtZSBhZnRlciBjYWxjdWxhdGlvbnMgKGdvIHRvIHRoZSBjdXJyZW50IGZpcnN0IGl0ZW0gcGFnZSlcbiAgICAgICAgZmlyc3RJdGVtT25QYWdlID0gKCh0aGlzLl9jdXJyZW50UGFnZSAtIDEpICogdGhpcy5fbGltaXRQZXJQYWdlKSArIDE7XG4gICAgICAgIC8vIFVwZGF0ZSBhbW91bnQgb2YgaXRlbXMgaW50byBhIHNpbmdsZSBwYWdlIChmcm9tIGNvbmYgb3IgYXV0byBjYWxjdWxhdGlvbnMpXG4gICAgICAgIHRoaXMuX2xpbWl0UGVyUGFnZSA9IGxpbWl0UGVyUGFnZTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlcyB0aGUgdG90YWwgYW1vdW50IG9mIHBhZ2VzIGFuZCBleGVjdXRlcyBpbnRlcm5hbCBtZXRob2RzXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBhZ2VzKCk7XG4gICAgICAgIC8vIEdvIHRvIHRoZSBjdXJyZW50IGZpcnN0IGl0ZW0gcGFnZVxuICAgICAgICB0aGlzLnNlbGVjdChNYXRoLmNlaWwoZmlyc3RJdGVtT25QYWdlIC8gbGltaXRQZXJQYWdlKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHNldCB0aGUgc2l6ZSBvZiB0aGUgaXRlbXMgYW5kIGl0cyBtYXJnaW4gdG8gZ2V0IGFuIGFkYXB0aXZlIENhcm91c2VsLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ2Fyb3VzZWwucHJvdG90eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3VwZGF0ZURpc3RyaWJ1dGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1vcmVUaGFuT25lID0gdGhpcy5fbGltaXRQZXJQYWdlID4gMSxcbiAgICAgICAgICAgIC8vIFRvdGFsIHNwYWNlIHRvIHVzZSBhcyBtYXJnaW4gaW50byBtYXNrXG4gICAgICAgICAgICAvLyBJdCdzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gbWFzayB3aWR0aCBhbmQgdG90YWwgd2lkdGggb2YgYWxsIGl0ZW1zXG4gICAgICAgICAgICBmcmVlU3BhY2UgPSB0aGlzLl9tYXNrV2lkdGggLSAodGhpcy5faXRlbU91dGVyV2lkdGggKiB0aGlzLl9saW1pdFBlclBhZ2UpLFxuICAgICAgICAgICAgLy8gRGVmaW5lcyBob3cgdG8gZGlzdHJpYnV0ZSB0aGUgZnJlZVNwYWNlLlxuICAgICAgICAgICAgZnJlZVNwYWNlRGlzdHJpYnV0aW9uID0gdGhpcy5fb3B0aW9ucy5hdXRvTWFyZ2luID8gKGZyZWVTcGFjZSAvIHRoaXMuX2xpbWl0UGVyUGFnZSAvIDIpIDogKGZyZWVTcGFjZSAvIHRoaXMuX2xpbWl0UGVyUGFnZSksXG4gICAgICAgICAgICAvLyBXaWR0aCB0byBhZGQgdG8gZWFjaCBpdGVtIHRvIGdldCByZXNwb25zaXZpdHlcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgaXRlbSwgZ2V0IGV4dHJhIHdpZHRoIGZvciBlYWNoIG9uZVxuICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBhcmUgb25seSBvbmUgaXRlbSwgZXh0cmFXaWR0aCBtdXN0IGJlIGp1c3QgdGhlIGZyZWVTcGFjZVxuICAgICAgICAgICAgZXh0cmFXaWR0aCA9IG1vcmVUaGFuT25lID8gZnJlZVNwYWNlRGlzdHJpYnV0aW9uIDogZnJlZVNwYWNlLFxuICAgICAgICAgICAgLy8gQW1vdW50IG9mIHNwYWNlcyB0byBkaXN0cmlidXRlIHRoZSBmcmVlIHNwYWNlXG4gICAgICAgICAgICBzcGFjZXMsXG4gICAgICAgICAgICAvLyBUaGUgbmV3IHdpZHRoIGNhbGN1bGF0ZWQgZnJvbSBjdXJyZW50IHdpZHRoIHBsdXMgZXh0cmFXaWR0aFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAvLyBTdHlsZXMgdG8gdXBkYXRlIHRoZSBpdGVtIGVsZW1lbnQgd2lkdGgsIGhlaWdodCAmIG1hcmdpbi1yaWdodFxuICAgICAgICAgICAgY3NzSXRlbVRleHQ7XG5cbiAgICAgICAgLy8gVXBkYXRlIE9OTFkgSUYgbWFyZ2luIGNoYW5nZWQgZnJvbSBsYXN0IHJlZnJlc2hcbiAgICAgICAgLy8gSWYgKm5ldyogYW5kICpvbGQqIGV4dHJhIHdpZHRoIGFyZSAwLCBjb250aW51ZSB0b29cbiAgICAgICAgaWYgKGV4dHJhV2lkdGggPT09IHRoaXMuX2l0ZW1FeHRyYVdpZHRoICYmIGV4dHJhV2lkdGggPiAwKSB7IHJldHVybjsgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgdmFsdWUgb2Ygd2lkdGhcbiAgICAgICAgdGhpcy5faXRlbUV4dHJhV2lkdGggPSBleHRyYVdpZHRoO1xuXG4gICAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIDYgaXRlbXMgb24gYSBwYWdlLCB0aGVyZSBhcmUgNSBzcGFjZXMgYmV0d2VlbiB0aGVtXG4gICAgICAgIC8vIEV4Y2VwdCB3aGVuIHRoZXJlIGFyZSBvbmx5IG9uZSBwYWdlIHRoYXQgTk8gZXhpc3Qgc3BhY2VzXG4gICAgICAgIHNwYWNlcyA9IG1vcmVUaGFuT25lID8gdGhpcy5fbGltaXRQZXJQYWdlIC0gMSA6IDA7XG4gICAgICAgIC8vIFRoZSBuZXcgd2lkdGggY2FsY3VsYXRlZCBmcm9tIGN1cnJlbnQgd2lkdGggcGx1cyBleHRyYVdpZHRoXG4gICAgICAgIHdpZHRoID0gdGhpcy5faXRlbVdpZHRoICsgZXh0cmFXaWR0aDtcblxuICAgICAgICAvLyBGcmVlIHNwYWNlIGZvciBlYWNoIHNwYWNlIGJldHdlZW4gaXRlbXNcbiAgICAgICAgLy8gQ2VpbCB0byBkZWxldGUgZmxvYXQgbnVtYmVycyAobm90IEZsb29yLCBiZWNhdXNlIG5leHQgcGFnZSBpcyBzZWVuKVxuICAgICAgICAvLyBUaGVyZSBpcyBubyBtYXJnaW4gd2hlbiB0aGVyZSBhcmUgb25seSBvbmUgaXRlbSBpbiBhIHBhZ2VcbiAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCB2YWx1ZXNcbiAgICAgICAgdGhpcy5faXRlbU1hcmdpbiA9IHRoaXMuX29wdGlvbnMuYXV0b01hcmdpbiAmJiBtb3JlVGhhbk9uZSA/IChmcmVlU3BhY2UgLyBzcGFjZXMgLyAyKSA6IDA7XG5cbiAgICAgICAgLy8gVXBkYXRlIGRpc3RhbmNlIG5lZWRlZCB0byBtb3ZlIE9OTFkgT05FIHBhZ2VcbiAgICAgICAgLy8gVGhlIHdpZHRoIG9mIGFsbCBpdGVtcyBvbiBhIHBhZ2UsIHBsdXMgdGhlIHdpZHRoIG9mIGFsbCBtYXJnaW5zIG9mIGl0ZW1zXG4gICAgICAgIHRoaXMuX3BhZ2VXaWR0aCA9ICh0aGlzLl9pdGVtT3V0ZXJXaWR0aCArIGV4dHJhV2lkdGggKyB0aGlzLl9pdGVtTWFyZ2luKSAqIHRoaXMuX2xpbWl0UGVyUGFnZTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGxpc3Qgd2lkdGhcbiAgICAgICAgLy8gRG8gaXQgYmVmb3JlIGl0ZW0gcmVzaXppbmcgdG8gbWFrZSBzcGFjZSB0byBhbGwgaXRlbXNcbiAgICAgICAgLy8gRGVsZXRlIGVmZWN0cyBvbiBsaXN0IHRvIGNoYW5nZSB3aWR0aCBpbnN0YW50bHlcbiAgICAgICAgdGhpcy5fc3RhbmRieUZYKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3Quc3R5bGUuY3NzVGV4dCA9IHRoaXMuX2xpc3Quc3R5bGUuY3NzVGV4dCArICc7ICcgKyAnd2lkdGg6JyArICh0aGlzLl9wYWdlV2lkdGggKiB0aGlzLl9wYWdlcykgKyAncHg7JztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBoZWlnaHQgdXNpbmcgbmV3IHdpZHRoIGFuZCByZWxhdGlvbiBiZXR3ZWVuIHdpZHRoIGFuZCBoZWlnaHQgb2YgaXRlbSAocmF0aW8pXG4gICAgICAgIGNzc0l0ZW1UZXh0ID0gW1xuICAgICAgICAgICAgJ3dpZHRoOicgKyAod2lkdGggJSAxID09PSAwID8gd2lkdGggOiB3aWR0aC50b0ZpeGVkKDQpKSArICdweDsnLFxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5hdXRvSGVpZ2h0ID8gJ2hlaWdodDonICsgKCh3aWR0aCAqIHRoaXMuX2l0ZW1IZWlnaHQpIC8gdGhpcy5faXRlbVdpZHRoKS50b0ZpeGVkKDQpICsgJ3B4OycgOiAnJyxcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuYXV0b01hcmdpbiA/ICdtYXJnaW4tcmlnaHQ6JyArICh0aGlzLl9pdGVtTWFyZ2luICUgMSA9PT0gMCA/IHRoaXMuX2l0ZW1NYXJnaW4gOiB0aGlzLl9pdGVtTWFyZ2luLnRvRml4ZWQoNCkpICsgJ3B4OycgOiAnJ1xuICAgICAgICBdLmpvaW4oJycpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBlbGVtZW50IHN0eWxlc1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRoaXMuX2l0ZW1zLCBmdW5jdGlvbiAoaXRlbSl7XG4gICAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBjc3NJdGVtVGV4dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFzayBoZWlnaHQgd2l0aCB0aGUgbGlzdCBoZWlnaHRcbiAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5oZWlnaHQgPSB0aGlzLl9nZXRPdXRlckRpbWVuc2lvbnModGhpcy5fbGlzdCkuaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAvLyBTdWl0IHRoZSBwYWdlIGluIHBsYWNlXG4gICAgICAgIHRoaXMuX3N0YW5kYnlGWChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2xhdGUoLXRoaXMuX3BhZ2VXaWR0aCAqICh0aGlzLl9jdXJyZW50UGFnZSAtIDEpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYXJyb3dzIHRvIHRoZSBjb21wb25lbnQuXG4gICAgICogQG1lbWJlcm9mISBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5fYWRkQXJyb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBdm9pZCBzZWxlY3Rpb24gb24gdGhlIGFycm93c1xuICAgICAgICBbdGhpcy5fcHJldkFycm93LCB0aGlzLl9uZXh0QXJyb3ddLmZvckVhY2goZnVuY3Rpb24oZWwpe1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd1bnNlbGVjdGFibGUnLCAnb24nKTtcbiAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3MoZWwsICdjaC11c2VyLW5vLXNlbGVjdCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgYXJyb3dzIHRvIERPTVxuICAgICAgICB0aGlzLl9lbC5pbnNlcnRCZWZvcmUodGhpcy5fcHJldkFycm93LCB0aGlzLl9lbC5jaGlsZHJlblswXSk7XG4gICAgICAgIHRoaXMuX2VsLmFwcGVuZENoaWxkKHRoaXMuX25leHRBcnJvdyk7XG4gICAgICAgIC8vIENoZWNrIGFycm93cyBhcyBjcmVhdGVkXG4gICAgICAgIHRoaXMuX2Fycm93c0NyZWF0ZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYXMgZGlzYWJsZWQgdGhlIGFycm93cyBieSBhZGRpbmcgYSBjbGFzc25hbWUgYW5kIGEgV0FJLUFSSUEgcHJvcGVydHkuXG4gICAgICogQG1lbWJlcm9mISBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJldiBEZWZpbmVzIGlmIHRoZSBcInByZXZpb3VzXCIgYXJyb3cgbXVzdCBiZSBkaXNhYmxlZCBvciBub3QuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBuZXh0IERlZmluZXMgaWYgdGhlIFwibmV4dFwiIGFycm93IG11c3QgYmUgZGlzYWJsZWQgb3Igbm90LlxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5fZGlzYWJsZUFycm93cyA9IGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gICAgICAgIHRoaXMuX3ByZXZBcnJvdy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCBwcmV2KTtcbiAgICAgICAgdGhpcy5fcHJldkFycm93LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCBwcmV2KTtcbiAgICAgICAgdGlueVtwcmV2ID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKHRoaXMuX3ByZXZBcnJvdywgJ2NoLWNhcm91c2VsLWRpc2FibGVkJyk7XG5cbiAgICAgICAgdGhpcy5fbmV4dEFycm93LnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsIG5leHQpO1xuICAgICAgICB0aGlzLl9uZXh0QXJyb3cuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIG5leHQpO1xuICAgICAgICB0aW55W25leHQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10odGhpcy5fbmV4dEFycm93LCAnY2gtY2Fyb3VzZWwtZGlzYWJsZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGFycm93cyBiZWhhdmlvciBvbiBmaXJzdCwgbGFzdCBhbmQgbWlkZGxlIHBhZ2VzLCBhbmQgdXBkYXRlIGNsYXNzIG5hbWUgYW5kIFdBSS1BUklBIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNhcm91c2VsLnByb3RvdHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl91cGRhdGVBcnJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENoZWNrIGFycm93cyBleGlzdGVuY3lcbiAgICAgICAgaWYgKCF0aGlzLl9hcnJvd3NDcmVhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FzZSAxOiBEaXNhYmxlIGJvdGggYXJyb3dzIGlmIHRoZXJlIGFyZSBvbnkgb25lIHBhZ2VcbiAgICAgICAgaWYgKHRoaXMuX3BhZ2VzID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlQXJyb3dzKHRydWUsIHRydWUpO1xuICAgICAgICAvLyBDYXNlIDI6IFwiUHJldmlvdXNcIiBhcnJvdyBoaWRkZW4gb24gZmlyc3QgcGFnZVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRQYWdlID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlQXJyb3dzKHRydWUsIGZhbHNlKTtcbiAgICAgICAgLy8gQ2FzZSAzOiBcIk5leHRcIiBhcnJvdyBoaWRkZW4gb24gbGFzdCBwYWdlXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY3VycmVudFBhZ2UgPT09IHRoaXMuX3BhZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlQXJyb3dzKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgLy8gQ2FzZSA0OiBFbmFibGUgYm90aCBhcnJvd3Mgb24gQ2Fyb3VzZWwncyBtaWRkbGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVBcnJvd3MoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgbGlzdCBjb3JyZXNwb25kaW5nIHRvIHNwZWNpZmllZCBkaXNwbGFjZW1lbnQuXG4gICAgICogQG1lbWJlcm9mISBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXNwbGFjZW1lbnQgRGlzdGFuY2UgdG8gbW92ZSB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3RyYW5zbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENTUyBwcm9wZXJ0eSB3cml0dGVuIGFzIHN0cmluZyB0byB1c2Ugb24gQ1NTIG1vdmVtZW50XG4gICAgICAgIHZhciB2ZW5kb3JUcmFuc2Zvcm1LZXkgPSBWRU5ET1JfUFJFRklYID8gVkVORE9SX1BSRUZJWCArICdUcmFuc2Zvcm0nIDogbnVsbDtcblxuICAgICAgICAvLyBVc2UgQ1NTIHRyYW5zZm9ybSB0byBtb3ZlXG4gICAgICAgIGlmICh0aW55LnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGhhcyBvbmx5IFwidHJhbnNmb3JtXCIsIFNhZmFyaSBvbmx5IFwid2Via2l0VHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIGhhcyBzdXBwb3J0IGZvciBib3RoLiBBcHBsaWVkIHJlcXVpcmVkIG1pbmltdW1cbiAgICAgICAgICAgICAgICBpZiAodmVuZG9yVHJhbnNmb3JtS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpc3Quc3R5bGVbdmVuZG9yVHJhbnNmb3JtS2V5XSA9ICd0cmFuc2xhdGVYKCcgKyBkaXNwbGFjZW1lbnQgKyAncHgpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWCgnICsgZGlzcGxhY2VtZW50ICsgJ3B4KSc7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIGxlZnQgcG9zaXRpb24gdG8gbW92ZVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRpc3BsYWNlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fbGlzdC5zdHlsZS5sZWZ0ID0gZGlzcGxhY2VtZW50ICsgJ3B4JztcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgc2VsZWN0ZWQgcGFnZSBvbiBwYWdpbmF0aW9uLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ2Fyb3VzZWwucHJvdG90eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZnJvbSBQYWdlIHByZXZpb3VzbHkgc2VsZWN0ZWQuIEl0IHdpbGwgYmUgdW5zZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG8gUGFnZSB0byBiZSBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3N3aXRjaFBhZ2luYXRpb24gPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgICAgLy8gQXZvaWQgdG8gY2hhbmdlIHNvbWV0aGluZyB0aGF0IG5vdCBleGlzdHNcbiAgICAgICAgaWYgKCF0aGlzLl9wYWdpbmF0aW9uQ3JlYXRlZCkgeyByZXR1cm47IH1cbiAgICAgICAgLy8gR2V0IGFsbCB0aHVtYm5haWxzIG9mIHBhZ2luYXRpb24gZWxlbWVudFxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9wYWdpbmF0aW9uLmNoaWxkcmVuLFxuICAgICAgICAgICAgZnJvbUl0ZW0gPSBjaGlsZHJlbltmcm9tIC0gMV0sXG4gICAgICAgICAgICB0b0l0ZW0gPSBjaGlsZHJlblt0byAtIDFdO1xuXG4gICAgICAgIC8vIFVuc2VsZWN0IHRoZSB0aHVtYm5haWwgcHJldmlvdXNseSBzZWxlY3RlZFxuICAgICAgICBmcm9tSXRlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XG4gICAgICAgIHRpbnkucmVtb3ZlQ2xhc3MoZnJvbUl0ZW0sICdjaC1jYXJvdXNlbC1zZWxlY3RlZCcpO1xuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgbmV3IHRodW1ibmFpbFxuICAgICAgICB0b0l0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICAgIHRpbnkuYWRkQ2xhc3ModG9JdGVtLCAnY2gtY2Fyb3VzZWwtc2VsZWN0ZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IG91dGVyIGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBBIGdpdmVuIEhUTUxFbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9nZXRPdXRlckRpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIG9iaiA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnd2lkdGgnOiAob2JqLnJpZ2h0IC0gb2JqLmxlZnQpLFxuICAgICAgICAgICAgJ2hlaWdodCc6IChvYmouYm90dG9tIC0gb2JqLnRvcClcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYWxsIHRoZSBuZWNlc3NhcnkgcmVjYWxjdWxhdGlvbnMgdG8gYmUgdXAtdG8tZGF0ZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNhcm91c2VsLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtjYXJvdXNlbH1cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBtYXNrV2lkdGggPSB0aGlzLl9nZXRPdXRlckRpbWVuc2lvbnModGhpcy5fbWFzaykud2lkdGg7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNoYW5nZXMgb24gdGhlIHdpZHRoIG9mIG1hc2ssIGZvciB0aGUgZWxhc3RpYyBjYXJvdXNlbFxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdpZHRoIG9mIHRoZSBtYXNrXG4gICAgICAgIGlmIChtYXNrV2lkdGggIT09IHRoaXMuX21hc2tXaWR0aCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBnbG9iYWwgcmVmZXJlbmNlIHRvIHRoZSB3aXRoIG9mIHRoZSBtYXNrXG4gICAgICAgICAgICB0aGlzLl9tYXNrV2lkdGggPSBtYXNrV2lkdGg7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgaXRlbXMgcGVyIHBhZ2UgYW5kIGNhbGN1bGF0ZSBwYWdlcywgb25seSB3aGVuIHRoZSBhbW91bnQgb2YgaXRlbXMgd2FzIGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxpbWl0UGVyUGFnZSgpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXJnaW4gYmV0d2VlbiBpdGVtcyBhbmQgaXRzIHNpemVcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpc3RyaWJ1dGlvbigpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29tcG9uZW50IG1ha2VzIGFsbCB0aGUgbmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zIHRvIGJlIHVwLXRvLWRhdGUuXG4gICAgICAgICAgICAgKiBAZXZlbnQgY2guQ2Fyb3VzZWwjcmVmcmVzaFxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcInJlZnJlc2hcIiBldmVudC5cbiAgICAgICAgICAgICAqIGNhcm91c2VsLm9uKCdyZWZyZXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICogICAgIGFsZXJ0KCdDYXJvdXNlbCB3YXMgcmVmcmVzaGVkLicpO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVmcmVzaCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgY2hhbmdlIGluIHRoZSB0b3RhbCBhbW91bnQgb2YgaXRlbXNcbiAgICAgICAgLy8gVXBkYXRlIGl0ZW1zIGNvbGxlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuX2xpc3QuY2hpbGRyZW4ubGVuZ3RoICE9PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZW50aXJlIHJlZmVyZW5jZSB0byBpdGVtc1xuICAgICAgICAgICAgLy8gdXNlcyBxdWVyeVNlbGVjdG9yQWxsIGJlY2F1c2UgaXQgbmVlZCBhIHN0YXRpYyBjb2xsZWN0aW9uXG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IHRoaXMuX2xpc3QucXVlcnlTZWxlY3RvckFsbCgnbGknKTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZXMgdGhlIHRvdGFsIGFtb3VudCBvZiBwYWdlcyBhbmQgZXhlY3V0ZXMgaW50ZXJuYWwgbWV0aG9kc1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUGFnZXMoKTtcbiAgICAgICAgICAgIC8vIEdvIHRvIHRoZSBsYXN0IHBhZ2UgaW4gY2FzZSB0aGF0IHRoZSBjdXJyZW50IHBhZ2Ugbm8gbG9uZ2VyIGV4aXN0c1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRQYWdlID4gdGhpcy5fcGFnZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFuZGJ5RlgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdCh0aGF0Ll9wYWdlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBjb21wb25lbnQgbWFrZXMgYWxsIHRoZSBuZWNlc3NhcnkgcmVjYWxjdWxhdGlvbnMgdG8gYmUgdXAtdG8tZGF0ZS5cbiAgICAgICAgICAgICAqIEBldmVudCBjaC5DYXJvdXNlbCNyZWZyZXNoXG4gICAgICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVmcmVzaCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBsaXN0IHRvIHRoZSBzcGVjaWZpZWQgcGFnZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNhcm91c2VsLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlIFJlZmVyZW5jZSBvZiBwYWdlIHdoZXJlIHRoZSBsaXN0IGhhcyB0byBtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtjYXJvdXNlbH1cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICAgICAgLy8gR2V0dGVyXG4gICAgICAgIGlmIChwYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50UGFnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF2b2lkIHRvIG1vdmUgaWYgaXQncyBkaXNhYmxlZFxuICAgICAgICAvLyBBdm9pZCB0byBzZWxlY3QgdGhlIHNhbWUgcGFnZSB0aGF0IGlzIHNlbGVjdGVkIHlldFxuICAgICAgICAvLyBBdm9pZCB0byBtb3ZlIGJleW9uZCBmaXJzdCBhbmQgbGFzdCBwYWdlc1xuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQgfHwgcGFnZSA9PT0gdGhpcy5fY3VycmVudFBhZ2UgfHwgcGFnZSA8IDEgfHwgcGFnZSA+IHRoaXMuX3BhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBlcmZvcm0gdGhlc2UgdGFza3MgaW4gdGhlIGZvbGxvd2luZyBvcmRlcjpcbiAgICAgICAgLy8gVGFzayAxOiBNb3ZlIHRoZSBsaXN0IGZyb20gMCAoemVybyksIHRvIHBhZ2UgdG8gbW92ZSAocGFnZSBudW1iZXIgYmVnaW5uaW5nIGluIHplcm8pXG4gICAgICAgIHRoaXMuX3RyYW5zbGF0ZSgtdGhpcy5fcGFnZVdpZHRoICogKHBhZ2UgLSAxKSk7XG4gICAgICAgIC8vIFRhc2sgMjogVXBkYXRlIHNlbGVjdGVkIHRodW1ibmFpbCBvbiBwYWdpbmF0aW9uXG4gICAgICAgIHRoaXMuX3N3aXRjaFBhZ2luYXRpb24odGhpcy5fY3VycmVudFBhZ2UsIHBhZ2UpO1xuICAgICAgICAvLyBUYXNrIDM6IFVwZGF0ZSB2YWx1ZSBvZiBjdXJyZW50IHBhZ2VcbiAgICAgICAgdGhpcy5fY3VycmVudFBhZ2UgPSBwYWdlO1xuICAgICAgICAvLyBUYXNrIDQ6IENoZWNrIGZvciBhcnJvd3MgYmVoYXZpb3Igb24gZmlyc3QsIGxhc3QgYW5kIG1pZGRsZSBwYWdlc1xuICAgICAgICB0aGlzLl91cGRhdGVBcnJvd3MoKTtcbiAgICAgICAgLy8gVGFzayA1OiBBZGQgaXRlbXMgdG8gdGhlIGxpc3QsIGlmIGl0J3MgbmVjZXNzYXJ5XG4gICAgICAgIHRoaXMuX2xvYWRBc3luY0l0ZW1zKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29tcG9uZW50IG1vdmVzIHRvIGFub3RoZXIgcGFnZS5cbiAgICAgICAgICogQGV2ZW50IGNoLkNhcm91c2VsI3NlbGVjdFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJzZWxlY3RcIiBldmVudC5cbiAgICAgICAgICogY2Fyb3VzZWwub24oJ3NlbGVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIGFsZXJ0KCdDYXJvdXNlbCB3YXMgbW92ZWQuJyk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWl0KCdzZWxlY3QnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGxpc3QgdG8gdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAgICogQG1lbWJlcm9mISBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Y2Fyb3VzZWx9XG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5fY3VycmVudFBhZ2UgLSAxKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBjb21wb25lbnQgbW92ZXMgdG8gdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAgICAgICAqIEBldmVudCBjaC5DYXJvdXNlbCNwcmV2XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNhcm91c2VsLm9uKCdwcmV2JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgYWxlcnQoJ0Nhcm91c2VsIGhhcyBtb3ZlZCB0byB0aGUgcHJldmlvdXMgcGFnZS4nKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoJ3ByZXYnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGxpc3QgdG8gdGhlIG5leHQgcGFnZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNhcm91c2VsLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtjYXJvdXNlbH1cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLl9jdXJyZW50UGFnZSArIDEpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbXBvbmVudCBtb3ZlcyB0byB0aGUgbmV4dCBwYWdlLlxuICAgICAgICAgKiBAZXZlbnQgY2guQ2Fyb3VzZWwjbmV4dFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjYXJvdXNlbC5vbignbmV4dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogICAgIGFsZXJ0KCdDYXJvdXNlbCBoYXMgbW92ZWQgdG8gdGhlIG5leHQgcGFnZS4nKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoJ25leHQnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBhIENhcm91c2VsIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ2Fyb3VzZWwucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2Nhcm91c2VsfVxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5fZWwuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuX2Rpc2FibGVBcnJvd3MoZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICBwYXJlbnQuZW5hYmxlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIGEgQ2Fyb3VzZWwgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlcm9mISBjaC5DYXJvdXNlbC5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Y2Fyb3VzZWx9XG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5fZWwuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fZGlzYWJsZUFycm93cyh0cnVlLCB0cnVlKTtcblxuICAgICAgICBwYXJlbnQuZGlzYWJsZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhIENhcm91c2VsIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ2Fyb3VzZWwucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5fZWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5fc25pcHBldCwgdGhpcy5fZWwpO1xuXG4gICAgICAgIHRpbnkudHJpZ2dlcih3aW5kb3cuZG9jdW1lbnQsIGNoLm9ubGF5b3V0Y2hhbmdlKTtcblxuICAgICAgICBwYXJlbnQuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgY2guZmFjdG9yeShDYXJvdXNlbCk7XG5cbn0odGhpcywgdGhpcy5jaCkpO1xuXG4oZnVuY3Rpb24gKHdpbmRvdywgY2gpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG51bSA9IHdpbmRvdy5wYXJzZUludChvcHRpb25zLCAxMCk7XG5cbiAgICAgICAgaWYgKCF3aW5kb3cuaXNOYU4obnVtKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAnbWF4JzogbnVtXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ291bnRkb3duIGNvdW50cyB0aGUgbWF4aW11bSBvZiBjaGFyYWN0ZXJzIHRoYXQgdXNlciBjYW4gZW50ZXIgaW4gYSBmb3JtIGNvbnRyb2wuIENvdW50ZG93biBjb3VsZCBsaW1pdCB0aGUgcG9zc2liaWxpdHkgdG8gY29udGludWUgaW5zZXJ0aW5nIGNoYXJzZXQuXG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIGNoLkNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEEgSFRNTEVsZW1lbnQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIGNoLkNvdW50ZG93bi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gY3VzdG9taXplIGFuIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhdIE51bWJlciBvZiB0aGUgbWF4aW11bSBhbW91bnQgb2YgY2hhcmFjdGVycyB1c2VyIGNhbiBpbnB1dCBpbiBmb3JtIGNvbnRyb2wuIERlZmF1bHQ6IDUwMC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGx1cmFsXSBNZXNzYWdlIG9mIHJlbWFpbmluZyBhbW91bnQgb2YgY2hhcmFjdGVycywgd2hlbiBpdCdzIGRpZmZlcmVudCB0byAxLiBUaGUgdmFyaWFibGUgdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgdG8gYmUgcmVwbGFjZWQsIHNob3VsZCBiZSBhIGhhc2guIERlZmF1bHQ6IFwiIyBjaGFyYWN0ZXJzIGxlZnQuXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNpbmd1bGFyXSBNZXNzYWdlIG9mIHJlbWFpbmluZyBhbW91bnQgb2YgY2hhcmFjdGVycywgd2hlbiBpdCdzIG9ubHkgMS4gVGhlIHZhcmlhYmxlIHRoYXQgcmVwcmVzZW50cyB0aGUgbnVtYmVyIHRvIGJlIHJlcGxhY2VkLCBzaG91bGQgYmUgYSBoYXNoLiBEZWZhdWx0OiBcIiMgY2hhcmFjdGVyIGxlZnQuXCIuXG4gICAgICogQHJldHVybnMge2NvdW50ZG93bn0gUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBDb3VudGRvd24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgQ291bnRkb3duLlxuICAgICAqIHZhciBjb3VudGRvd24gPSBuZXcgY2guQ291bnRkb3duKFtlbF0sIFtvcHRpb25zXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgQ291bnRkb3duIHdpdGggY3VzdG9tIG9wdGlvbnMuXG4gICAgICogdmFyIGNvdW50ZG93biA9IG5ldyBjaC5Db3VudGRvd24oe1xuICAgICAqICAgICAnbWF4JzogMjUwLFxuICAgICAqICAgICAncGx1cmFsJzogJ0xlZnQ6ICMgY2hhcmFjdGVycy4nLFxuICAgICAqICAgICAnc2luZ3VsYXInOiAnTGVmdDogIyBjaGFyYWN0ZXIuJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IENvdW50ZG93biB1c2luZyB0aGUgc2hvcnRoYW5kIHdheSAobWF4IGFzIHBhcmFtZXRlcikuXG4gICAgICogdmFyIGNvdW50ZG93biA9IG5ldyBjaC5Db3VudGRvd24oeydtYXgnOiA1MDB9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb3VudGRvd24oZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5faW5pdChlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHlvdSBkZWZpbmUgYW4gaW5pdGlhbGl6ZSBtZXRob2QsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhIG5ldyBDb3VudGRvd24gaXMgY3JlYXRlZC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiEgY2guQ291bnRkb3duLnByb3RvdHlwZVxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHJlYWR5IHRvIHVzZS5cbiAgICAgICAgICogQGV2ZW50IGNoLkNvdW50ZG93biNyZWFkeVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJyZWFkeVwiIGV2ZW50LlxuICAgICAgICAgKiBjb3VudGRvd24ub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aGF0LmVtaXQoJ3JlYWR5Jyk7IH0sIDUwKTtcbiAgICB9XG5cbiAgICAvLyBJbmhlcml0YW5jZVxuICAgIHRpbnkuaW5oZXJpdHMoQ291bnRkb3duLCBjaC5Db21wb25lbnQpO1xuXG4gICAgdmFyIHBhcmVudCA9IENvdW50ZG93bi5zdXBlcl8ucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNvdW50ZG93bi5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIENvdW50ZG93bi5wcm90b3R5cGUubmFtZSA9ICdjb3VudGRvd24nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQG1lbWJlcm9mISBjaC5Db3VudGRvd24ucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgQ291bnRkb3duLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvdW50ZG93bjtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gYnkgZGVmYXVsdC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ291bnRkb3duLnByb3RvdHlwZS5fZGVmYXVsdHMgPSB7XG4gICAgICAgICdwbHVyYWwnOiAnIyBjaGFyYWN0ZXJzIGxlZnQuJyxcbiAgICAgICAgJ3Npbmd1bGFyJzogJyMgY2hhcmFjdGVyIGxlZnQuJyxcbiAgICAgICAgJ21heCc6IDUwMFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IGluc3RhbmNlIG9mIENvdW50ZG93biBhbmQgbWVyZ2UgY3VzdG9tIG9wdGlvbnMgd2l0aCBkZWZhdWx0cyBvcHRpb25zLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQ291bnRkb3duLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge2NvdW50ZG93bn1cbiAgICAgKi9cbiAgICBDb3VudGRvd24ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENhbGwgdG8gaXRzIHBhcmVudCBpbml0IG1ldGhvZFxuICAgICAgICBwYXJlbnQuX2luaXQuY2FsbCh0aGlzLCBlbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZSB0aGUgXCJpZFwiIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtZXNzYWdlSUQgPSAnY2gtY291bnRkb3duLW1lc3NhZ2UtJyArIHRoYXQudWlkLFxuXG4gICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2luZ3VsYXIgb3IgUGx1cmFsIG1lc3NhZ2UgZGVwZW5kaW5nIG9uIGFtb3VudCBvZiByZW1haW5pbmcgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtZXNzYWdlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY291bnRkb3duIHRyaWdnZXIuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MVGV4dEFyZWFFbGVtZW50fVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBHZXRzIHRoZSBjb3VudGRvd24gdHJpZ2dlci5cbiAgICAgICAgICogY291bnRkb3duLnRyaWdnZXI7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIgPSB0aGlzLl9lbDtcbiAgICAgICAgJ2tleXVwIGtleXByZXNzIGtleWRvd24gaW5wdXQgcGFzdGUgY3V0Jy5zcGxpdCgnICcpXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGlueS5vbih0aGF0LnRyaWdnZXIsIG5hbWUsIGZ1bmN0aW9uICgpIHsgdGhhdC5fY291bnQoKTsgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW1vdW50IG9mIGZyZWUgY2hhcmFjdGVycyB1bnRpbCBmdWxsIHRoZSBmaWVsZC5cbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoYXQuX3JlbWFpbmluZyA9IHRoYXQuX29wdGlvbnMubWF4IC0gdGhhdC5fY29udGVudExlbmd0aCgpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbWVzc2FnZVxuICAgICAgICBtZXNzYWdlID0gKCh0aGF0Ll9yZW1haW5pbmcgPT09IDEpID8gdGhhdC5fb3B0aW9ucy5zaW5ndWxhciA6IHRoYXQuX29wdGlvbnMucGx1cmFsKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvdW50ZG93biBjb250YWluZXIuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MUGFyYWdyYXBoRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoYXQuY29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aW55LnBhcmVudCh0aGF0Ll9lbCk7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCAnPHNwYW4gY2xhc3M9XCJjaC1jb3VudGRvd24gY2gtZm9ybS1oaW50XCIgaWQ9XCInICsgbWVzc2FnZUlEICsgJ1wiPicgKyBtZXNzYWdlLnJlcGxhY2UoJyMnLCB0aGF0Ll9yZW1haW5pbmcpICsgJzwvc3Bhbj4nKTtcblxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKCcjJyArIG1lc3NhZ2VJRCk7XG4gICAgICAgIH0oKSk7XG5cbiAgICAgICAgdGhpcy5vbignZGlzYWJsZScsIHRoaXMuX3JlbW92ZUVycm9yKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHZhbHVlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBDb3VudGRvd24ucHJvdG90eXBlLl9jb250ZW50TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWwudmFsdWUubGVuZ3RoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGlucHV0IG9mIGRhdGEgb24gZm9ybSBjb250cm9sIGFuZCB1cGRhdGVzIHJlbWFpbmluZyBhbW91bnQgb2YgY2hhcmFjdGVycyBvciBsaW1pdHMgdGhlIGNvbnRlbnQgbGVuZ3RoLiBBbHNvLCBjaGFuZ2UgdGhlIHZpc2libGUgbWVzc2FnZSBvZiByZW1haW5pbmcgY2hhcmFjdGVycy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtjb3VudGRvd259XG4gICAgICovXG4gICAgQ291bnRkb3duLnByb3RvdHlwZS5fY291bnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9jb250ZW50TGVuZ3RoKCksXG4gICAgICAgICAgICBtZXNzYWdlO1xuXG4gICAgICAgIHRoaXMuX3JlbWFpbmluZyA9IHRoaXMuX29wdGlvbnMubWF4IC0gbGVuZ3RoO1xuXG4gICAgICAgIC8vIExpbWl0IENvdW50IGFsZXJ0IHRoZSB1c2VyXG4gICAgICAgIGlmIChsZW5ndGggPD0gdGhpcy5fb3B0aW9ucy5tYXgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2V4Y2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4Y2VlZGVkIGZsYWdcbiAgICAgICAgICAgICAgICB0aGlzLl9leGNlZWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUVycm9yKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiB0aGlzLl9vcHRpb25zLm1heCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgbGVuZ2h0IG9mIGNoYXJhY3RlcnMgaXMgZXhjZWVkZWQuXG4gICAgICAgICAgICAgKiBAZXZlbnQgY2guQ291bnRkb3duI2V4Y2VlZFxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcImV4Y2VlZFwiIGV2ZW50LlxuICAgICAgICAgICAgICogY291bnRkb3duLm9uKCdleGNlZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdleGNlZWQnKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGV4Y2VlZGVkIGZsYWdcbiAgICAgICAgICAgIHRoaXMuX2V4Y2VlZGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyLnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcbiAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3ModGhpcy50cmlnZ2VyLCAnY2gtdmFsaWRhdGlvbi1lcnJvcicpO1xuXG4gICAgICAgICAgICB0aW55LmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCAnY2gtY291bnRkb3duLWV4Y2VlZGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGFuZ2UgdmlzaWJsZSBtZXNzYWdlIG9mIHJlbWFpbmluZyBjaGFyYWN0ZXJzXG4gICAgICAgIC8vIFNpbmd1bGFyIG9yIFBsdXJhbCBtZXNzYWdlIGRlcGVuZGluZyBvbiBhbW91bnQgb2YgcmVtYWluaW5nIGNoYXJhY3RlcnNcbiAgICAgICAgbWVzc2FnZSA9ICh0aGlzLl9yZW1haW5pbmcgIT09IDEgPyB0aGlzLl9vcHRpb25zLnBsdXJhbCA6IHRoaXMuX29wdGlvbnMuc2luZ3VsYXIpLnJlcGxhY2UoL1xcIy9nLCB0aGlzLl9yZW1haW5pbmcpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBET00gdGV4dFxuICAgICAgICB0aGlzLmNvbnRhaW5lci5pbm5lclRleHQgID0gbWVzc2FnZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICAgLyoqXG4gICAgICogUHJvY2VzcyBpbnB1dCBvZiBkYXRhIG9uIGZvcm0gY29udHJvbCBhbmQgdXBkYXRlcyByZW1haW5pbmcgYW1vdW50IG9mIGNoYXJhY3RlcnMgb3IgbGltaXRzIHRoZSBjb250ZW50IGxlbmd0aC4gQWxzbywgY2hhbmdlIHRoZSB2aXNpYmxlIG1lc3NhZ2Ugb2YgcmVtYWluaW5nIGNoYXJhY3RlcnMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7Y291bnRkb3dufVxuICAgICAqL1xuICAgIENvdW50ZG93bi5wcm90b3R5cGUuX3JlbW92ZUVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aW55LnJlbW92ZUNsYXNzKHRoaXMudHJpZ2dlciwgJ2NoLXZhbGlkYXRpb24tZXJyb3InKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyLnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgdGlueS5yZW1vdmVDbGFzcyh0aGlzLmNvbnRhaW5lciwgJ2NoLWNvdW50ZG93bi1leGNlZWRlZCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhIENvdW50ZG93biBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkNvdW50ZG93bi5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIERlc3Ryb3kgYSBjb3VudGRvd25cbiAgICAgKiBjb3VudGRvd24uZGVzdHJveSgpO1xuICAgICAqIC8vIEVtcHR5IHRoZSBjb3VudGRvd24gcmVmZXJlbmNlXG4gICAgICogY291bnRkb3duID0gdW5kZWZpbmVkO1xuICAgICAqL1xuICAgIENvdW50ZG93bi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSB0aW55LnBhcmVudCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIpO1xuXG4gICAgICAgIHRpbnkudHJpZ2dlcih3aW5kb3cuZG9jdW1lbnQsIGNoLm9ubGF5b3V0Y2hhbmdlKTtcblxuICAgICAgICBwYXJlbnQuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgLy8gRmFjdG9yaXplXG4gICAgY2guZmFjdG9yeShDb3VudGRvd24sIG5vcm1hbGl6ZU9wdGlvbnMpO1xuXG59KHRoaXMsIHRoaXMuY2gpKTtcblxuKGZ1bmN0aW9uICh3aW5kb3csIGNoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogRGF0ZXBpY2tlciBsZXRzIHlvdSBzZWxlY3QgZGF0ZXMuXG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIGNoLkNvbXBvbmVudFxuICAgICAqIEByZXF1aXJlcyBjaC5DYWxlbmRhclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtlbF0gQSBIVE1MRWxlbWVudCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgY2guRGF0ZXBpY2tlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gY3VzdG9taXplIGFuIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5mb3JtYXRdIFNldHMgdGhlIGRhdGUgZm9ybWF0LiBEZWZhdWx0OiBcIkREL01NL1lZWVlcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2VsZWN0ZWRdIFNldHMgYSBkYXRlIHRoYXQgc2hvdWxkIGJlIHNlbGVjdGVkIGJ5IGRlZmF1bHQuIERlZmF1bHQ6IFwidG9kYXlcIi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZnJvbV0gU2V0IGEgbWluaW11bSBzZWxlY3RhYmxlIGRhdGUuIFRoZSBmb3JtYXQgb2YgdGhlIGdpdmVuIGRhdGUgc2hvdWxkIGJlIFwiWVlZWS9NTS9ERFwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50b10gU2V0IGEgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuIFRoZSBmb3JtYXQgb2YgdGhlIGdpdmVuIGRhdGUgc2hvdWxkIGJlIFwiWVlZWS9NTS9ERFwiLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1vbnRoc05hbWVzXSBBIGNvbGxlY3Rpb24gb2YgbW9udGhzIG5hbWVzLiBEZWZhdWx0OiBbXCJFbmVyb1wiLCAuLi4gLCBcIkRpY2llbWJyZVwiXS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy53ZWVrZGF5c10gQSBjb2xsZWN0aW9uIG9mIHdlZWtkYXlzLiBEZWZhdWx0OiBbXCJEb21cIiwgLi4uICwgXCJTYWJcIl0uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5oaWRkZW5ieV0gRGV0ZXJtaW5lcyBob3cgdG8gaGlkZSB0aGUgY29tcG9uZW50LiBZb3UgbXVzdCB1c2U6IFwiYnV0dG9uXCIsIFwicG9pbnRlcnNcIiwgXCJwb2ludGVybGVhdmVcIiwgXCJhbGxcIiBvciBcIm5vbmVcIi4gRGVmYXVsdDogXCJwb2ludGVyc1wiLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtvcHRpb25zLmNvbnRleHRdIEl0J3MgYSByZWZlcmVuY2UgdG8gcG9zaXRpb24gYW5kIHNpemUgb2YgZWxlbWVudCB0aGF0IHdpbGwgYmUgY29uc2lkZXJlZCB0byBjYXJyeSBvdXQgdGhlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zaWRlXSBUaGUgc2lkZSBvcHRpb24gd2hlcmUgdGhlIHRhcmdldCBlbGVtZW50IHdpbGwgYmUgcG9zaXRpb25lZC4gWW91IG11c3QgdXNlOiBcImxlZnRcIiwgXCJyaWdodFwiLCBcInRvcFwiLCBcImJvdHRvbVwiIG9yIFwiY2VudGVyXCIuIERlZmF1bHQ6IFwiYm90dG9tXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFsaWduXSBUaGUgYWxpZ24gb3B0aW9ucyB3aGVyZSB0aGUgdGFyZ2V0IGVsZW1lbnQgd2lsbCBiZSBwb3NpdGlvbmVkLiBZb3UgbXVzdCB1c2U6IFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wXCIsIFwiYm90dG9tXCIgb3IgXCJjZW50ZXJcIi4gRGVmYXVsdDogXCJjZW50ZXJcIi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0WF0gRGlzdGFuY2UgdG8gZGlzcGxhY2UgdGhlIHRhcmdldCBob3Jpem9udGFsbHkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFldIERpc3RhbmNlIHRvIGRpc3BsYWNlIHRoZSB0YXJnZXQgdmVydGljYWxseS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb25dIFRoZSB0eXBlIG9mIHBvc2l0aW9uaW5nIHVzZWQuIFlvdSBtdXN0IHVzZTogXCJhYnNvbHV0ZVwiIG9yIFwiZml4ZWRcIi4gRGVmYXVsdDogXCJhYnNvbHV0ZVwiLlxuICAgICAqIEByZXR1cm5zIHtkYXRlcGlja2VyfSBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIERhdGVwaWNrZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgRGF0ZXBpY2tlci5cbiAgICAgKiB2YXIgZGF0ZXBpY2tlciA9IG5ldyBjaC5EYXRlcGlja2VyKFtzZWxlY3Rvcl0sIFtvcHRpb25zXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgRGF0ZXBpY2tlciB3aXRoIGN1c3RvbSBvcHRpb25zLlxuICAgICAqIHZhciBkYXRlcGlja2VyID0gbmV3IGNoLkRhdGVwaWNrZXIoe1xuICAgICAqICAgICBcImZvcm1hdFwiOiBcIk1NL0REL1lZWVlcIixcbiAgICAgKiAgICAgXCJzZWxlY3RlZFwiOiBcIjIwMTEvMTIvMjVcIixcbiAgICAgKiAgICAgXCJmcm9tXCI6IFwiMjAxMC8xMi8yNVwiLFxuICAgICAqICAgICBcInRvXCI6IFwiMjAxMi8xMi8yNVwiLFxuICAgICAqICAgICBcIm1vbnRoc05hbWVzXCI6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXSxcbiAgICAgKiAgICAgXCJ3ZWVrZGF5c1wiOiBbXCJTdVwiLCBcIk1vXCIsIFwiVHVcIiwgXCJXZVwiLCBcIlRodVwiLCBcIkZyXCIsIFwiU2FcIl1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRlcGlja2VyKHNlbGVjdG9yLCBvcHRpb25zKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2luaXQoc2VsZWN0b3IsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB5b3UgZGVmaW5lIGFuIGluaXRpYWxpemUgbWV0aG9kLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYSBuZXcgRGF0ZXBpY2tlciBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mISBjaC5EYXRlcGlja2VyLnByb3RvdHlwZVxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHJlYWR5IHRvIHVzZS5cbiAgICAgICAgICogQGV2ZW50IGNoLkRhdGVwaWNrZXIjcmVhZHlcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwicmVhZHlcIiBldmVudC5cbiAgICAgICAgICogZGF0ZXBpY2tlci5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRoYXQuZW1pdCgncmVhZHknKTsgfSwgNTApO1xuICAgIH1cblxuICAgIC8vIEluaGVyaXRhbmNlXG4gICAgdGlueS5pbmhlcml0cyhEYXRlcGlja2VyLCBjaC5Db21wb25lbnQpO1xuXG4gICAgdmFyIHBhcmVudCA9IERhdGVwaWNrZXIuc3VwZXJfLnByb3RvdHlwZSxcbiAgICAgICAgLy8gQ3JlYXRlcyBtZXRob2RzIGVuYWJsZSBhbmQgZGlzYWJsZSBpbnRvIHRoZSBwcm90b3R5cGUuXG4gICAgICAgIG1ldGhvZHMgPSBbJ2VuYWJsZScsICdkaXNhYmxlJ10sXG4gICAgICAgIGxlbiA9IG1ldGhvZHMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlTWV0aG9kcyhtZXRob2QpIHtcbiAgICAgICAgRGF0ZXBpY2tlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdGhpcy5fcG9wb3ZlclttZXRob2RdKCk7XG5cbiAgICAgICAgICAgIHBhcmVudFttZXRob2RdLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQG1lbWJlcm9mISBjaC5EYXRlcGlja2VyLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBZb3UgY2FuIHJlYWNoIHRoZSBhc3NvY2lhdGVkIGluc3RhbmNlLlxuICAgICAqIHZhciBkYXRlcGlja2VyID0gJChzZWxlY3RvcikuZGF0YSgnZGF0ZXBpY2tlcicpO1xuICAgICAqL1xuICAgIERhdGVwaWNrZXIucHJvdG90eXBlLm5hbWUgPSAnZGF0ZXBpY2tlcic7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkRhdGVwaWNrZXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgRGF0ZXBpY2tlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRlcGlja2VyO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEYXRlcGlja2VyLnByb3RvdHlwZS5fZGVmYXVsdHMgPSB7XG4gICAgICAgICdmb3JtYXQnOiAnREQvTU0vWVlZWScsXG4gICAgICAgICdzaWRlJzogJ2JvdHRvbScsXG4gICAgICAgICdhbGlnbic6ICdjZW50ZXInLFxuICAgICAgICAnaGlkZGVuYnknOiAncG9pbnRlcnMnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSBuZXcgaW5zdGFuY2Ugb2YgRGF0ZXBpY2tlciBhbmQgbWVyZ2UgY3VzdG9tIG9wdGlvbnMgd2l0aCBkZWZhdWx0cyBvcHRpb25zLlxuICAgICAqIEBtZW1iZXJvZiEgY2guRGF0ZXBpY2tlci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtkYXRlcGlja2VyfVxuICAgICAqL1xuICAgIERhdGVwaWNrZXIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENhbGwgdG8gaXRzIHBhcmVudCBpbml0IG1ldGhvZFxuICAgICAgICBwYXJlbnQuX2luaXQuY2FsbCh0aGlzLCBzZWxlY3Rvciwgb3B0aW9ucyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0ZXBpY2tlciBpbnB1dCBmaWVsZC5cbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWVsZCA9IHRoaXMuX2VsO1xuICAgICAgICB0aGlzLmZpZWxkLmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJlbmQnLCAnPGkgcm9sZT1cImJ1dHRvblwiIGNsYXNzPVwiY2gtZGF0ZXBpY2tlci10cmlnZ2VyIGNoLWljb24tY2FsZW5kYXJcIj48L2k+Jyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRlcGlja2VyIHRyaWdnZXIuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlciA9IHRpbnkubmV4dCh0aGlzLmZpZWxkKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBDYWxlbmRhciBjb21wb25lbnQgaW5zdGFuY2VkLlxuICAgICAgICAgKiBAdHlwZSB7Y2guQ2FsZW5kYXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jYWxlbmRhciA9IG5ldyBjaC5DYWxlbmRhcihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgb3B0aW9ucyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgUG9wb3ZlciBjb21wb25lbnQgaW5zdGFuY2VkLlxuICAgICAgICAgKiBAdHlwZSB7Y2guUG9wb3Zlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3BvcG92ZXIgPSBuZXcgY2guUG9wb3Zlcih0aGlzLnRyaWdnZXIsIHtcbiAgICAgICAgICAgICdfY2xhc3NOYW1lJzogJ2NoLWRhdGVwaWNrZXIgY2gtY29uZScsXG4gICAgICAgICAgICAnX2FyaWFSb2xlJzogJ3Rvb2x0aXAnLFxuICAgICAgICAgICAgJ2NvbnRlbnQnOiB0aGlzLl9jYWxlbmRhci5jb250YWluZXIsXG4gICAgICAgICAgICAnc2lkZSc6IHRoaXMuX29wdGlvbnMuc2lkZSxcbiAgICAgICAgICAgICdhbGlnbic6IHRoaXMuX29wdGlvbnMuYWxpZ24sXG4gICAgICAgICAgICAnb2Zmc2V0WCc6IDEsXG4gICAgICAgICAgICAnb2Zmc2V0WSc6IDEwLFxuICAgICAgICAgICAgJ3Nob3duYnknOiAncG9pbnRlcnRhcCcsXG4gICAgICAgICAgICAnaGlkZGVuYnknOiB0aGlzLl9vcHRpb25zLmhpZGRlbmJ5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRpbnkub24odGhpcy5fcG9wb3Zlci5fY29udGVudCwgY2gub25wb2ludGVydGFwLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgICAgICAgLy8gRGF5IHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKGVsLm5vZGVOYW1lID09PSAnVEQnICYmIGVsLmNsYXNzTmFtZS5pbmRleE9mKCdjaC1jYWxlbmRhci1kaXNhYmxlZCcpID09PSAtMSAmJiBlbC5jbGFzc05hbWUuaW5kZXhPZignY2gtY2FsZW5kYXItb3RoZXInKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnBpY2soZWwuaW5uZXJIVE1MKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZpZWxkLnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsICdjaC1wb3BvdmVyLScgKyB0aGlzLl9wb3BvdmVyLnVpZCk7XG5cbiAgICAgICAgLy8gQ2hhbmdlIHR5cGUgb2YgaW5wdXQgdG8gXCJ0ZXh0XCJcbiAgICAgICAgdGhpcy5maWVsZC50eXBlID0gJ3RleHQnO1xuXG4gICAgICAgIC8vIENoYW5nZSB2YWx1ZSBvZiBpbnB1dCBpZiB0aGVyZSBhcmUgYSBzZWxlY3RlZCBkYXRlXG4gICAgICAgIHRoaXMuZmllbGQudmFsdWUgPSAodGhpcy5fb3B0aW9ucy5zZWxlY3RlZCkgPyB0aGlzLl9jYWxlbmRhci5zZWxlY3QoKSA6IHRoaXMuZmllbGQudmFsdWU7XG5cbiAgICAgICAgLy8gSGlkZSBwb3BvdmVyXG4gICAgICAgIHRoaXMub24oJ2Rpc2FibGUnLCB0aGlzLmhpZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgZGF0ZXBpY2tlci5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkRhdGVwaWNrZXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2RhdGVwaWNrZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaG93cyBhIGRhdGVwaWNrZXIuXG4gICAgICogZGF0ZXBpY2tlci5zaG93KCk7XG4gICAgICovXG4gICAgRGF0ZXBpY2tlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9wb3Zlci5zaG93KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBhIGRhdGVwaWNrZXIgaXMgc2hvd24uXG4gICAgICAgICAqIEBldmVudCBjaC5EYXRlcGlja2VyI3Nob3dcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwic2hvd1wiIGV2ZW50LlxuICAgICAgICAgKiBkYXRlcGlja2VyLm9uKCdzaG93JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWl0KCdzaG93Jyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBkYXRlcGlja2VyLlxuICAgICAqIEBtZW1iZXJvZiEgY2guRGF0ZXBpY2tlci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7ZGF0ZXBpY2tlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNob3dzIGEgZGF0ZXBpY2tlci5cbiAgICAgKiBkYXRlcGlja2VyLmhpZGUoKTtcbiAgICAgKi9cbiAgICBEYXRlcGlja2VyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wb3BvdmVyLmhpZGUoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIGEgZGF0ZXBpY2tlciBpcyBoaWRkZW4uXG4gICAgICAgICAqIEBldmVudCBjaC5EYXRlcGlja2VyI2hpZGVcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwiaGlkZVwiIGV2ZW50LlxuICAgICAgICAgKiBkYXRlcGlja2VyLm9uKCdoaWRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWl0KCdoaWRlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSBzcGVjaWZpYyBkYXkgaW50byBjdXJyZW50IG1vbnRoIGFuZCB5ZWFyLlxuICAgICAqIEBtZW1iZXJvZiEgY2guRGF0ZXBpY2tlci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7KFN0cmluZyB8IE51bWJlcil9IGRheSBBIGdpdmVuIGRheSB0byBzZWxlY3QuXG4gICAgICogQHJldHVybnMge2RhdGVwaWNrZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTZWxlY3QgYSBzcGVjaWZpYyBkYXkuXG4gICAgICogZGF0ZXBpY2tlci5waWNrKDI4KTtcbiAgICAgKi9cbiAgICBEYXRlcGlja2VyLnByb3RvdHlwZS5waWNrID0gZnVuY3Rpb24gKGRheSkge1xuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgZGF5IGFuZCB1cGRhdGUgaW5wdXQgdmFsdWUgd2l0aCBzZWxlY3RlZCBkYXRlXG4gICAgICAgIHRoaXMuZmllbGQudmFsdWUgPSBbdGhpcy5fY2FsZW5kYXIuX2RhdGVzLmN1cnJlbnQueWVhciwgdGhpcy5fY2FsZW5kYXIuX2RhdGVzLmN1cnJlbnQubW9udGgsIGRheV0uam9pbignLycpO1xuXG4gICAgICAgIC8vIEhpZGUgZmxvYXRcbiAgICAgICAgdGhpcy5fcG9wb3Zlci5oaWRlKCk7XG5cbiAgICAgICAgLy8gU2VsZWN0IGEgZGF0ZVxuICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmZpZWxkLnZhbHVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhIHNwZWNpZmljIGRhdGUgb3IgcmV0dXJucyB0aGUgc2VsZWN0ZWQgZGF0ZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkRhdGVwaWNrZXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRlXSBBIGdpdmVuIGRhdGUgdG8gc2VsZWN0LiBUaGUgZm9ybWF0IG9mIHRoZSBnaXZlbiBkYXRlIHNob3VsZCBiZSBcIllZWVkvTU0vRERcIi5cbiAgICAgKiBAcmV0dXJucyB7KGRhdGVwaWNrZXIgfCBTdHJpbmcpfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gUmV0dXJucyB0aGUgc2VsZWN0ZWQgZGF0ZS5cbiAgICAgKiBkYXRlcGlja2VyLnNlbGVjdCgpO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gU2VsZWN0IGEgc3BlY2lmaWMgZGF0ZS5cbiAgICAgKiBkYXRlcGlja2VyLnNlbGVjdCgnMjAxNC8wNS8yOCcpO1xuICAgICAqL1xuICAgIERhdGVwaWNrZXIucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChkYXRlKSB7XG5cbiAgICAgICAvLyBTZXR0ZXJcbiAgICAgICAvLyBTZWxlY3QgdGhlIGRheSBhbmQgdXBkYXRlIGlucHV0IHZhbHVlIHdpdGggc2VsZWN0ZWQgZGF0ZVxuICAgICAgICBpZiAoZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsZW5kYXIuc2VsZWN0KGRhdGUpO1xuICAgICAgICAgICAgdGhpcy5maWVsZC52YWx1ZSA9IHRoaXMuX2NhbGVuZGFyLnNlbGVjdCgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWQuXG4gICAgICAgICAgICAgKiBAZXZlbnQgY2guRGF0ZXBpY2tlciNzZWxlY3RcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJzZWxlY3RcIiBldmVudC5cbiAgICAgICAgICAgICAqIGRhdGVwaWNrZXIub24oJ3NlbGVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3NlbGVjdCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldHRlclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsZW5kYXIuc2VsZWN0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0ZSBvZiB0b2RheVxuICAgICAqIEBtZW1iZXJvZiEgY2guRGF0ZXBpY2tlci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZGF0ZSBvZiB0b2RheVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gR2V0IHRoZSBkYXRlIG9mIHRvZGF5LlxuICAgICAqIHZhciB0b2RheSA9IGRhdGVwaWNrZXIuZ2V0VG9kYXkoKTtcbiAgICAgKi9cbiAgICBEYXRlcGlja2VyLnByb3RvdHlwZS5nZXRUb2RheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGVuZGFyLmdldFRvZGF5KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRvIHRoZSBuZXh0IG1vbnRoLlxuICAgICAqIEBtZW1iZXJvZiEgY2guRGF0ZXBpY2tlci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7ZGF0ZXBpY2tlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIE1vdmVzIHRvIHRoZSBuZXh0IG1vbnRoLlxuICAgICAqIGRhdGVwaWNrZXIubmV4dE1vbnRoKCk7XG4gICAgICovXG4gICAgRGF0ZXBpY2tlci5wcm90b3R5cGUubmV4dE1vbnRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYWxlbmRhci5uZXh0TW9udGgoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIGEgbmV4dCBtb250aCBpcyBzaG93bi5cbiAgICAgICAgICogQGV2ZW50IGNoLkRhdGVwaWNrZXIjbmV4dG1vbnRoXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcIm5leHRtb250aFwiIGV2ZW50LlxuICAgICAgICAgKiBkYXRlcGlja2VyLm9uKCduZXh0bW9udGgnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoJ25leHRtb250aCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIHRoZSBwcmV2aW91cyBtb250aC5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkRhdGVwaWNrZXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2RhdGVwaWNrZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBNb3ZlcyB0byB0aGUgcHJldiBtb250aC5cbiAgICAgKiBkYXRlcGlja2VyLnByZXZNb250aCgpO1xuICAgICAqL1xuICAgIERhdGVwaWNrZXIucHJvdG90eXBlLnByZXZNb250aCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLl9jYWxlbmRhci5wcmV2TW9udGgoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIGEgcHJldmlvdXMgbW9udGggaXMgc2hvd24uXG4gICAgICAgICAqIEBldmVudCBjaC5EYXRlcGlja2VyI3ByZXZtb250aFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJwcmV2bW9udGhcIiBldmVudC5cbiAgICAgICAgICogZGF0ZXBpY2tlci5vbigncHJldm1vbnRoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWl0KCdwcmV2bW9udGgnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZSB0byB0aGUgbmV4dCB5ZWFyLlxuICAgICAqIEBtZW1iZXJvZiEgY2guRGF0ZXBpY2tlci5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7ZGF0ZXBpY2tlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIE1vdmVzIHRvIHRoZSBuZXh0IHllYXIuXG4gICAgICogZGF0ZXBpY2tlci5uZXh0WWVhcigpO1xuICAgICAqL1xuICAgIERhdGVwaWNrZXIucHJvdG90eXBlLm5leHRZZWFyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyLm5leHRZZWFyKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBhIG5leHQgeWVhciBpcyBzaG93bi5cbiAgICAgICAgICogQGV2ZW50IGNoLkRhdGVwaWNrZXIjbmV4dHllYXJcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwibmV4dHllYXJcIiBldmVudC5cbiAgICAgICAgICogZGF0ZXBpY2tlci5vbignbmV4dHllYXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoJ25leHR5ZWFyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gdGhlIHByZXZpb3VzIHllYXIuXG4gICAgICogQG1lbWJlcm9mISBjaC5EYXRlcGlja2VyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtkYXRlcGlja2VyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTW92ZXMgdG8gdGhlIHByZXYgeWVhci5cbiAgICAgKiBkYXRlcGlja2VyLnByZXZZZWFyKCk7XG4gICAgICovXG4gICAgRGF0ZXBpY2tlci5wcm90b3R5cGUucHJldlllYXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5fY2FsZW5kYXIucHJldlllYXIoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIGEgcHJldmlvdXMgeWVhciBpcyBzaG93bi5cbiAgICAgICAgICogQGV2ZW50IGNoLkRhdGVwaWNrZXIjcHJldnllYXJcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwicHJldnllYXJcIiBldmVudC5cbiAgICAgICAgICogZGF0ZXBpY2tlci5vbigncHJldnllYXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoJ3ByZXZ5ZWFyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBEYXRlcGlja2VyIHRvIGRhdGUgb2YgdG9kYXlcbiAgICAgKiBAbWVtYmVyb2YhIGNoLkRhdGVwaWNrZXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2RhdGVwaWNrZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBSZXNzZXQgdGhlIGRhdGVwaWNrZXJcbiAgICAgKiBkYXRlcGlja2VyLnJlc2V0KCk7XG4gICAgICovXG4gICAgRGF0ZXBpY2tlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLy8gRGVsZXRlIGlucHV0IHZhbHVlXG4gICAgICAgIHRoaXMuZmllbGQudmFsdWUgPSAnJztcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIucmVzZXQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlciB3aGVuIHRoZSBkYXRlcGlja2VyIGlzIHJlc2V0ZWQuXG4gICAgICAgICAqIEBldmVudCBjaC5EYXRlcGlja2VyI3Jlc2V0XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcInJlc2V0XCIgZXZlbnQuXG4gICAgICAgICAqIGRhdGVwaWNrZXIub24oJ3Jlc2V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbWl0KCdyZXNldCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkRhdGVwaWNrZXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGUgQSBnaXZlbiBkYXRlIHRvIHNldCBhcyBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS4gVGhlIGZvcm1hdCBvZiB0aGUgZ2l2ZW4gZGF0ZSBzaG91bGQgYmUgXCJZWVlZL01NL0REXCIuXG4gICAgICogQHJldHVybnMge2RhdGVwaWNrZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTZXQgYSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS5cbiAgICAgKiBkYXRlcGlja2VyLnNldEZyb20oJzIwMTAvMDUvMjgnKTtcbiAgICAgKi9cbiAgICBEYXRlcGlja2VyLnByb3RvdHlwZS5zZXRGcm9tID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIuc2V0RnJvbShkYXRlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuXG4gICAgICogQG1lbWJlcm9mISBjaC5EYXRlcGlja2VyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRlIEEgZ2l2ZW4gZGF0ZSB0byBzZXQgYXMgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuIFRoZSBmb3JtYXQgb2YgdGhlIGdpdmVuIGRhdGUgc2hvdWxkIGJlIFwiWVlZWS9NTS9ERFwiLlxuICAgICAqIEByZXR1cm5zIHtkYXRlcGlja2VyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gU2V0IGEgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuXG4gICAgICogZGF0ZXBpY2tlci5zZXRUbygnMjAxNC8wNS8yOCcpO1xuICAgICAqL1xuICAgIERhdGVwaWNrZXIucHJvdG90eXBlLnNldFRvID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIuc2V0VG8oZGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZXBpY2tlci5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkRhdGVwaWNrZXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2RhdGVwaWNrZXJ9IFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgRGF0ZXBpY2tlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEVuYWJsaW5nIGFuIGluc3RhbmNlIG9mIERhdGVwaWNrZXIuXG4gICAgICogZGF0ZXBpY2tlci5lbmFibGUoKTtcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIGFuIGluc3RhbmNlIG9mIERhdGVwaWNrZXIuXG4gICAgICogQG1lbWJlcm9mISBjaC5EYXRlcGlja2VyLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtkYXRlcGlja2VyfSBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIERhdGVwaWNrZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBEaXNhYmxpbmcgYW4gaW5zdGFuY2Ugb2YgRGF0ZXBpY2tlci5cbiAgICAgKiBkYXRlcGlja2VyLmRpc2FibGUoKTtcbiAgICAgKi9cbiAgICB3aGlsZSAobGVuKSB7XG4gICAgICAgIGNyZWF0ZU1ldGhvZHMobWV0aG9kc1tsZW4gLT0gMV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGEgRGF0ZXBpY2tlciBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkRhdGVwaWNrZXIucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBEZXN0cm95aW5nIGFuIGluc3RhbmNlIG9mIERhdGVwaWNrZXIuXG4gICAgICogZGF0ZXBpY2tlci5kZXN0cm95KCk7XG4gICAgICovXG4gICAgRGF0ZXBpY2tlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aW55LnBhcmVudCh0aGlzLnRyaWdnZXIpLnJlbW92ZUNoaWxkKHRoaXMudHJpZ2dlcik7XG5cbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG4gICAgICAgIHRoaXMuX2VsLnR5cGUgPSAnZGF0ZSc7XG5cbiAgICAgICAgdGhpcy5fcG9wb3Zlci5kZXN0cm95KCk7XG5cbiAgICAgICAgcGFyZW50LmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgLy8gRmFjdG9yaXplXG4gICAgY2guZmFjdG9yeShEYXRlcGlja2VyKTtcblxufSh0aGlzLCB0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAod2luZG93LCBjaCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0U3VnZ2VzdGlvbih0YXJnZXQpIHtcbiAgICAgICAgdmFyIHBvc2luc2V0O1xuXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGhpcy5fc3VnZ2VzdGlvbnNMaXN0LmNoaWxkTm9kZXMsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmKGUuY29udGFpbnModGFyZ2V0KSl7XG4gICAgICAgICAgICAgICAgcG9zaW5zZXQgPSBwYXJzZUludCh0YXJnZXQuZ2V0QXR0cmlidXRlKCdhcmlhLXBvc2luc2V0JyksIDEwKSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2hpZ2hsaWdodGVkID0gKHR5cGVvZiBwb3NpbnNldCA9PT0gJ251bWJlcicpID8gcG9zaW5zZXQgOiBudWxsO1xuXG4gICAgICAgIHRoaXMuX3Rvb2dsZUhpZ2hsaWdodGVkKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNwZWNpYWxLZXlDb2RlTWFwID0ge1xuICAgICAgICA5OiAndGFiJyxcbiAgICAgICAgMjc6ICdlc2MnLFxuICAgICAgICAzNzogJ2xlZnQnLFxuICAgICAgICAzOTogJ3JpZ2h0JyxcbiAgICAgICAgMTM6ICdlbnRlcicsXG4gICAgICAgIDM4OiAndXAnLFxuICAgICAgICA0MDogJ2Rvd24nXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEF1dG9jb21wbGV0ZSBDb21wb25lbnQgc2hvd3MgYSBsaXN0IG9mIHN1Z2dlc3Rpb25zIGZvciBhIEhUTUxJbnB1dEVsZW1lbnQuXG4gICAgICogQG1lbWJlcm9mIGNoXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIGNoLkNvbXBvbmVudFxuICAgICAqIEByZXF1aXJlcyBjaC5Qb3BvdmVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2VsXSBBIEhUTUxFbGVtZW50IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBjaC5BdXRvY29tcGxldGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRvIGN1c3RvbWl6ZSBhbiBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubG9hZGluZ0NsYXNzXSBEZWZhdWx0OiBcImNoLWF1dG9jb21wbGV0ZS1sb2FkaW5nXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhpZ2hsaWdodGVkQ2xhc3NdIERlZmF1bHQ6IFwiY2gtYXV0b2NvbXBsZXRlLWhpZ2hsaWdodGVkXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLml0ZW1DbGFzc10gRGVmYXVsdDogXCJjaC1hdXRvY29tcGxldGUtaXRlbVwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hZGRDbGFzc10gQ1NTIGNsYXNzIG5hbWVzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgY29udGFpbmVyIG9uIHRoZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24uIERlZmF1bHQ6IFwiY2gtYm94LWxpdGUgY2gtYXV0b2NvbXBsZXRlXCIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmtleXN0cm9rZXNUaW1lXSBEZWZhdWx0OiAxNTAuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5odG1sXSBEZWZhdWx0OiBmYWxzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2lkZV0gVGhlIHNpZGUgb3B0aW9uIHdoZXJlIHRoZSB0YXJnZXQgZWxlbWVudCB3aWxsIGJlIHBvc2l0aW9uZWQuIFlvdSBtdXN0IHVzZTogXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIiBvciBcImNlbnRlclwiLiBEZWZhdWx0OiBcImJvdHRvbVwiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbGlnbl0gVGhlIGFsaWduIG9wdGlvbnMgd2hlcmUgdGhlIHRhcmdldCBlbGVtZW50IHdpbGwgYmUgcG9zaXRpb25lZC4gWW91IG11c3QgdXNlOiBcImxlZnRcIiwgXCJyaWdodFwiLCBcInRvcFwiLCBcImJvdHRvbVwiIG9yIFwiY2VudGVyXCIuIERlZmF1bHQ6IFwibGVmdFwiLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRYXSBUaGUgb2Zmc2V0WCBvcHRpb24gc3BlY2lmaWVzIGEgZGlzdGFuY2UgdG8gZGlzcGxhY2UgdGhlIHRhcmdldCBob3JpdG9udGFsbHkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFldIFRoZSBvZmZzZXRZIG9wdGlvbiBzcGVjaWZpZXMgYSBkaXN0YW5jZSB0byBkaXNwbGFjZSB0aGUgdGFyZ2V0IHZlcnRpY2FsbHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uZWRdIFRoZSBwb3NpdGlvbmVkIG9wdGlvbiBzcGVjaWZpZXMgdGhlIHR5cGUgb2YgcG9zaXRpb25pbmcgdXNlZC4gWW91IG11c3QgdXNlOiBcImFic29sdXRlXCIgb3IgXCJmaXhlZFwiLiBEZWZhdWx0OiBcImFic29sdXRlXCIuXG4gICAgICogQHBhcmFtIHsoQm9vbGVhbiB8IFN0cmluZyl9IFtvcHRpb25zLndyYXBwZXJdIFdyYXAgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBwbGFjZSB0aGUgY29udGFpbmVyIGludG8gaXQgaW5zdGVhZCBvZiBib2R5LiBXaGVuIHZhbHVlIGlzIGEgc3RyaW5nIGl0IHdpbGwgYmUgYXBwbGllZCBhcyBhZGRpdGlvbmFsIHdyYXBwZXIgY2xhc3MuIERlZmF1bHQ6IGZhbHNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyc10gTnVtYmVyIG9mIGNoYXJhY3RlcnMgcmVxdWlyZWQgdG8gYmVnaW4gdG8gc3VnZ2VzdC4gRGVmYXVsdDogMS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHthdXRvY29tcGxldGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgQXV0b0NvbXBsZXRlLlxuICAgICAqIHZhciBhdXRvY29tcGxldGUgPSBuZXcgQXV0b0NvbXBsZXRlKFtlbF0sIFtvcHRpb25zXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgQXV0b0NvbXBsZXRlIHdpdGggY29uZmlndXJhdGlvbi5cbiAgICAgKiB2YXIgYXV0b2NvbXBsZXRlID0gbmV3IEF1dG9Db21wbGV0ZSgnLm15LWF1dG9jb21wbGV0ZScsIHtcbiAgICAgKiAgJ2xvYWRpbmdDbGFzcyc6ICdjdXN0b20tbG9hZGluZycsXG4gICAgICogICdoaWdobGlnaHRlZENsYXNzJzogJ2N1c3RvbS1oaWdobGlnaHRlZCcsXG4gICAgICogICdpdGVtQ2xhc3MnOiAnY3VzdG9tLWl0ZW0nLFxuICAgICAqICAnYWRkQ2xhc3MnOiAnY2Fyb3VzZWwtY2l0aWVzJyxcbiAgICAgKiAgJ2tleXN0cm9rZXNUaW1lJzogNjAwLFxuICAgICAqICAnaHRtbCc6IHRydWUsXG4gICAgICogICdzaWRlJzogJ2NlbnRlcicsXG4gICAgICogICdhbGlnbic6ICdjZW50ZXInLFxuICAgICAqICAnb2Zmc2V0WCc6IDAsXG4gICAgICogICdvZmZzZXRZJzogMCxcbiAgICAgKiAgJ3Bvc2l0aW9uZWQnOiAnZml4ZWQnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gQXV0b2NvbXBsZXRlKGVsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBjb250ZXh0IG9mIGFuIGluc3RhbmNlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2luaXQoZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB5b3UgZGVmaW5lIGFuIGluaXRpYWxpemUgbWV0aG9kLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYSBuZXcgQXV0b2NvbXBsZXRlIGlzIGNyZWF0ZWQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YhIGNoLkF1dG9jb21wbGV0ZS5wcm90b3R5cGVcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZWFkeSB0byB1c2UuXG4gICAgICAgICAqIEBldmVudCBjaC5BdXRvY29tcGxldGUjcmVhZHlcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gU3Vic2NyaWJlIHRvIFwicmVhZHlcIiBldmVudC5cbiAgICAgICAgICogYXV0b2NvbXBsZXRlLm9uKCdyZWFkeScsZnVuY3Rpb24gKCkge1xuICAgICAgICAgKiAgICAgLy8gU29tZSBjb2RlIGhlcmUhXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aGF0LmVtaXQoJ3JlYWR5Jyk7IH0sIDUwKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBJbmhlcml0YW5jZVxuICAgIHRpbnkuaW5oZXJpdHMoQXV0b2NvbXBsZXRlLCBjaC5Db21wb25lbnQpO1xuXG4gICAgdmFyIHBhcmVudCA9IEF1dG9jb21wbGV0ZS5zdXBlcl8ucHJvdG90eXBlLFxuICAgICAgICAvLyB0aGVyZSBpcyBubyBtb3VzZWVudGVyIHRvIGhpZ2hsaWdodCB0aGUgaXRlbSwgc28gaXQgaGFwcGVucyB3aGVuIHRoZSB1c2VyIGRvIG1vdXNlZG93blxuICAgICAgICBoaWdobGlnaHRFdmVudCA9ICh0aW55LnN1cHBvcnQudG91Y2gpID8gY2gub25wb2ludGVyZG93biA6ICdtb3VzZW92ZXInO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUubmFtZSA9ICdhdXRvY29tcGxldGUnO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQG1lbWJlcm9mISBjaC5BdXRvY29tcGxldGUucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEF1dG9jb21wbGV0ZTtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gYnkgZGVmYXVsdC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5fZGVmYXVsdHMgPSB7XG4gICAgICAgICdsb2FkaW5nQ2xhc3MnOiAnY2gtYXV0b2NvbXBsZXRlLWxvYWRpbmcnLFxuICAgICAgICAnaGlnaGxpZ2h0ZWRDbGFzcyc6ICdjaC1hdXRvY29tcGxldGUtaGlnaGxpZ2h0ZWQnLFxuICAgICAgICAnaXRlbUNsYXNzJzogJ2NoLWF1dG9jb21wbGV0ZS1pdGVtJyxcbiAgICAgICAgJ2FkZENsYXNzJzogJ2NoLWJveC1saXRlIGNoLWF1dG9jb21wbGV0ZScsXG4gICAgICAgICdzaWRlJzogJ2JvdHRvbScsXG4gICAgICAgICdhbGlnbic6ICdsZWZ0JyxcbiAgICAgICAgJ2h0bWwnOiBmYWxzZSxcbiAgICAgICAgJ19oaWRkZW5ieSc6ICdub25lJyxcbiAgICAgICAgJ2tleXN0cm9rZXNUaW1lJzogMTUwLFxuICAgICAgICAnX2l0ZW1UZW1wbGF0ZSc6ICc8bGkgY2xhc3M9XCJ7e2l0ZW1DbGFzc319XCJ7e3N1Z2dlc3RlZERhdGF9fT57e3Rlcm19fTxpIGNsYXNzPVwiY2gtaWNvbi1hcnJvdy11cFwiIGRhdGEtanM9XCJjaC1hdXRvY29tcGxldGUtY29tcGxldGUtcXVlcnlcIj48L2k+PC9saT4nLFxuICAgICAgICAnd3JhcHBlcic6IGZhbHNlLFxuICAgICAgICAnbWluQ2hhcnMnOiAxXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSBuZXcgaW5zdGFuY2Ugb2YgQXV0b2NvbXBsZXRlIGFuZCBtZXJnZSBjdXN0b20gb3B0aW9ucyB3aXRoIGRlZmF1bHRzIG9wdGlvbnMuXG4gICAgICogQG1lbWJlcm9mISBjaC5BdXRvY29tcGxldGUucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7YXV0b2NvbXBsZXRlfVxuICAgICAqL1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLy8gQ2FsbCB0byBpdHMgcGFyZW50IGluaXQgbWV0aG9kXG4gICAgICAgIHBhcmVudC5faW5pdC5jYWxsKHRoaXMsIGVsLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBjcmVhdGVzIHRoZSBiYXNpYyBpdGVtIHRlbXBsYXRlIGZvciB0aGlzIGluc3RhbmNlXG4gICAgICAgIHRoaXMuX29wdGlvbnMuX2l0ZW1UZW1wbGF0ZSA9IHRoaXMuX29wdGlvbnMuX2l0ZW1UZW1wbGF0ZS5yZXBsYWNlKCd7e2l0ZW1DbGFzc319JywgdGhpcy5fb3B0aW9ucy5pdGVtQ2xhc3MpO1xuXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgc3VnZ2VzdGVkIGRhdGEgc3BhY2Ugd2hlbiBodG1sIGlzIGNvbmZpZ3VyZWRcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuX2l0ZW1UZW1wbGF0ZSA9IHRoaXMuX29wdGlvbnMuX2l0ZW1UZW1wbGF0ZS5yZXBsYWNlKCd7e3N1Z2dlc3RlZERhdGF9fScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBjb21wb25lbnQgd2hvIHNob3dzIGFuZCBtYW5hZ2UgdGhlIHN1Z2dlc3Rpb25zLlxuICAgICAgICB0aGlzLl9wb3BvdmVyID0gbmV3IGNoLlBvcG92ZXIoe1xuICAgICAgICAgICAgJ3JlZmVyZW5jZSc6IHRoaXMuX2VsLFxuICAgICAgICAgICAgJ2NvbnRlbnQnOiB0aGlzLl9zdWdnZXN0aW9uc0xpc3QsXG4gICAgICAgICAgICAnc2lkZSc6IHRoaXMuX29wdGlvbnMuc2lkZSxcbiAgICAgICAgICAgICdhbGlnbic6IHRoaXMuX29wdGlvbnMuYWxpZ24sXG4gICAgICAgICAgICAnYWRkQ2xhc3MnOiB0aGlzLl9vcHRpb25zLmFkZENsYXNzLFxuICAgICAgICAgICAgJ2hpZGRlbmJ5JzogdGhpcy5fb3B0aW9ucy5faGlkZGVuYnksXG4gICAgICAgICAgICAnd2lkdGgnOiB0aGlzLl9lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArICdweCcsXG4gICAgICAgICAgICAnZngnOiB0aGlzLl9vcHRpb25zLmZ4LFxuICAgICAgICAgICAgJ3dyYXBwZXInOiB0aGlzLl9vcHRpb25zLndyYXBwZXJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhdXRvY29tcGxldGUgY29udGFpbmVyLlxuICAgICAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIEdldHMgdGhlIGF1dG9jb21wbGV0ZSBjb250YWluZXIgdG8gYXBwZW5kIG9yIHByZXBlbmQgY29udGVudC5cbiAgICAgICAgICogYXV0b2NvbXBsZXRlLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuX3BvcG92ZXIuY29udGFpbmVyO1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb24gbGlzdC5cbiAgICAgICAgICogQHR5cGUge0hUTUxVTGlzdEVsZW1lbnR9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdWdnZXN0aW9uc0xpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICB0aW55LmFkZENsYXNzKHRoaXMuX3N1Z2dlc3Rpb25zTGlzdCwgJ2NoLWF1dG9jb21wbGV0ZS1saXN0Jyk7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fc3VnZ2VzdGlvbnNMaXN0KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0cyB0aGUgaXRlbXNcbiAgICAgICAgICogQG1lbWJlcm9mISBjaC5BdXRvY29tcGxldGUucHJvdG90eXBlXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcmV0dXJucyB7YXV0b2NvbXBsZXRlfVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLl9oaWdobGlnaHRTdWdnZXN0aW9uID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgaXRlbSA9ICh0YXJnZXQubm9kZU5hbWUgPT09ICdMSScpID8gdGFyZ2V0IDogKHRhcmdldC5wYXJlbnROb2RlLm5vZGVOYW1lID09PSAnTEknKSA/IHRhcmdldC5wYXJlbnROb2RlIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRTdWdnZXN0aW9uLmNhbGwodGhhdCwgaXRlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICB0aW55Lm9uKHRoaXMuY29udGFpbmVyLCBoaWdobGlnaHRFdmVudCwgdGhpcy5faGlnaGxpZ2h0U3VnZ2VzdGlvbik7XG5cblxuICAgICAgICB0aW55Lm9uKHRoaXMuY29udGFpbmVyLCBjaC5vbnBvaW50ZXJ0YXAsIGZ1bmN0aW9uIGl0ZW1FdmVudHMoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudDtcblxuICAgICAgICAgICAgLy8gY29tcGxldGVzIHRoZSB2YWx1ZSwgaXQgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCB3cml0ZSB0aGUgY29tcGxldGUgd29yZFxuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0knICYmICF0aGF0Ll9vcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoYXQuX2VsLnZhbHVlID0gdGhhdC5fc3VnZ2VzdGlvbnNbdGhhdC5faGlnaGxpZ2h0ZWRdO1xuICAgICAgICAgICAgICAgIHRoYXQuZW1pdCgndHlwZScsIHRoYXQuX2VsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgodGFyZ2V0Lm5vZGVOYW1lID09PSAnTEknICYmIHRhcmdldC5jbGFzc05hbWUuaW5kZXhPZih0aGF0Ll9vcHRpb25zLml0ZW1DbGFzcykgIT09IC0xKSB8fCAodGFyZ2V0LnBhcmVudEVsZW1lbnQubm9kZU5hbWUgPT09ICdMSScgJiYgdGFyZ2V0LnBhcmVudEVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YodGhhdC5fb3B0aW9ucy5pdGVtQ2xhc3MpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9zZWxlY3RTdWdnZXN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXV0b2NvbXBsZXRlIHRyaWdnZXIuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlciA9IHRoaXMuX2VsO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtYXV0b2NvbXBsZXRlJywgJ2xpc3QnKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsICd0cnVlJyk7XG4gICAgICAgIHRoaXMudHJpZ2dlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtb3ducycsIHRoaXMuY29udGFpbmVyLmdldEF0dHJpYnV0ZSgnaWQnKSk7XG4gICAgICAgIHRoaXMudHJpZ2dlci5zZXRBdHRyaWJ1dGUoJ2F1dG9jb21wbGV0ZScsICdvZmYnKTtcblxuICAgICAgICB0aW55Lm9uKHRoaXMudHJpZ2dlciwgJ2ZvY3VzJywgZnVuY3Rpb24gdHVybm9uKCkgeyB0aGF0Ll90dXJuKCdvbicpOyB9KTtcbiAgICAgICAgdGlueS5vbih0aGlzLnRyaWdnZXIsICdibHVyJywgZnVuY3Rpb24gdHVybm9mZigpIHt0aGF0Ll90dXJuKCdvZmYnKTsgfSk7XG5cbiAgICAgICAgLy8gVHVybiBvbiB3aGVuIHRoZSBpbnB1dCBlbGVtZW50IGlzIGFscmVhZHkgaGFzIGZvY3VzXG4gICAgICAgIGlmICh0aGlzLl9lbCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAhdGhpcy5fZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fdHVybignb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgdGhlIHNlbGVjdGVkIGl0ZW0gb3IgbnVsbCB3aGVuIG5vIHNlbGVjdGVkIGl0ZW0gaXMuXG4gICAgICAgIHRoaXMuX2hpZ2hsaWdodGVkID0gbnVsbDtcblxuICAgICAgICAvLyBDb2xsZWN0aW9uIG9mIHN1Z2dlc3Rpb25zIHRvIGJlIHNob3duLlxuICAgICAgICB0aGlzLl9zdWdnZXN0aW9ucyA9IFtdO1xuXG4gICAgICAgIC8vIFVzZWQgdG8gc2hvdyB3aGVuIHRoZSB1c2VyIGNhbmNlbCB0aGUgc3VnZ2VzdGlvbnNcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxRdWVyeSA9IHRoaXMuX2N1cnJlbnRRdWVyeSA9IHRoaXMuX2VsLnZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLl9jb25maWd1cmVTaG9ydGN1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlndXJlU2hvcnRjdXRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHVybnMgb24gdGhlIGFiaWxpdHkgb2ZmIGxpc3RlbiB0aGUga2V5c3Ryb2tlc1xuICAgICAqIEBtZW1iZXJvZiEgY2guQXV0b2NvbXBsZXRlLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge2F1dG9jb21wbGV0ZX1cbiAgICAgKi9cbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLl90dXJuID0gZnVuY3Rpb24gKHR1cm4pIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5fZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGZ1bmN0aW9uIHR1cm5PbigpIHtcbiAgICAgICAgICAgIHRoYXQuX2N1cnJlbnRRdWVyeSA9IHRoYXQuX2VsLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIHVzZXIgd3JpdGVzXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoYXQuX3N0b3BUeXBpbmcpO1xuICAgICAgICAgICAgaWYgKHRoYXQuX2N1cnJlbnRRdWVyeS5sZW5ndGggPj0gdGhhdC5fb3B0aW9ucy5taW5DaGFycykge1xuICAgICAgICAgICAgICAgIHRoYXQuX3N0b3BUeXBpbmcgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICB0aW55LmFkZENsYXNzKHRoYXQudHJpZ2dlciwgdGhhdC5fb3B0aW9ucy5sb2FkaW5nQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGlzIHR5cGluZy5cbiAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50IGNoLkF1dG9jb21wbGV0ZSN0eXBlXG4gICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAqIC8vIFN1YnNjcmliZSB0byBcInR5cGVcIiBldmVudCB3aXRoIGFqYXggY2FsbFxuICAgICAgICAgICAgICAgICAgICAgKiBhdXRvY29tcGxldGUub24oJ3R5cGUnLCBmdW5jdGlvbiAodXNlcklucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgJ3VybCc6ICcvY291bnRyaWVzP3E9JyArIHVzZXJJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgJ2RhdGFUeXBlJzogJ2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAnc3VjY2Vzcyc6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlLnN1Z2dlc3QocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJ0eXBlXCIgZXZlbnQgd2l0aCBqc29ucFxuICAgICAgICAgICAgICAgICAgICAgKiBhdXRvY29tcGxldGUub24oJ3R5cGUnLCBmdW5jdGlvbiAodXNlcklucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAndXJsJzogJy9jb3VudHJpZXM/cT0nKyB1c2VySW5wdXQgKycmY2FsbGJhY2s9cGFyc2VSZXN1bHRzJyxcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICdkYXRhVHlwZSc6ICdqc29ucCcsXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAnY2FjaGUnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICdnbG9iYWwnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgJ2NvbnRleHQnOiB3aW5kb3csXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAnanNvbnAnOiAncGFyc2VSZXN1bHRzJyxcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICdjcm9zc0RvbWFpbic6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5lbWl0KCd0eXBlJywgdGhhdC5fY3VycmVudFF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB9LCB0aGF0Ll9vcHRpb25zLmtleXN0cm9rZXNUaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhhdC5zdWdnZXN0KFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHR1cm5PbkZhbGxiYWNrKGUpIHtcbiAgICAgICAgICAgIGlmIChzcGVjaWFsS2V5Q29kZU1hcFtlLndoaWNoIHx8IGUua2V5Q29kZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaGVuIGtleWRvd24gaXMgZmlyZWQgdGhhdC50cmlnZ2VyIHN0aWxsIGhhcyBhbiBvbGQgdmFsdWVcbiAgICAgICAgICAgIHNldFRpbWVvdXQodHVybk9uLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29yaWdpbmFsUXVlcnkgPSB0aGlzLl9lbC52YWx1ZTtcblxuICAgICAgICAvLyBJRTggZG9uJ3Qgc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYXQgYWxsXG4gICAgICAgIC8vIElFOSBpcyB0aGUgb25seSBicm93c2VyIHRoYXQgZG9lc24ndCBmaXJlIHRoZSBpbnB1dCBldmVudCB3aGVuIGNoYXJhY3RlcnMgYXJlIHJlbW92ZWRcbiAgICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgdmFyIE1TSUUgPSAoLyhtc2llfHRyaWRlbnQpL2kpLnRlc3QodWEpID9cbiAgICAgICAgICAgIHVhLm1hdGNoKC8obXNpZSB8cnY6KShcXGQrKC5cXGQrKT8pL2kpWzJdIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKHR1cm4gPT09ICdvbicpIHtcbiAgICAgICAgICAgIGlmICghTVNJRSB8fCBNU0lFID4gOSkge1xuICAgICAgICAgICAgICAgIHRpbnkub24odGhpcy50cmlnZ2VyLCBjaC5vbmtleWlucHV0LCB0dXJuT24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAna2V5ZG93biBjdXQgcGFzdGUnLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihldnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbnkub24odGhhdC50cmlnZ2VyLCBldnROYW1lLCB0dXJuT25GYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHVybiA9PT0gJ29mZicpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgaWYgKCFNU0lFIHx8IE1TSUUgPiA5KSB7XG4gICAgICAgICAgICAgICAgdGlueS5vZmYodGhpcy50cmlnZ2VyLCBjaC5vbmtleWlucHV0LCB0dXJuT24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAna2V5ZG93biBjdXQgcGFzdGUnLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihldnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbnkub2ZmKHRoYXQudHJpZ2dlciwgZXZ0TmFtZSwgdHVybk9uRmFsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSXQgc2V0cyB0byB0aGUgSFRNTElucHV0RWxlbWVudCB0aGUgc2VsZWN0ZWQgcXVlcnkgYW5kIGl0IGVtaXRzIGEgJ3NlbGVjdCcgZXZlbnQuXG4gICAgICogQG1lbWJlcm9mISBjaC5BdXRvY29tcGxldGUucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7YXV0b2NvbXBsZXRlfVxuICAgICAqL1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuX3NlbGVjdFN1Z2dlc3Rpb24gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9zdG9wVHlwaW5nKTtcblxuICAgICAgICBpZiAodGhpcy5faGlnaGxpZ2h0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsLnZhbHVlID0gdGhpcy5fc3VnZ2VzdGlvbnNbdGhpcy5faGlnaGxpZ2h0ZWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZWwuYmx1cigpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gYSBzdWdnZXN0aW9uIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAZXZlbnQgY2guQXV0b2NvbXBsZXRlI3NlbGVjdFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJzZWxlY3RcIiBldmVudC5cbiAgICAgICAgICogYXV0b2NvbXBsZXRlLm9uKCdzZWxlY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAvLyBTb21lIGNvZGUgaGVyZSFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVtaXQoJ3NlbGVjdCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJdCBoaWdobGlnaHRzIHRoZSBpdGVtIGFkZGluZyB0aGUgXCJjaC1hdXRvY29tcGxldGUtaGlnaGxpZ2h0ZWRcIiBjbGFzcyBuYW1lIG9yIHRoZSBjbGFzcyBuYW1lIHRoYXQgeW91IGNvbmZpZ3VyZWQgYXMgXCJoaWdobGlnaHRlZENsYXNzXCIgb3B0aW9uLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQXV0b2NvbXBsZXRlLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge2F1dG9jb21wbGV0ZX1cbiAgICAgKi9cbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLl90b29nbGVIaWdobGlnaHRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbnVsbCBpcyB3aGVuIGlzIG5vdCBhIHNlbGVjdGVkIGl0ZW0gYnV0LFxuICAgICAgICAvLyBpbmNyZW1lbnRzIDEgX2hpZ2hsaWdodGVkIGJlY2F1c2UgYXJpYS1wb3NpbnNldCBzdGFydHMgaW4gMSBpbnN0ZWFkIDAgYXMgdGhlIGNvbGxlY3Rpb24gdGhhdCBzdG9yZXMgdGhlIGRhdGFcbiAgICAgICAgdmFyIGN1cnJlbnQgPSAodGhpcy5faGlnaGxpZ2h0ZWQgPT09IG51bGwpID8gbnVsbCA6ICh0aGlzLl9oaWdobGlnaHRlZCArIDEpLFxuICAgICAgICAgICAgY3VycmVudEl0ZW0gPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdbYXJpYS1wb3NpbnNldD1cIicgKyBjdXJyZW50ICsgJ1wiXScpLFxuICAgICAgICAgICAgc2VsZWN0ZWRJdGVtID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignW2FyaWEtcG9zaW5zZXRdLicgKyB0aGlzLl9vcHRpb25zLmhpZ2hsaWdodGVkQ2xhc3MpO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZEl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGJhY2tncm91bmQgdGhlIGhpZ2hsaWdodGVkIGl0ZW1cbiAgICAgICAgICAgIHRpbnkucmVtb3ZlQ2xhc3Moc2VsZWN0ZWRJdGVtLCB0aGlzLl9vcHRpb25zLmhpZ2hsaWdodGVkQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJdGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBoaWdobGlnaHQgdGhlIHNlbGVjdGVkIGl0ZW1cbiAgICAgICAgICAgIHRpbnkuYWRkQ2xhc3MoY3VycmVudEl0ZW0sIHRoaXMuX29wdGlvbnMuaGlnaGxpZ2h0ZWRDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIHN1Z2dlc3Rpb25zIHRvIGJlIHNob3duLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQXV0b2NvbXBsZXRlLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHthdXRvY29tcGxldGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBUaGUgc3VnZ2VzdCBtZXRob2QgbmVlZHMgYW4gQXJyYXkgb2Ygc3RyaW5ncyB0byB3b3JrIHdpdGggZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAgICogYXV0b2NvbXBsZXRlLnN1Z2dlc3QoWydBcnViYScsJ0FybWVuaWEnLCdBcmdlbnRpbmEnXSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBUbyB3b3JrIHdpdGggaHRtbCBjb25maWd1cmF0aW9uLCBpdCBuZWVkcyBhbiBBcnJheSBvZiBzdHJpbmdzLiBFYWNoIHN0cmluZyBtdXN0IHRvIGJlIGFzIHlvdSB3aXNoIHlvdSB3YXRjaCBpdFxuICAgICAqIGF1dG9jb21wbGV0ZS5zdWdnZXN0KFtcbiAgICAgKiAgJzxzdHJvbmc+QXI8L3N0cm9uZz51YmEgPGkgY2xhc3M9XCJmbGFnLWFydWJhXCI+PC9pPicsXG4gICAgICogICc8c3Ryb25nPkFyPC9zdHJvbmc+bWVuaWEgPGkgY2xhc3M9XCJmbGFnLWFybWVuaWFcIj48L2k+JyxcbiAgICAgKiAgJzxzdHJvbmc+QXI8L3N0cm9uZz5nZW50aW5hIDxpIGNsYXNzPVwiZmxhZy1hcmdlbnRpbmFcIj48L2k+J1xuICAgICAqIF0pO1xuICAgICAqL1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuc3VnZ2VzdCA9IGZ1bmN0aW9uIChzdWdnZXN0aW9ucykge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gY29udGV4dCBvZiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zID0gW10sXG4gICAgICAgICAgICBtYXRjaGVkUmVnRXhwID0gbmV3IFJlZ0V4cCgnKCcgKyB0aGlzLl9jdXJyZW50UXVlcnkucmVwbGFjZSgvKFsuKis/Xj0hOiR7fSgpfFtcXF1cXC9cXFxcXSkvZywgJ1xcXFwkMScpICsgJyknLCAnaWcnKSxcbiAgICAgICAgICAgIHRvdGFsSXRlbXMsXG4gICAgICAgICAgICBpdGVtRE9NQ29sbGVjdGlvbixcbiAgICAgICAgICAgIGl0ZW1UZW1wbGF0ZSA9IHRoaXMuX29wdGlvbnMuX2l0ZW1UZW1wbGF0ZSxcbiAgICAgICAgICAgIHN1Z2dlc3RlZEl0ZW0sXG4gICAgICAgICAgICB0ZXJtLFxuICAgICAgICAgICAgc3VnZ2VzdGlvbnNMZW5ndGggPSBzdWdnZXN0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIGl0ZW1TZWxlY3RlZCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy5fb3B0aW9ucy5oaWdobGlnaHRlZENsYXNzKTtcblxuICAgICAgICAvLyBoaWRlIHRoZSBsb2FkaW5nIGZlZWRiYWNrXG4gICAgICAgIHRpbnkucmVtb3ZlQ2xhc3ModGhpcy50cmlnZ2VyLCB0aGF0Ll9vcHRpb25zLmxvYWRpbmdDbGFzcyk7XG5cbiAgICAgICAgLy8gaGlkZXMgdGhlIHN1Z2dlc3Rpb25zIGxpc3RcbiAgICAgICAgaWYgKHN1Z2dlc3Rpb25zTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3BvdmVyLmhpZGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaG93cyB0aGUgc3VnZ2VzdGlvbnMgbGlzdCB3aGVuIHRoZSBpcyBjbG9zZWQgYW5kIHRoZSBlbGVtZW50IGlzIHdpdGhzIGZvY3VzXG4gICAgICAgIGlmICghdGhpcy5fcG9wb3Zlci5pc1Nob3duKCkgJiYgd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuX2VsKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3BvdmVyLnNob3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY2xhc3MgZnJvbSB0aGUgZXh0cmEgYWRkZWQgaXRlbXNcbiAgICAgICAgaWYgKGl0ZW1TZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGlueS5yZW1vdmVDbGFzcyhpdGVtU2VsZWN0ZWQsIHRoaXMuX29wdGlvbnMuaGlnaGxpZ2h0ZWRDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgZWFjaCBzdWdnZXN0ZWQgaXRlbSB0byB0aGUgc3VnZ2VzdGlvbiBsaXN0XG4gICAgICAgIGZvciAoc3VnZ2VzdGVkSXRlbSA9IDA7IHN1Z2dlc3RlZEl0ZW0gPCBzdWdnZXN0aW9uc0xlbmd0aDsgc3VnZ2VzdGVkSXRlbSArPSAxKSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHRlcm0gdG8gYmUgcmVwbGFjZWRcbiAgICAgICAgICAgIHRlcm0gPSBzdWdnZXN0aW9uc1tzdWdnZXN0ZWRJdGVtXTtcblxuICAgICAgICAgICAgLy8gZm9yIHRoZSBodG1sIGNvbmZpZ3VyZWQgY29tcG9uZW50IGRvZXNuJ3QgaGlnaGxpZ2h0IHRoZSB0ZXJtIG1hdGNoZWQgaXQgbXVzdCBiZSBkb25lIGJ5IHRoZSB1c2VyXG4gICAgICAgICAgICBpZiAoIXRoYXQuX29wdGlvbnMuaHRtbCkge1xuICAgICAgICAgICAgICAgIHRlcm0gPSB0ZXJtLnJlcGxhY2UobWF0Y2hlZFJlZ0V4cCwgJzxzdHJvbmc+JDE8L3N0cm9uZz4nKTtcbiAgICAgICAgICAgICAgICBpdGVtVGVtcGxhdGUgPSB0aGlzLl9vcHRpb25zLl9pdGVtVGVtcGxhdGUucmVwbGFjZSgne3tzdWdnZXN0ZWREYXRhfX0nLCAnIGRhdGEtc3VnZ2VzdGVkPVwiJyArIHN1Z2dlc3Rpb25zW3N1Z2dlc3RlZEl0ZW1dICsgJ1wiJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbVRlbXBsYXRlLnJlcGxhY2UoJ3t7dGVybX19JywgdGVybSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3VnZ2VzdGlvbnNMaXN0LmlubmVySFRNTCA9IGl0ZW1zLmpvaW4oJycpO1xuXG4gICAgICAgIGl0ZW1ET01Db2xsZWN0aW9uID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLicgKyB0aGlzLl9vcHRpb25zLml0ZW1DbGFzcyk7XG5cbiAgICAgICAgLy8gd2l0aCB0aGlzIHdlIHNldCB0aGUgYXJpYS1zZXRzaXplIHZhbHVlIHRoYXQgY291bnRzIHRoZSB0b3RhbFxuICAgICAgICB0b3RhbEl0ZW1zID0gaXRlbURPTUNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgIC8vIFJlc2V0IHN1Z2dlc3Rpb25zIGNvbGxlY3Rpb24uXG4gICAgICAgIHRoaXMuX3N1Z2dlc3Rpb25zLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgZm9yIChzdWdnZXN0ZWRJdGVtID0gMDsgc3VnZ2VzdGVkSXRlbSA8IHRvdGFsSXRlbXM7IHN1Z2dlc3RlZEl0ZW0gKz0gMSkge1xuICAgICAgICAgICAgZWwgPSBpdGVtRE9NQ29sbGVjdGlvbltzdWdnZXN0ZWRJdGVtXTtcblxuICAgICAgICAgICAgLy8gYWRkIHRoZSBkYXRhIHRvIHRoZSBzdWdnZXN0aW9ucyBjb2xsZWN0aW9uXG4gICAgICAgICAgICB0aGF0Ll9zdWdnZXN0aW9ucy5wdXNoKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zdWdnZXN0ZWQnKSk7XG5cbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1wb3NpbnNldCcsIHRoYXQuX3N1Z2dlc3Rpb25zLmxlbmd0aCk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2V0c2l6ZScsIHRvdGFsSXRlbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGlnaGxpZ2h0ZWQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3N1Z2dlc3Rpb25zUXVhbnRpdHkgPSB0aGlzLl9zdWdnZXN0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhpZGVzIGNvbXBvbmVudCdzIGNvbnRhaW5lci5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkF1dG9jb21wbGV0ZS5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7YXV0b2NvbXBsZXRlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gSGlkZXMgdGhlIGF1dG9jb21wbGV0ZS5cbiAgICAgKiBhdXRvY29tcGxldGUuaGlkZSgpO1xuICAgICAqL1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9wb3Zlci5oaWRlKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgQXV0b2NvbXBsZXRlIGNvbnRhaW5lciBpcyBoaWRkZW4uXG4gICAgICAgICAqIEBldmVudCBjaC5BdXRvY29tcGxldGUjaGlkZVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBTdWJzY3JpYmUgdG8gXCJoaWRlXCIgZXZlbnQuXG4gICAgICAgICAqIGF1dG9jb21wbGV0ZS5vbignaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICogIC8vIFNvbWUgY29kZSBoZXJlIVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW1pdCgnaGlkZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQm9vbGVhbiBpZiB0aGUgY29tcG9uZW50J3MgY29yZSBiZWhhdmlvciBpcyBzaG93bi4gVGhhdCBtZWFucyBpdCB3aWxsIHJldHVybiAndHJ1ZScgaWYgdGhlIGNvbXBvbmVudCBpcyBvbiBhbmQgaXQgd2lsbCByZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBtZW1iZXJvZiEgY2guQXV0b2NvbXBsZXRlLnByb3RvdHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gRXhlY3V0ZSBhIGZ1bmN0aW9uIGlmIHRoZSBjb21wb25lbnQgaXMgc2hvd24uXG4gICAgICogaWYgKGF1dG9jb21wbGV0ZS5pc1Nob3duKCkpIHtcbiAgICAgKiAgICAgZm4oKTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5pc1Nob3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9wb3Zlci5pc1Nob3duKCk7XG4gICAgfTtcblxuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaG93bigpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2VsLmJsdXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudC5kaXNhYmxlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFuIEF1dG9jb21wbGV0ZSBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyb2YhIGNoLkF1dG9jb21wbGV0ZS5wcm90b3R5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIERlc3Ryb3lpbmcgYW4gaW5zdGFuY2Ugb2YgQXV0b2NvbXBsZXRlLlxuICAgICAqIGF1dG9jb21wbGV0ZS5kZXN0cm95KCk7XG4gICAgICovXG4gICAgQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRpbnkub2ZmKHRoaXMuY29udGFpbmVyLCBoaWdobGlnaHRFdmVudCwgdGhpcy5faGlnaGxpZ2h0U3VnZ2VzdGlvbik7XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyLnJlbW92ZUF0dHJpYnV0ZSgnYXV0b2NvbXBsZXRlJyk7XG4gICAgICAgIHRoaXMudHJpZ2dlci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYXV0b2NvbXBsZXRlJyk7XG4gICAgICAgIHRoaXMudHJpZ2dlci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1vd25zJyk7XG5cbiAgICAgICAgdGhpcy5fcG9wb3Zlci5kZXN0cm95KCk7XG5cbiAgICAgICAgcGFyZW50LmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIGNoLmZhY3RvcnkoQXV0b2NvbXBsZXRlKTtcblxufSh0aGlzLCB0aGlzLmNoKSk7XG5cbihmdW5jdGlvbiAoQXV0b2NvbXBsZXRlLCBjaCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBDb25nZmlndXJlIHNob3J0Y3V0cyB0byBuYXZpZ2F0ZSBhbmQgc2V0IHZhbHVlcywgb3IgY2FuY2VsIHRoZSB0eXBlZCB0ZXh0XG4gICAgICogQG1lbWJlcm9mISBjaC5BdXRvY29tcGxldGUucHJvdG90eXBlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7YXV0b2NvbXBsZXRlfVxuICAgICAqL1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuX2NvbmZpZ3VyZVNob3J0Y3V0cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIGNvbnRleHQgb2YgYW4gaW5zdGFuY2UuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgIGNoLnNob3J0Y3V0cy5hZGQoY2gub25rZXllbnRlciwgdGhpcy51aWQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoYXQuX3NlbGVjdFN1Z2dlc3Rpb24oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2guc2hvcnRjdXRzLmFkZChjaC5vbmtleWVzYywgdGhpcy51aWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuaGlkZSgpO1xuICAgICAgICAgICAgdGhhdC5fZWwudmFsdWUgPSB0aGF0Ll9vcmlnaW5hbFF1ZXJ5O1xuICAgICAgICB9KTtcblxuICAgICAgICBjaC5zaG9ydGN1dHMuYWRkKGNoLm9ua2V5dXBhcnJvdywgdGhpcy51aWQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIHNlbGVjdGVkIHZhbHVlICYgc3RvcmVzIHRoZSBmdXR1cmUgSFRNTElucHV0RWxlbWVudCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHRoYXQuX2hpZ2hsaWdodGVkID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICB0aGF0Ll9oaWdobGlnaHRlZCA9IHRoYXQuX3N1Z2dlc3Rpb25zUXVhbnRpdHkgLSAxO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhhdC5fc3VnZ2VzdGlvbnNbdGhhdC5faGlnaGxpZ2h0ZWRdO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoYXQuX2hpZ2hsaWdodGVkIDw9IDApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZIaWdobGlnaHRlZCA9IHRoaXMuX2N1cnJlbnRIaWdobGlnaHRlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGF0Ll9jdXJyZW50UXVlcnk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGF0Ll9oaWdobGlnaHRlZCAtPSAxO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhhdC5fc3VnZ2VzdGlvbnNbdGhhdC5faGlnaGxpZ2h0ZWRdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoYXQuX3Rvb2dsZUhpZ2hsaWdodGVkKCk7XG5cbiAgICAgICAgICAgIGlmICghdGhhdC5fb3B0aW9ucy5odG1sKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fZWwudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICBjaC5zaG9ydGN1dHMuYWRkKGNoLm9ua2V5ZG93bmFycm93LCB0aGlzLnVpZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIHNlbGVjdGVkIHZhbHVlICYgc3RvcmVzIHRoZSBmdXR1cmUgSFRNTElucHV0RWxlbWVudCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHRoYXQuX2hpZ2hsaWdodGVkID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICB0aGF0Ll9oaWdobGlnaHRlZCA9IDA7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoYXQuX3N1Z2dlc3Rpb25zW3RoYXQuX2hpZ2hsaWdodGVkXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGF0Ll9oaWdobGlnaHRlZCA+PSB0aGF0Ll9zdWdnZXN0aW9uc1F1YW50aXR5IC0gMSkge1xuXG4gICAgICAgICAgICAgICAgdGhhdC5faGlnaGxpZ2h0ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhhdC5fY3VycmVudFF1ZXJ5O1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhhdC5faGlnaGxpZ2h0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoYXQuX3N1Z2dlc3Rpb25zW3RoYXQuX2hpZ2hsaWdodGVkXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0Ll90b29nbGVIaWdobGlnaHRlZCgpO1xuXG4gICAgICAgICAgICBpZiAoIXRoYXQuX29wdGlvbnMuaHRtbCkge1xuICAgICAgICAgICAgICAgIHRoYXQuX2VsLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWN0aXZhdGUgdGhlIHNob3J0Y3V0cyBmb3IgdGhpcyBpbnN0YW5jZVxuICAgICAgICB0aGlzLl9wb3BvdmVyLm9uKCdiZWZvcmVzaG93JywgZnVuY3Rpb24gKCkgeyBjaC5zaG9ydGN1dHMub24odGhhdC51aWQpOyB9KTtcblxuICAgICAgICAvLyBEZWFjdGl2YXRlIHRoZSBzaG9ydGN1dHMgZm9yIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5fcG9wb3Zlci5vbignYmVmb3JlaGlkZScsIGZ1bmN0aW9uICgpIHsgY2guc2hvcnRjdXRzLm9mZih0aGF0LnVpZCk7IH0pO1xuXG4gICAgICAgIHRoaXMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjaC5zaG9ydGN1dHMucmVtb3ZlKHRoaXMudWlkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxufSh0aGlzLmNoLkF1dG9jb21wbGV0ZSwgdGhpcy5jaCkpO1xuIiwiLyohIGpRdWVyeSB2My4xLjEgfCAoYykgalF1ZXJ5IEZvdW5kYXRpb24gfCBqcXVlcnkub3JnL2xpY2Vuc2UgKi9cbiFmdW5jdGlvbihhLGIpe1widXNlIHN0cmljdFwiO1wib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1hLmRvY3VtZW50P2IoYSwhMCk6ZnVuY3Rpb24oYSl7aWYoIWEuZG9jdW1lbnQpdGhyb3cgbmV3IEVycm9yKFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiKTtyZXR1cm4gYihhKX06YihhKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6dGhpcyxmdW5jdGlvbihhLGIpe1widXNlIHN0cmljdFwiO3ZhciBjPVtdLGQ9YS5kb2N1bWVudCxlPU9iamVjdC5nZXRQcm90b3R5cGVPZixmPWMuc2xpY2UsZz1jLmNvbmNhdCxoPWMucHVzaCxpPWMuaW5kZXhPZixqPXt9LGs9ai50b1N0cmluZyxsPWouaGFzT3duUHJvcGVydHksbT1sLnRvU3RyaW5nLG49bS5jYWxsKE9iamVjdCksbz17fTtmdW5jdGlvbiBwKGEsYil7Yj1ifHxkO3ZhciBjPWIuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtjLnRleHQ9YSxiLmhlYWQuYXBwZW5kQ2hpbGQoYykucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKX12YXIgcT1cIjMuMS4xXCIscj1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgci5mbi5pbml0KGEsYil9LHM9L15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLHQ9L14tbXMtLyx1PS8tKFthLXpdKS9nLHY9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50b1VwcGVyQ2FzZSgpfTtyLmZuPXIucHJvdG90eXBlPXtqcXVlcnk6cSxjb25zdHJ1Y3RvcjpyLGxlbmd0aDowLHRvQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gZi5jYWxsKHRoaXMpfSxnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/Zi5jYWxsKHRoaXMpOmE8MD90aGlzW2ErdGhpcy5sZW5ndGhdOnRoaXNbYV19LHB1c2hTdGFjazpmdW5jdGlvbihhKXt2YXIgYj1yLm1lcmdlKHRoaXMuY29uc3RydWN0b3IoKSxhKTtyZXR1cm4gYi5wcmV2T2JqZWN0PXRoaXMsYn0sZWFjaDpmdW5jdGlvbihhKXtyZXR1cm4gci5lYWNoKHRoaXMsYSl9LG1hcDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soci5tYXAodGhpcyxmdW5jdGlvbihiLGMpe3JldHVybiBhLmNhbGwoYixjLGIpfSkpfSxzbGljZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB1c2hTdGFjayhmLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9LGZpcnN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoMCl9LGxhc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lcSgtMSl9LGVxOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubGVuZ3RoLGM9K2ErKGE8MD9iOjApO3JldHVybiB0aGlzLnB1c2hTdGFjayhjPj0wJiZjPGI/W3RoaXNbY11dOltdKX0sZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJldk9iamVjdHx8dGhpcy5jb25zdHJ1Y3RvcigpfSxwdXNoOmgsc29ydDpjLnNvcnQsc3BsaWNlOmMuc3BsaWNlfSxyLmV4dGVuZD1yLmZuLmV4dGVuZD1mdW5jdGlvbigpe3ZhciBhLGIsYyxkLGUsZixnPWFyZ3VtZW50c1swXXx8e30saD0xLGk9YXJndW1lbnRzLmxlbmd0aCxqPSExO2ZvcihcImJvb2xlYW5cIj09dHlwZW9mIGcmJihqPWcsZz1hcmd1bWVudHNbaF18fHt9LGgrKyksXCJvYmplY3RcIj09dHlwZW9mIGd8fHIuaXNGdW5jdGlvbihnKXx8KGc9e30pLGg9PT1pJiYoZz10aGlzLGgtLSk7aDxpO2grKylpZihudWxsIT0oYT1hcmd1bWVudHNbaF0pKWZvcihiIGluIGEpYz1nW2JdLGQ9YVtiXSxnIT09ZCYmKGomJmQmJihyLmlzUGxhaW5PYmplY3QoZCl8fChlPXIuaXNBcnJheShkKSkpPyhlPyhlPSExLGY9YyYmci5pc0FycmF5KGMpP2M6W10pOmY9YyYmci5pc1BsYWluT2JqZWN0KGMpP2M6e30sZ1tiXT1yLmV4dGVuZChqLGYsZCkpOnZvaWQgMCE9PWQmJihnW2JdPWQpKTtyZXR1cm4gZ30sci5leHRlbmQoe2V4cGFuZG86XCJqUXVlcnlcIisocStNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXEQvZyxcIlwiKSxpc1JlYWR5OiEwLGVycm9yOmZ1bmN0aW9uKGEpe3Rocm93IG5ldyBFcnJvcihhKX0sbm9vcDpmdW5jdGlvbigpe30saXNGdW5jdGlvbjpmdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PT1yLnR5cGUoYSl9LGlzQXJyYXk6QXJyYXkuaXNBcnJheSxpc1dpbmRvdzpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmYT09PWEud2luZG93fSxpc051bWVyaWM6ZnVuY3Rpb24oYSl7dmFyIGI9ci50eXBlKGEpO3JldHVybihcIm51bWJlclwiPT09Ynx8XCJzdHJpbmdcIj09PWIpJiYhaXNOYU4oYS1wYXJzZUZsb2F0KGEpKX0saXNQbGFpbk9iamVjdDpmdW5jdGlvbihhKXt2YXIgYixjO3JldHVybiEoIWF8fFwiW29iamVjdCBPYmplY3RdXCIhPT1rLmNhbGwoYSkpJiYoIShiPWUoYSkpfHwoYz1sLmNhbGwoYixcImNvbnN0cnVjdG9yXCIpJiZiLmNvbnN0cnVjdG9yLFwiZnVuY3Rpb25cIj09dHlwZW9mIGMmJm0uY2FsbChjKT09PW4pKX0saXNFbXB0eU9iamVjdDpmdW5jdGlvbihhKXt2YXIgYjtmb3IoYiBpbiBhKXJldHVybiExO3JldHVybiEwfSx0eXBlOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hP2ErXCJcIjpcIm9iamVjdFwiPT10eXBlb2YgYXx8XCJmdW5jdGlvblwiPT10eXBlb2YgYT9qW2suY2FsbChhKV18fFwib2JqZWN0XCI6dHlwZW9mIGF9LGdsb2JhbEV2YWw6ZnVuY3Rpb24oYSl7cChhKX0sY2FtZWxDYXNlOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UodCxcIm1zLVwiKS5yZXBsYWNlKHUsdil9LG5vZGVOYW1lOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PWIudG9Mb3dlckNhc2UoKX0sZWFjaDpmdW5jdGlvbihhLGIpe3ZhciBjLGQ9MDtpZih3KGEpKXtmb3IoYz1hLmxlbmd0aDtkPGM7ZCsrKWlmKGIuY2FsbChhW2RdLGQsYVtkXSk9PT0hMSlicmVha31lbHNlIGZvcihkIGluIGEpaWYoYi5jYWxsKGFbZF0sZCxhW2RdKT09PSExKWJyZWFrO3JldHVybiBhfSx0cmltOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hP1wiXCI6KGErXCJcIikucmVwbGFjZShzLFwiXCIpfSxtYWtlQXJyYXk6ZnVuY3Rpb24oYSxiKXt2YXIgYz1ifHxbXTtyZXR1cm4gbnVsbCE9YSYmKHcoT2JqZWN0KGEpKT9yLm1lcmdlKGMsXCJzdHJpbmdcIj09dHlwZW9mIGE/W2FdOmEpOmguY2FsbChjLGEpKSxjfSxpbkFycmF5OmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbnVsbD09Yj8tMTppLmNhbGwoYixhLGMpfSxtZXJnZTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0rYi5sZW5ndGgsZD0wLGU9YS5sZW5ndGg7ZDxjO2QrKylhW2UrK109YltkXTtyZXR1cm4gYS5sZW5ndGg9ZSxhfSxncmVwOmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQsZT1bXSxmPTAsZz1hLmxlbmd0aCxoPSFjO2Y8ZztmKyspZD0hYihhW2ZdLGYpLGQhPT1oJiZlLnB1c2goYVtmXSk7cmV0dXJuIGV9LG1hcDpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPTAsaD1bXTtpZih3KGEpKWZvcihkPWEubGVuZ3RoO2Y8ZDtmKyspZT1iKGFbZl0sZixjKSxudWxsIT1lJiZoLnB1c2goZSk7ZWxzZSBmb3IoZiBpbiBhKWU9YihhW2ZdLGYsYyksbnVsbCE9ZSYmaC5wdXNoKGUpO3JldHVybiBnLmFwcGx5KFtdLGgpfSxndWlkOjEscHJveHk6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGU7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGImJihjPWFbYl0sYj1hLGE9Yyksci5pc0Z1bmN0aW9uKGEpKXJldHVybiBkPWYuY2FsbChhcmd1bWVudHMsMiksZT1mdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGJ8fHRoaXMsZC5jb25jYXQoZi5jYWxsKGFyZ3VtZW50cykpKX0sZS5ndWlkPWEuZ3VpZD1hLmd1aWR8fHIuZ3VpZCsrLGV9LG5vdzpEYXRlLm5vdyxzdXBwb3J0Om99KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihyLmZuW1N5bWJvbC5pdGVyYXRvcl09Y1tTeW1ib2wuaXRlcmF0b3JdKSxyLmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihhLGIpe2pbXCJbb2JqZWN0IFwiK2IrXCJdXCJdPWIudG9Mb3dlckNhc2UoKX0pO2Z1bmN0aW9uIHcoYSl7dmFyIGI9ISFhJiZcImxlbmd0aFwiaW4gYSYmYS5sZW5ndGgsYz1yLnR5cGUoYSk7cmV0dXJuXCJmdW5jdGlvblwiIT09YyYmIXIuaXNXaW5kb3coYSkmJihcImFycmF5XCI9PT1jfHwwPT09Ynx8XCJudW1iZXJcIj09dHlwZW9mIGImJmI+MCYmYi0xIGluIGEpfXZhciB4PWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxoLGksaixrLGwsbSxuLG8scCxxLHIscyx0LHU9XCJzaXp6bGVcIisxKm5ldyBEYXRlLHY9YS5kb2N1bWVudCx3PTAseD0wLHk9aGEoKSx6PWhhKCksQT1oYSgpLEI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT09PWImJihsPSEwKSwwfSxDPXt9Lmhhc093blByb3BlcnR5LEQ9W10sRT1ELnBvcCxGPUQucHVzaCxHPUQucHVzaCxIPUQuc2xpY2UsST1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGQ9YS5sZW5ndGg7YzxkO2MrKylpZihhW2NdPT09YilyZXR1cm4gYztyZXR1cm4tMX0sSj1cImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsSz1cIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsTD1cIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsTT1cIlxcXFxbXCIrSytcIiooXCIrTCtcIikoPzpcIitLK1wiKihbKl4kfCF+XT89KVwiK0srXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIitMK1wiKSl8KVwiK0srXCIqXFxcXF1cIixOPVwiOihcIitMK1wiKSg/OlxcXFwoKCgnKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIitNK1wiKSopfC4qKVxcXFwpfClcIixPPW5ldyBSZWdFeHAoSytcIitcIixcImdcIiksUD1uZXcgUmVnRXhwKFwiXlwiK0srXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiK0srXCIrJFwiLFwiZ1wiKSxRPW5ldyBSZWdFeHAoXCJeXCIrSytcIiosXCIrSytcIipcIiksUj1uZXcgUmVnRXhwKFwiXlwiK0srXCIqKFs+K35dfFwiK0srXCIpXCIrSytcIipcIiksUz1uZXcgUmVnRXhwKFwiPVwiK0srXCIqKFteXFxcXF0nXFxcIl0qPylcIitLK1wiKlxcXFxdXCIsXCJnXCIpLFQ9bmV3IFJlZ0V4cChOKSxVPW5ldyBSZWdFeHAoXCJeXCIrTCtcIiRcIiksVj17SUQ6bmV3IFJlZ0V4cChcIl4jKFwiK0wrXCIpXCIpLENMQVNTOm5ldyBSZWdFeHAoXCJeXFxcXC4oXCIrTCtcIilcIiksVEFHOm5ldyBSZWdFeHAoXCJeKFwiK0wrXCJ8WypdKVwiKSxBVFRSOm5ldyBSZWdFeHAoXCJeXCIrTSksUFNFVURPOm5ldyBSZWdFeHAoXCJeXCIrTiksQ0hJTEQ6bmV3IFJlZ0V4cChcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIrSytcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiK0srXCIqKD86KFsrLV18KVwiK0srXCIqKFxcXFxkKyl8KSlcIitLK1wiKlxcXFwpfClcIixcImlcIiksYm9vbDpuZXcgUmVnRXhwKFwiXig/OlwiK0orXCIpJFwiLFwiaVwiKSxuZWVkc0NvbnRleHQ6bmV3IFJlZ0V4cChcIl5cIitLK1wiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIitLK1wiKigoPzotXFxcXGQpP1xcXFxkKilcIitLK1wiKlxcXFwpfCkoPz1bXi1dfCQpXCIsXCJpXCIpfSxXPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksWD0vXmhcXGQkL2ksWT0vXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFo9L14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sJD0vWyt+XS8sXz1uZXcgUmVnRXhwKFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIrSytcIj98KFwiK0srXCIpfC4pXCIsXCJpZ1wiKSxhYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9XCIweFwiK2ItNjU1MzY7cmV0dXJuIGQhPT1kfHxjP2I6ZDwwP1N0cmluZy5mcm9tQ2hhckNvZGUoZCs2NTUzNik6U3RyaW5nLmZyb21DaGFyQ29kZShkPj4xMHw1NTI5NiwxMDIzJmR8NTYzMjApfSxiYT0vKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxjYT1mdW5jdGlvbihhLGIpe3JldHVybiBiP1wiXFwwXCI9PT1hP1wiXFx1ZmZmZFwiOmEuc2xpY2UoMCwtMSkrXCJcXFxcXCIrYS5jaGFyQ29kZUF0KGEubGVuZ3RoLTEpLnRvU3RyaW5nKDE2KStcIiBcIjpcIlxcXFxcIithfSxkYT1mdW5jdGlvbigpe20oKX0sZWE9dGEoZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGlzYWJsZWQ9PT0hMCYmKFwiZm9ybVwiaW4gYXx8XCJsYWJlbFwiaW4gYSl9LHtkaXI6XCJwYXJlbnROb2RlXCIsbmV4dDpcImxlZ2VuZFwifSk7dHJ5e0cuYXBwbHkoRD1ILmNhbGwodi5jaGlsZE5vZGVzKSx2LmNoaWxkTm9kZXMpLERbdi5jaGlsZE5vZGVzLmxlbmd0aF0ubm9kZVR5cGV9Y2F0Y2goZmEpe0c9e2FwcGx5OkQubGVuZ3RoP2Z1bmN0aW9uKGEsYil7Ri5hcHBseShhLEguY2FsbChiKSl9OmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5sZW5ndGgsZD0wO3doaWxlKGFbYysrXT1iW2QrK10pO2EubGVuZ3RoPWMtMX19fWZ1bmN0aW9uIGdhKGEsYixkLGUpe3ZhciBmLGgsaixrLGwsbyxyLHM9YiYmYi5vd25lckRvY3VtZW50LHc9Yj9iLm5vZGVUeXBlOjk7aWYoZD1kfHxbXSxcInN0cmluZ1wiIT10eXBlb2YgYXx8IWF8fDEhPT13JiY5IT09dyYmMTEhPT13KXJldHVybiBkO2lmKCFlJiYoKGI/Yi5vd25lckRvY3VtZW50fHxiOnYpIT09biYmbShiKSxiPWJ8fG4scCkpe2lmKDExIT09dyYmKGw9Wi5leGVjKGEpKSlpZihmPWxbMV0pe2lmKDk9PT13KXtpZighKGo9Yi5nZXRFbGVtZW50QnlJZChmKSkpcmV0dXJuIGQ7aWYoai5pZD09PWYpcmV0dXJuIGQucHVzaChqKSxkfWVsc2UgaWYocyYmKGo9cy5nZXRFbGVtZW50QnlJZChmKSkmJnQoYixqKSYmai5pZD09PWYpcmV0dXJuIGQucHVzaChqKSxkfWVsc2V7aWYobFsyXSlyZXR1cm4gRy5hcHBseShkLGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSkpLGQ7aWYoKGY9bFszXSkmJmMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSYmYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKXJldHVybiBHLmFwcGx5KGQsYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGYpKSxkfWlmKGMucXNhJiYhQVthK1wiIFwiXSYmKCFxfHwhcS50ZXN0KGEpKSl7aWYoMSE9PXcpcz1iLHI9YTtlbHNlIGlmKFwib2JqZWN0XCIhPT1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpeyhrPWIuZ2V0QXR0cmlidXRlKFwiaWRcIikpP2s9ay5yZXBsYWNlKGJhLGNhKTpiLnNldEF0dHJpYnV0ZShcImlkXCIsaz11KSxvPWcoYSksaD1vLmxlbmd0aDt3aGlsZShoLS0pb1toXT1cIiNcIitrK1wiIFwiK3NhKG9baF0pO3I9by5qb2luKFwiLFwiKSxzPSQudGVzdChhKSYmcWEoYi5wYXJlbnROb2RlKXx8Yn1pZihyKXRyeXtyZXR1cm4gRy5hcHBseShkLHMucXVlcnlTZWxlY3RvckFsbChyKSksZH1jYXRjaCh4KXt9ZmluYWxseXtrPT09dSYmYi5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKX19fXJldHVybiBpKGEucmVwbGFjZShQLFwiJDFcIiksYixkLGUpfWZ1bmN0aW9uIGhhKCl7dmFyIGE9W107ZnVuY3Rpb24gYihjLGUpe3JldHVybiBhLnB1c2goYytcIiBcIik+ZC5jYWNoZUxlbmd0aCYmZGVsZXRlIGJbYS5zaGlmdCgpXSxiW2MrXCIgXCJdPWV9cmV0dXJuIGJ9ZnVuY3Rpb24gaWEoYSl7cmV0dXJuIGFbdV09ITAsYX1mdW5jdGlvbiBqYShhKXt2YXIgYj1uLmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTt0cnl7cmV0dXJuISFhKGIpfWNhdGNoKGMpe3JldHVybiExfWZpbmFsbHl7Yi5wYXJlbnROb2RlJiZiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYiksYj1udWxsfX1mdW5jdGlvbiBrYShhLGIpe3ZhciBjPWEuc3BsaXQoXCJ8XCIpLGU9Yy5sZW5ndGg7d2hpbGUoZS0tKWQuYXR0ckhhbmRsZVtjW2VdXT1ifWZ1bmN0aW9uIGxhKGEsYil7dmFyIGM9YiYmYSxkPWMmJjE9PT1hLm5vZGVUeXBlJiYxPT09Yi5ub2RlVHlwZSYmYS5zb3VyY2VJbmRleC1iLnNvdXJjZUluZGV4O2lmKGQpcmV0dXJuIGQ7aWYoYyl3aGlsZShjPWMubmV4dFNpYmxpbmcpaWYoYz09PWIpcmV0dXJuLTE7cmV0dXJuIGE/MTotMX1mdW5jdGlvbiBtYShhKXtyZXR1cm4gZnVuY3Rpb24oYil7dmFyIGM9Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PWMmJmIudHlwZT09PWF9fWZ1bmN0aW9uIG5hKGEpe3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuKFwiaW5wdXRcIj09PWN8fFwiYnV0dG9uXCI9PT1jKSYmYi50eXBlPT09YX19ZnVuY3Rpb24gb2EoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVyblwiZm9ybVwiaW4gYj9iLnBhcmVudE5vZGUmJmIuZGlzYWJsZWQ9PT0hMT9cImxhYmVsXCJpbiBiP1wibGFiZWxcImluIGIucGFyZW50Tm9kZT9iLnBhcmVudE5vZGUuZGlzYWJsZWQ9PT1hOmIuZGlzYWJsZWQ9PT1hOmIuaXNEaXNhYmxlZD09PWF8fGIuaXNEaXNhYmxlZCE9PSFhJiZlYShiKT09PWE6Yi5kaXNhYmxlZD09PWE6XCJsYWJlbFwiaW4gYiYmYi5kaXNhYmxlZD09PWF9fWZ1bmN0aW9uIHBhKGEpe3JldHVybiBpYShmdW5jdGlvbihiKXtyZXR1cm4gYj0rYixpYShmdW5jdGlvbihjLGQpe3ZhciBlLGY9YShbXSxjLmxlbmd0aCxiKSxnPWYubGVuZ3RoO3doaWxlKGctLSljW2U9ZltnXV0mJihjW2VdPSEoZFtlXT1jW2VdKSl9KX0pfWZ1bmN0aW9uIHFhKGEpe3JldHVybiBhJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5nZXRFbGVtZW50c0J5VGFnTmFtZSYmYX1jPWdhLnN1cHBvcnQ9e30sZj1nYS5pc1hNTD1mdW5jdGlvbihhKXt2YXIgYj1hJiYoYS5vd25lckRvY3VtZW50fHxhKS5kb2N1bWVudEVsZW1lbnQ7cmV0dXJuISFiJiZcIkhUTUxcIiE9PWIubm9kZU5hbWV9LG09Z2Euc2V0RG9jdW1lbnQ9ZnVuY3Rpb24oYSl7dmFyIGIsZSxnPWE/YS5vd25lckRvY3VtZW50fHxhOnY7cmV0dXJuIGchPT1uJiY5PT09Zy5ub2RlVHlwZSYmZy5kb2N1bWVudEVsZW1lbnQ/KG49ZyxvPW4uZG9jdW1lbnRFbGVtZW50LHA9IWYobiksdiE9PW4mJihlPW4uZGVmYXVsdFZpZXcpJiZlLnRvcCE9PWUmJihlLmFkZEV2ZW50TGlzdGVuZXI/ZS5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsZGEsITEpOmUuYXR0YWNoRXZlbnQmJmUuYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLGRhKSksYy5hdHRyaWJ1dGVzPWphKGZ1bmN0aW9uKGEpe3JldHVybiBhLmNsYXNzTmFtZT1cImlcIiwhYS5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIil9KSxjLmdldEVsZW1lbnRzQnlUYWdOYW1lPWphKGZ1bmN0aW9uKGEpe3JldHVybiBhLmFwcGVuZENoaWxkKG4uY3JlYXRlQ29tbWVudChcIlwiKSksIWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aH0pLGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZT1ZLnRlc3Qobi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSxjLmdldEJ5SWQ9amEoZnVuY3Rpb24oYSl7cmV0dXJuIG8uYXBwZW5kQ2hpbGQoYSkuaWQ9dSwhbi5nZXRFbGVtZW50c0J5TmFtZXx8IW4uZ2V0RWxlbWVudHNCeU5hbWUodSkubGVuZ3RofSksYy5nZXRCeUlkPyhkLmZpbHRlci5JRD1mdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoXyxhYSk7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBhLmdldEF0dHJpYnV0ZShcImlkXCIpPT09Yn19LGQuZmluZC5JRD1mdW5jdGlvbihhLGIpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBiLmdldEVsZW1lbnRCeUlkJiZwKXt2YXIgYz1iLmdldEVsZW1lbnRCeUlkKGEpO3JldHVybiBjP1tjXTpbXX19KTooZC5maWx0ZXIuSUQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKF8sYWEpO3JldHVybiBmdW5jdGlvbihhKXt2YXIgYz1cInVuZGVmaW5lZFwiIT10eXBlb2YgYS5nZXRBdHRyaWJ1dGVOb2RlJiZhLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtyZXR1cm4gYyYmYy52YWx1ZT09PWJ9fSxkLmZpbmQuSUQ9ZnVuY3Rpb24oYSxiKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgYi5nZXRFbGVtZW50QnlJZCYmcCl7dmFyIGMsZCxlLGY9Yi5nZXRFbGVtZW50QnlJZChhKTtpZihmKXtpZihjPWYuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpLGMmJmMudmFsdWU9PT1hKXJldHVybltmXTtlPWIuZ2V0RWxlbWVudHNCeU5hbWUoYSksZD0wO3doaWxlKGY9ZVtkKytdKWlmKGM9Zi5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIiksYyYmYy52YWx1ZT09PWEpcmV0dXJuW2ZdfXJldHVybltdfX0pLGQuZmluZC5UQUc9Yy5nZXRFbGVtZW50c0J5VGFnTmFtZT9mdW5jdGlvbihhLGIpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBiLmdldEVsZW1lbnRzQnlUYWdOYW1lP2IuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSk6Yy5xc2E/Yi5xdWVyeVNlbGVjdG9yQWxsKGEpOnZvaWQgMH06ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPVtdLGU9MCxmPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSk7aWYoXCIqXCI9PT1hKXt3aGlsZShjPWZbZSsrXSkxPT09Yy5ub2RlVHlwZSYmZC5wdXNoKGMpO3JldHVybiBkfXJldHVybiBmfSxkLmZpbmQuQ0xBU1M9Yy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lJiZmdW5jdGlvbihhLGIpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUmJnApcmV0dXJuIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShhKX0scj1bXSxxPVtdLChjLnFzYT1ZLnRlc3Qobi5xdWVyeVNlbGVjdG9yQWxsKSkmJihqYShmdW5jdGlvbihhKXtvLmFwcGVuZENoaWxkKGEpLmlubmVySFRNTD1cIjxhIGlkPSdcIit1K1wiJz48L2E+PHNlbGVjdCBpZD0nXCIrdStcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiLGEucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCYmcS5wdXNoKFwiWypeJF09XCIrSytcIiooPzonJ3xcXFwiXFxcIilcIiksYS5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGh8fHEucHVzaChcIlxcXFxbXCIrSytcIiooPzp2YWx1ZXxcIitKK1wiKVwiKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbaWR+PVwiK3UrXCItXVwiKS5sZW5ndGh8fHEucHVzaChcIn49XCIpLGEucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aHx8cS5wdXNoKFwiOmNoZWNrZWRcIiksYS5xdWVyeVNlbGVjdG9yQWxsKFwiYSNcIit1K1wiKypcIikubGVuZ3RofHxxLnB1c2goXCIuIy4rWyt+XVwiKX0pLGphKGZ1bmN0aW9uKGEpe2EuaW5uZXJIVE1MPVwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT48c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7dmFyIGI9bi5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7Yi5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJoaWRkZW5cIiksYS5hcHBlbmRDaGlsZChiKS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJEXCIpLGEucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCYmcS5wdXNoKFwibmFtZVwiK0srXCIqWypeJHwhfl0/PVwiKSwyIT09YS5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoJiZxLnB1c2goXCI6ZW5hYmxlZFwiLFwiOmRpc2FibGVkXCIpLG8uYXBwZW5kQ2hpbGQoYSkuZGlzYWJsZWQ9ITAsMiE9PWEucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGgmJnEucHVzaChcIjplbmFibGVkXCIsXCI6ZGlzYWJsZWRcIiksYS5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKSxxLnB1c2goXCIsLio6XCIpfSkpLChjLm1hdGNoZXNTZWxlY3Rvcj1ZLnRlc3Qocz1vLm1hdGNoZXN8fG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yfHxvLm1vek1hdGNoZXNTZWxlY3Rvcnx8by5vTWF0Y2hlc1NlbGVjdG9yfHxvLm1zTWF0Y2hlc1NlbGVjdG9yKSkmJmphKGZ1bmN0aW9uKGEpe2MuZGlzY29ubmVjdGVkTWF0Y2g9cy5jYWxsKGEsXCIqXCIpLHMuY2FsbChhLFwiW3MhPScnXTp4XCIpLHIucHVzaChcIiE9XCIsTil9KSxxPXEubGVuZ3RoJiZuZXcgUmVnRXhwKHEuam9pbihcInxcIikpLHI9ci5sZW5ndGgmJm5ldyBSZWdFeHAoci5qb2luKFwifFwiKSksYj1ZLnRlc3Qoby5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiksdD1ifHxZLnRlc3Qoby5jb250YWlucyk/ZnVuY3Rpb24oYSxiKXt2YXIgYz05PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLGQ9YiYmYi5wYXJlbnROb2RlO3JldHVybiBhPT09ZHx8ISghZHx8MSE9PWQubm9kZVR5cGV8fCEoYy5jb250YWlucz9jLmNvbnRhaW5zKGQpOmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24mJjE2JmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZCkpKX06ZnVuY3Rpb24oYSxiKXtpZihiKXdoaWxlKGI9Yi5wYXJlbnROb2RlKWlmKGI9PT1hKXJldHVybiEwO3JldHVybiExfSxCPWI/ZnVuY3Rpb24oYSxiKXtpZihhPT09YilyZXR1cm4gbD0hMCwwO3ZhciBkPSFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uLSFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO3JldHVybiBkP2Q6KGQ9KGEub3duZXJEb2N1bWVudHx8YSk9PT0oYi5vd25lckRvY3VtZW50fHxiKT9hLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpOjEsMSZkfHwhYy5zb3J0RGV0YWNoZWQmJmIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSk9PT1kP2E9PT1ufHxhLm93bmVyRG9jdW1lbnQ9PT12JiZ0KHYsYSk/LTE6Yj09PW58fGIub3duZXJEb2N1bWVudD09PXYmJnQodixiKT8xOms/SShrLGEpLUkoayxiKTowOjQmZD8tMToxKX06ZnVuY3Rpb24oYSxiKXtpZihhPT09YilyZXR1cm4gbD0hMCwwO3ZhciBjLGQ9MCxlPWEucGFyZW50Tm9kZSxmPWIucGFyZW50Tm9kZSxnPVthXSxoPVtiXTtpZighZXx8IWYpcmV0dXJuIGE9PT1uPy0xOmI9PT1uPzE6ZT8tMTpmPzE6az9JKGssYSktSShrLGIpOjA7aWYoZT09PWYpcmV0dXJuIGxhKGEsYik7Yz1hO3doaWxlKGM9Yy5wYXJlbnROb2RlKWcudW5zaGlmdChjKTtjPWI7d2hpbGUoYz1jLnBhcmVudE5vZGUpaC51bnNoaWZ0KGMpO3doaWxlKGdbZF09PT1oW2RdKWQrKztyZXR1cm4gZD9sYShnW2RdLGhbZF0pOmdbZF09PT12Py0xOmhbZF09PT12PzE6MH0sbik6bn0sZ2EubWF0Y2hlcz1mdW5jdGlvbihhLGIpe3JldHVybiBnYShhLG51bGwsbnVsbCxiKX0sZ2EubWF0Y2hlc1NlbGVjdG9yPWZ1bmN0aW9uKGEsYil7aWYoKGEub3duZXJEb2N1bWVudHx8YSkhPT1uJiZtKGEpLGI9Yi5yZXBsYWNlKFMsXCI9JyQxJ11cIiksYy5tYXRjaGVzU2VsZWN0b3ImJnAmJiFBW2IrXCIgXCJdJiYoIXJ8fCFyLnRlc3QoYikpJiYoIXF8fCFxLnRlc3QoYikpKXRyeXt2YXIgZD1zLmNhbGwoYSxiKTtpZihkfHxjLmRpc2Nvbm5lY3RlZE1hdGNofHxhLmRvY3VtZW50JiYxMSE9PWEuZG9jdW1lbnQubm9kZVR5cGUpcmV0dXJuIGR9Y2F0Y2goZSl7fXJldHVybiBnYShiLG4sbnVsbCxbYV0pLmxlbmd0aD4wfSxnYS5jb250YWlucz1mdW5jdGlvbihhLGIpe3JldHVybihhLm93bmVyRG9jdW1lbnR8fGEpIT09biYmbShhKSx0KGEsYil9LGdhLmF0dHI9ZnVuY3Rpb24oYSxiKXsoYS5vd25lckRvY3VtZW50fHxhKSE9PW4mJm0oYSk7dmFyIGU9ZC5hdHRySGFuZGxlW2IudG9Mb3dlckNhc2UoKV0sZj1lJiZDLmNhbGwoZC5hdHRySGFuZGxlLGIudG9Mb3dlckNhc2UoKSk/ZShhLGIsIXApOnZvaWQgMDtyZXR1cm4gdm9pZCAwIT09Zj9mOmMuYXR0cmlidXRlc3x8IXA/YS5nZXRBdHRyaWJ1dGUoYik6KGY9YS5nZXRBdHRyaWJ1dGVOb2RlKGIpKSYmZi5zcGVjaWZpZWQ/Zi52YWx1ZTpudWxsfSxnYS5lc2NhcGU9ZnVuY3Rpb24oYSl7cmV0dXJuKGErXCJcIikucmVwbGFjZShiYSxjYSl9LGdhLmVycm9yPWZ1bmN0aW9uKGEpe3Rocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiK2EpfSxnYS51bmlxdWVTb3J0PWZ1bmN0aW9uKGEpe3ZhciBiLGQ9W10sZT0wLGY9MDtpZihsPSFjLmRldGVjdER1cGxpY2F0ZXMsaz0hYy5zb3J0U3RhYmxlJiZhLnNsaWNlKDApLGEuc29ydChCKSxsKXt3aGlsZShiPWFbZisrXSliPT09YVtmXSYmKGU9ZC5wdXNoKGYpKTt3aGlsZShlLS0pYS5zcGxpY2UoZFtlXSwxKX1yZXR1cm4gaz1udWxsLGF9LGU9Z2EuZ2V0VGV4dD1mdW5jdGlvbihhKXt2YXIgYixjPVwiXCIsZD0wLGY9YS5ub2RlVHlwZTtpZihmKXtpZigxPT09Znx8OT09PWZ8fDExPT09Zil7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGEudGV4dENvbnRlbnQpcmV0dXJuIGEudGV4dENvbnRlbnQ7Zm9yKGE9YS5maXJzdENoaWxkO2E7YT1hLm5leHRTaWJsaW5nKWMrPWUoYSl9ZWxzZSBpZigzPT09Znx8ND09PWYpcmV0dXJuIGEubm9kZVZhbHVlfWVsc2Ugd2hpbGUoYj1hW2QrK10pYys9ZShiKTtyZXR1cm4gY30sZD1nYS5zZWxlY3RvcnM9e2NhY2hlTGVuZ3RoOjUwLGNyZWF0ZVBzZXVkbzppYSxtYXRjaDpWLGF0dHJIYW5kbGU6e30sZmluZDp7fSxyZWxhdGl2ZTp7XCI+XCI6e2RpcjpcInBhcmVudE5vZGVcIixmaXJzdDohMH0sXCIgXCI6e2RpcjpcInBhcmVudE5vZGVcIn0sXCIrXCI6e2RpcjpcInByZXZpb3VzU2libGluZ1wiLGZpcnN0OiEwfSxcIn5cIjp7ZGlyOlwicHJldmlvdXNTaWJsaW5nXCJ9fSxwcmVGaWx0ZXI6e0FUVFI6ZnVuY3Rpb24oYSl7cmV0dXJuIGFbMV09YVsxXS5yZXBsYWNlKF8sYWEpLGFbM109KGFbM118fGFbNF18fGFbNV18fFwiXCIpLnJlcGxhY2UoXyxhYSksXCJ+PVwiPT09YVsyXSYmKGFbM109XCIgXCIrYVszXStcIiBcIiksYS5zbGljZSgwLDQpfSxDSElMRDpmdW5jdGlvbihhKXtyZXR1cm4gYVsxXT1hWzFdLnRvTG93ZXJDYXNlKCksXCJudGhcIj09PWFbMV0uc2xpY2UoMCwzKT8oYVszXXx8Z2EuZXJyb3IoYVswXSksYVs0XT0rKGFbNF0/YVs1XSsoYVs2XXx8MSk6MiooXCJldmVuXCI9PT1hWzNdfHxcIm9kZFwiPT09YVszXSkpLGFbNV09KyhhWzddK2FbOF18fFwib2RkXCI9PT1hWzNdKSk6YVszXSYmZ2EuZXJyb3IoYVswXSksYX0sUFNFVURPOmZ1bmN0aW9uKGEpe3ZhciBiLGM9IWFbNl0mJmFbMl07cmV0dXJuIFYuQ0hJTEQudGVzdChhWzBdKT9udWxsOihhWzNdP2FbMl09YVs0XXx8YVs1XXx8XCJcIjpjJiZULnRlc3QoYykmJihiPWcoYywhMCkpJiYoYj1jLmluZGV4T2YoXCIpXCIsYy5sZW5ndGgtYiktYy5sZW5ndGgpJiYoYVswXT1hWzBdLnNsaWNlKDAsYiksYVsyXT1jLnNsaWNlKDAsYikpLGEuc2xpY2UoMCwzKSl9fSxmaWx0ZXI6e1RBRzpmdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoXyxhYSkudG9Mb3dlckNhc2UoKTtyZXR1cm5cIipcIj09PWE/ZnVuY3Rpb24oKXtyZXR1cm4hMH06ZnVuY3Rpb24oYSl7cmV0dXJuIGEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PWJ9fSxDTEFTUzpmdW5jdGlvbihhKXt2YXIgYj15W2ErXCIgXCJdO3JldHVybiBifHwoYj1uZXcgUmVnRXhwKFwiKF58XCIrSytcIilcIithK1wiKFwiK0srXCJ8JClcIikpJiZ5KGEsZnVuY3Rpb24oYSl7cmV0dXJuIGIudGVzdChcInN0cmluZ1wiPT10eXBlb2YgYS5jbGFzc05hbWUmJmEuY2xhc3NOYW1lfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5nZXRBdHRyaWJ1dGUmJmEuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCIpfSl9LEFUVFI6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBmdW5jdGlvbihkKXt2YXIgZT1nYS5hdHRyKGQsYSk7cmV0dXJuIG51bGw9PWU/XCIhPVwiPT09YjohYnx8KGUrPVwiXCIsXCI9XCI9PT1iP2U9PT1jOlwiIT1cIj09PWI/ZSE9PWM6XCJePVwiPT09Yj9jJiYwPT09ZS5pbmRleE9mKGMpOlwiKj1cIj09PWI/YyYmZS5pbmRleE9mKGMpPi0xOlwiJD1cIj09PWI/YyYmZS5zbGljZSgtYy5sZW5ndGgpPT09YzpcIn49XCI9PT1iPyhcIiBcIitlLnJlcGxhY2UoTyxcIiBcIikrXCIgXCIpLmluZGV4T2YoYyk+LTE6XCJ8PVwiPT09YiYmKGU9PT1jfHxlLnNsaWNlKDAsYy5sZW5ndGgrMSk9PT1jK1wiLVwiKSl9fSxDSElMRDpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPVwibnRoXCIhPT1hLnNsaWNlKDAsMyksZz1cImxhc3RcIiE9PWEuc2xpY2UoLTQpLGg9XCJvZi10eXBlXCI9PT1iO3JldHVybiAxPT09ZCYmMD09PWU/ZnVuY3Rpb24oYSl7cmV0dXJuISFhLnBhcmVudE5vZGV9OmZ1bmN0aW9uKGIsYyxpKXt2YXIgaixrLGwsbSxuLG8scD1mIT09Zz9cIm5leHRTaWJsaW5nXCI6XCJwcmV2aW91c1NpYmxpbmdcIixxPWIucGFyZW50Tm9kZSxyPWgmJmIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxzPSFpJiYhaCx0PSExO2lmKHEpe2lmKGYpe3doaWxlKHApe209Yjt3aGlsZShtPW1bcF0paWYoaD9tLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1yOjE9PT1tLm5vZGVUeXBlKXJldHVybiExO289cD1cIm9ubHlcIj09PWEmJiFvJiZcIm5leHRTaWJsaW5nXCJ9cmV0dXJuITB9aWYobz1bZz9xLmZpcnN0Q2hpbGQ6cS5sYXN0Q2hpbGRdLGcmJnMpe209cSxsPW1bdV18fChtW3VdPXt9KSxrPWxbbS51bmlxdWVJRF18fChsW20udW5pcXVlSURdPXt9KSxqPWtbYV18fFtdLG49alswXT09PXcmJmpbMV0sdD1uJiZqWzJdLG09biYmcS5jaGlsZE5vZGVzW25dO3doaWxlKG09KytuJiZtJiZtW3BdfHwodD1uPTApfHxvLnBvcCgpKWlmKDE9PT1tLm5vZGVUeXBlJiYrK3QmJm09PT1iKXtrW2FdPVt3LG4sdF07YnJlYWt9fWVsc2UgaWYocyYmKG09YixsPW1bdV18fChtW3VdPXt9KSxrPWxbbS51bmlxdWVJRF18fChsW20udW5pcXVlSURdPXt9KSxqPWtbYV18fFtdLG49alswXT09PXcmJmpbMV0sdD1uKSx0PT09ITEpd2hpbGUobT0rK24mJm0mJm1bcF18fCh0PW49MCl8fG8ucG9wKCkpaWYoKGg/bS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09cjoxPT09bS5ub2RlVHlwZSkmJisrdCYmKHMmJihsPW1bdV18fChtW3VdPXt9KSxrPWxbbS51bmlxdWVJRF18fChsW20udW5pcXVlSURdPXt9KSxrW2FdPVt3LHRdKSxtPT09YikpYnJlYWs7cmV0dXJuIHQtPWUsdD09PWR8fHQlZD09PTAmJnQvZD49MH19fSxQU0VVRE86ZnVuY3Rpb24oYSxiKXt2YXIgYyxlPWQucHNldWRvc1thXXx8ZC5zZXRGaWx0ZXJzW2EudG9Mb3dlckNhc2UoKV18fGdhLmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIithKTtyZXR1cm4gZVt1XT9lKGIpOmUubGVuZ3RoPjE/KGM9W2EsYSxcIlwiLGJdLGQuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShhLnRvTG93ZXJDYXNlKCkpP2lhKGZ1bmN0aW9uKGEsYyl7dmFyIGQsZj1lKGEsYiksZz1mLmxlbmd0aDt3aGlsZShnLS0pZD1JKGEsZltnXSksYVtkXT0hKGNbZF09ZltnXSl9KTpmdW5jdGlvbihhKXtyZXR1cm4gZShhLDAsYyl9KTplfX0scHNldWRvczp7bm90OmlhKGZ1bmN0aW9uKGEpe3ZhciBiPVtdLGM9W10sZD1oKGEucmVwbGFjZShQLFwiJDFcIikpO3JldHVybiBkW3VdP2lhKGZ1bmN0aW9uKGEsYixjLGUpe3ZhciBmLGc9ZChhLG51bGwsZSxbXSksaD1hLmxlbmd0aDt3aGlsZShoLS0pKGY9Z1toXSkmJihhW2hdPSEoYltoXT1mKSl9KTpmdW5jdGlvbihhLGUsZil7cmV0dXJuIGJbMF09YSxkKGIsbnVsbCxmLGMpLGJbMF09bnVsbCwhYy5wb3AoKX19KSxoYXM6aWEoZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVybiBnYShhLGIpLmxlbmd0aD4wfX0pLGNvbnRhaW5zOmlhKGZ1bmN0aW9uKGEpe3JldHVybiBhPWEucmVwbGFjZShfLGFhKSxmdW5jdGlvbihiKXtyZXR1cm4oYi50ZXh0Q29udGVudHx8Yi5pbm5lclRleHR8fGUoYikpLmluZGV4T2YoYSk+LTF9fSksbGFuZzppYShmdW5jdGlvbihhKXtyZXR1cm4gVS50ZXN0KGF8fFwiXCIpfHxnYS5lcnJvcihcInVuc3VwcG9ydGVkIGxhbmc6IFwiK2EpLGE9YS5yZXBsYWNlKF8sYWEpLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oYil7dmFyIGM7ZG8gaWYoYz1wP2IubGFuZzpiLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpfHxiLmdldEF0dHJpYnV0ZShcImxhbmdcIikpcmV0dXJuIGM9Yy50b0xvd2VyQ2FzZSgpLGM9PT1hfHwwPT09Yy5pbmRleE9mKGErXCItXCIpO3doaWxlKChiPWIucGFyZW50Tm9kZSkmJjE9PT1iLm5vZGVUeXBlKTtyZXR1cm4hMX19KSx0YXJnZXQ6ZnVuY3Rpb24oYil7dmFyIGM9YS5sb2NhdGlvbiYmYS5sb2NhdGlvbi5oYXNoO3JldHVybiBjJiZjLnNsaWNlKDEpPT09Yi5pZH0scm9vdDpmdW5jdGlvbihhKXtyZXR1cm4gYT09PW99LGZvY3VzOmZ1bmN0aW9uKGEpe3JldHVybiBhPT09bi5hY3RpdmVFbGVtZW50JiYoIW4uaGFzRm9jdXN8fG4uaGFzRm9jdXMoKSkmJiEhKGEudHlwZXx8YS5ocmVmfHx+YS50YWJJbmRleCl9LGVuYWJsZWQ6b2EoITEpLGRpc2FibGVkOm9hKCEwKSxjaGVja2VkOmZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm5cImlucHV0XCI9PT1iJiYhIWEuY2hlY2tlZHx8XCJvcHRpb25cIj09PWImJiEhYS5zZWxlY3RlZH0sc2VsZWN0ZWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsYS5zZWxlY3RlZD09PSEwfSxlbXB0eTpmdW5jdGlvbihhKXtmb3IoYT1hLmZpcnN0Q2hpbGQ7YTthPWEubmV4dFNpYmxpbmcpaWYoYS5ub2RlVHlwZTw2KXJldHVybiExO3JldHVybiEwfSxwYXJlbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIWQucHNldWRvcy5lbXB0eShhKX0saGVhZGVyOmZ1bmN0aW9uKGEpe3JldHVybiBYLnRlc3QoYS5ub2RlTmFtZSl9LGlucHV0OmZ1bmN0aW9uKGEpe3JldHVybiBXLnRlc3QoYS5ub2RlTmFtZSl9LGJ1dHRvbjpmdW5jdGlvbihhKXt2YXIgYj1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09YiYmXCJidXR0b25cIj09PWEudHlwZXx8XCJidXR0b25cIj09PWJ9LHRleHQ6ZnVuY3Rpb24oYSl7dmFyIGI7cmV0dXJuXCJpbnB1dFwiPT09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpJiZcInRleHRcIj09PWEudHlwZSYmKG51bGw9PShiPWEuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSl8fFwidGV4dFwiPT09Yi50b0xvd2VyQ2FzZSgpKX0sZmlyc3Q6cGEoZnVuY3Rpb24oKXtyZXR1cm5bMF19KSxsYXN0OnBhKGZ1bmN0aW9uKGEsYil7cmV0dXJuW2ItMV19KSxlcTpwYShmdW5jdGlvbihhLGIsYyl7cmV0dXJuW2M8MD9jK2I6Y119KSxldmVuOnBhKGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxiO2MrPTIpYS5wdXNoKGMpO3JldHVybiBhfSksb2RkOnBhKGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTE7YzxiO2MrPTIpYS5wdXNoKGMpO3JldHVybiBhfSksbHQ6cGEoZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1jPDA/YytiOmM7LS1kPj0wOylhLnB1c2goZCk7cmV0dXJuIGF9KSxndDpwYShmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWM8MD9jK2I6YzsrK2Q8YjspYS5wdXNoKGQpO3JldHVybiBhfSl9fSxkLnBzZXVkb3MubnRoPWQucHNldWRvcy5lcTtmb3IoYiBpbntyYWRpbzohMCxjaGVja2JveDohMCxmaWxlOiEwLHBhc3N3b3JkOiEwLGltYWdlOiEwfSlkLnBzZXVkb3NbYl09bWEoYik7Zm9yKGIgaW57c3VibWl0OiEwLHJlc2V0OiEwfSlkLnBzZXVkb3NbYl09bmEoYik7ZnVuY3Rpb24gcmEoKXt9cmEucHJvdG90eXBlPWQuZmlsdGVycz1kLnBzZXVkb3MsZC5zZXRGaWx0ZXJzPW5ldyByYSxnPWdhLnRva2VuaXplPWZ1bmN0aW9uKGEsYil7dmFyIGMsZSxmLGcsaCxpLGosaz16W2ErXCIgXCJdO2lmKGspcmV0dXJuIGI/MDprLnNsaWNlKDApO2g9YSxpPVtdLGo9ZC5wcmVGaWx0ZXI7d2hpbGUoaCl7YyYmIShlPVEuZXhlYyhoKSl8fChlJiYoaD1oLnNsaWNlKGVbMF0ubGVuZ3RoKXx8aCksaS5wdXNoKGY9W10pKSxjPSExLChlPVIuZXhlYyhoKSkmJihjPWUuc2hpZnQoKSxmLnB1c2goe3ZhbHVlOmMsdHlwZTplWzBdLnJlcGxhY2UoUCxcIiBcIil9KSxoPWguc2xpY2UoYy5sZW5ndGgpKTtmb3IoZyBpbiBkLmZpbHRlcikhKGU9VltnXS5leGVjKGgpKXx8altnXSYmIShlPWpbZ10oZSkpfHwoYz1lLnNoaWZ0KCksZi5wdXNoKHt2YWx1ZTpjLHR5cGU6ZyxtYXRjaGVzOmV9KSxoPWguc2xpY2UoYy5sZW5ndGgpKTtpZighYylicmVha31yZXR1cm4gYj9oLmxlbmd0aDpoP2dhLmVycm9yKGEpOnooYSxpKS5zbGljZSgwKX07ZnVuY3Rpb24gc2EoYSl7Zm9yKHZhciBiPTAsYz1hLmxlbmd0aCxkPVwiXCI7YjxjO2IrKylkKz1hW2JdLnZhbHVlO3JldHVybiBkfWZ1bmN0aW9uIHRhKGEsYixjKXt2YXIgZD1iLmRpcixlPWIubmV4dCxmPWV8fGQsZz1jJiZcInBhcmVudE5vZGVcIj09PWYsaD14Kys7cmV0dXJuIGIuZmlyc3Q/ZnVuY3Rpb24oYixjLGUpe3doaWxlKGI9YltkXSlpZigxPT09Yi5ub2RlVHlwZXx8ZylyZXR1cm4gYShiLGMsZSk7cmV0dXJuITF9OmZ1bmN0aW9uKGIsYyxpKXt2YXIgaixrLGwsbT1bdyxoXTtpZihpKXt3aGlsZShiPWJbZF0paWYoKDE9PT1iLm5vZGVUeXBlfHxnKSYmYShiLGMsaSkpcmV0dXJuITB9ZWxzZSB3aGlsZShiPWJbZF0paWYoMT09PWIubm9kZVR5cGV8fGcpaWYobD1iW3VdfHwoYlt1XT17fSksaz1sW2IudW5pcXVlSURdfHwobFtiLnVuaXF1ZUlEXT17fSksZSYmZT09PWIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSliPWJbZF18fGI7ZWxzZXtpZigoaj1rW2ZdKSYmalswXT09PXcmJmpbMV09PT1oKXJldHVybiBtWzJdPWpbMl07aWYoa1tmXT1tLG1bMl09YShiLGMsaSkpcmV0dXJuITB9cmV0dXJuITF9fWZ1bmN0aW9uIHVhKGEpe3JldHVybiBhLmxlbmd0aD4xP2Z1bmN0aW9uKGIsYyxkKXt2YXIgZT1hLmxlbmd0aDt3aGlsZShlLS0paWYoIWFbZV0oYixjLGQpKXJldHVybiExO3JldHVybiEwfTphWzBdfWZ1bmN0aW9uIHZhKGEsYixjKXtmb3IodmFyIGQ9MCxlPWIubGVuZ3RoO2Q8ZTtkKyspZ2EoYSxiW2RdLGMpO3JldHVybiBjfWZ1bmN0aW9uIHdhKGEsYixjLGQsZSl7Zm9yKHZhciBmLGc9W10saD0wLGk9YS5sZW5ndGgsaj1udWxsIT1iO2g8aTtoKyspKGY9YVtoXSkmJihjJiYhYyhmLGQsZSl8fChnLnB1c2goZiksaiYmYi5wdXNoKGgpKSk7cmV0dXJuIGd9ZnVuY3Rpb24geGEoYSxiLGMsZCxlLGYpe3JldHVybiBkJiYhZFt1XSYmKGQ9eGEoZCkpLGUmJiFlW3VdJiYoZT14YShlLGYpKSxpYShmdW5jdGlvbihmLGcsaCxpKXt2YXIgaixrLGwsbT1bXSxuPVtdLG89Zy5sZW5ndGgscD1mfHx2YShifHxcIipcIixoLm5vZGVUeXBlP1toXTpoLFtdKSxxPSFhfHwhZiYmYj9wOndhKHAsbSxhLGgsaSkscj1jP2V8fChmP2E6b3x8ZCk/W106ZzpxO2lmKGMmJmMocSxyLGgsaSksZCl7aj13YShyLG4pLGQoaixbXSxoLGkpLGs9ai5sZW5ndGg7d2hpbGUoay0tKShsPWpba10pJiYocltuW2tdXT0hKHFbbltrXV09bCkpfWlmKGYpe2lmKGV8fGEpe2lmKGUpe2o9W10saz1yLmxlbmd0aDt3aGlsZShrLS0pKGw9cltrXSkmJmoucHVzaChxW2tdPWwpO2UobnVsbCxyPVtdLGosaSl9az1yLmxlbmd0aDt3aGlsZShrLS0pKGw9cltrXSkmJihqPWU/SShmLGwpOm1ba10pPi0xJiYoZltqXT0hKGdbal09bCkpfX1lbHNlIHI9d2Eocj09PWc/ci5zcGxpY2UobyxyLmxlbmd0aCk6ciksZT9lKG51bGwsZyxyLGkpOkcuYXBwbHkoZyxyKX0pfWZ1bmN0aW9uIHlhKGEpe2Zvcih2YXIgYixjLGUsZj1hLmxlbmd0aCxnPWQucmVsYXRpdmVbYVswXS50eXBlXSxoPWd8fGQucmVsYXRpdmVbXCIgXCJdLGk9Zz8xOjAsaz10YShmdW5jdGlvbihhKXtyZXR1cm4gYT09PWJ9LGgsITApLGw9dGEoZnVuY3Rpb24oYSl7cmV0dXJuIEkoYixhKT4tMX0saCwhMCksbT1bZnVuY3Rpb24oYSxjLGQpe3ZhciBlPSFnJiYoZHx8YyE9PWopfHwoKGI9Yykubm9kZVR5cGU/ayhhLGMsZCk6bChhLGMsZCkpO3JldHVybiBiPW51bGwsZX1dO2k8ZjtpKyspaWYoYz1kLnJlbGF0aXZlW2FbaV0udHlwZV0pbT1bdGEodWEobSksYyldO2Vsc2V7aWYoYz1kLmZpbHRlclthW2ldLnR5cGVdLmFwcGx5KG51bGwsYVtpXS5tYXRjaGVzKSxjW3VdKXtmb3IoZT0rK2k7ZTxmO2UrKylpZihkLnJlbGF0aXZlW2FbZV0udHlwZV0pYnJlYWs7cmV0dXJuIHhhKGk+MSYmdWEobSksaT4xJiZzYShhLnNsaWNlKDAsaS0xKS5jb25jYXQoe3ZhbHVlOlwiIFwiPT09YVtpLTJdLnR5cGU/XCIqXCI6XCJcIn0pKS5yZXBsYWNlKFAsXCIkMVwiKSxjLGk8ZSYmeWEoYS5zbGljZShpLGUpKSxlPGYmJnlhKGE9YS5zbGljZShlKSksZTxmJiZzYShhKSl9bS5wdXNoKGMpfXJldHVybiB1YShtKX1mdW5jdGlvbiB6YShhLGIpe3ZhciBjPWIubGVuZ3RoPjAsZT1hLmxlbmd0aD4wLGY9ZnVuY3Rpb24oZixnLGgsaSxrKXt2YXIgbCxvLHEscj0wLHM9XCIwXCIsdD1mJiZbXSx1PVtdLHY9aix4PWZ8fGUmJmQuZmluZC5UQUcoXCIqXCIsaykseT13Kz1udWxsPT12PzE6TWF0aC5yYW5kb20oKXx8LjEsej14Lmxlbmd0aDtmb3IoayYmKGo9Zz09PW58fGd8fGspO3MhPT16JiZudWxsIT0obD14W3NdKTtzKyspe2lmKGUmJmwpe289MCxnfHxsLm93bmVyRG9jdW1lbnQ9PT1ufHwobShsKSxoPSFwKTt3aGlsZShxPWFbbysrXSlpZihxKGwsZ3x8bixoKSl7aS5wdXNoKGwpO2JyZWFrfWsmJih3PXkpfWMmJigobD0hcSYmbCkmJnItLSxmJiZ0LnB1c2gobCkpfWlmKHIrPXMsYyYmcyE9PXIpe289MDt3aGlsZShxPWJbbysrXSlxKHQsdSxnLGgpO2lmKGYpe2lmKHI+MCl3aGlsZShzLS0pdFtzXXx8dVtzXXx8KHVbc109RS5jYWxsKGkpKTt1PXdhKHUpfUcuYXBwbHkoaSx1KSxrJiYhZiYmdS5sZW5ndGg+MCYmcitiLmxlbmd0aD4xJiZnYS51bmlxdWVTb3J0KGkpfXJldHVybiBrJiYodz15LGo9diksdH07cmV0dXJuIGM/aWEoZik6Zn1yZXR1cm4gaD1nYS5jb21waWxlPWZ1bmN0aW9uKGEsYil7dmFyIGMsZD1bXSxlPVtdLGY9QVthK1wiIFwiXTtpZighZil7Ynx8KGI9ZyhhKSksYz1iLmxlbmd0aDt3aGlsZShjLS0pZj15YShiW2NdKSxmW3VdP2QucHVzaChmKTplLnB1c2goZik7Zj1BKGEsemEoZSxkKSksZi5zZWxlY3Rvcj1hfXJldHVybiBmfSxpPWdhLnNlbGVjdD1mdW5jdGlvbihhLGIsYyxlKXt2YXIgZixpLGosayxsLG09XCJmdW5jdGlvblwiPT10eXBlb2YgYSYmYSxuPSFlJiZnKGE9bS5zZWxlY3Rvcnx8YSk7aWYoYz1jfHxbXSwxPT09bi5sZW5ndGgpe2lmKGk9blswXT1uWzBdLnNsaWNlKDApLGkubGVuZ3RoPjImJlwiSURcIj09PShqPWlbMF0pLnR5cGUmJjk9PT1iLm5vZGVUeXBlJiZwJiZkLnJlbGF0aXZlW2lbMV0udHlwZV0pe2lmKGI9KGQuZmluZC5JRChqLm1hdGNoZXNbMF0ucmVwbGFjZShfLGFhKSxiKXx8W10pWzBdLCFiKXJldHVybiBjO20mJihiPWIucGFyZW50Tm9kZSksYT1hLnNsaWNlKGkuc2hpZnQoKS52YWx1ZS5sZW5ndGgpfWY9Vi5uZWVkc0NvbnRleHQudGVzdChhKT8wOmkubGVuZ3RoO3doaWxlKGYtLSl7aWYoaj1pW2ZdLGQucmVsYXRpdmVbaz1qLnR5cGVdKWJyZWFrO2lmKChsPWQuZmluZFtrXSkmJihlPWwoai5tYXRjaGVzWzBdLnJlcGxhY2UoXyxhYSksJC50ZXN0KGlbMF0udHlwZSkmJnFhKGIucGFyZW50Tm9kZSl8fGIpKSl7aWYoaS5zcGxpY2UoZiwxKSxhPWUubGVuZ3RoJiZzYShpKSwhYSlyZXR1cm4gRy5hcHBseShjLGUpLGM7YnJlYWt9fX1yZXR1cm4obXx8aChhLG4pKShlLGIsIXAsYywhYnx8JC50ZXN0KGEpJiZxYShiLnBhcmVudE5vZGUpfHxiKSxjfSxjLnNvcnRTdGFibGU9dS5zcGxpdChcIlwiKS5zb3J0KEIpLmpvaW4oXCJcIik9PT11LGMuZGV0ZWN0RHVwbGljYXRlcz0hIWwsbSgpLGMuc29ydERldGFjaGVkPWphKGZ1bmN0aW9uKGEpe3JldHVybiAxJmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24obi5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikpfSksamEoZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW5uZXJIVE1MPVwiPGEgaHJlZj0nIyc+PC9hPlwiLFwiI1wiPT09YS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIil9KXx8a2EoXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsZnVuY3Rpb24oYSxiLGMpe2lmKCFjKXJldHVybiBhLmdldEF0dHJpYnV0ZShiLFwidHlwZVwiPT09Yi50b0xvd2VyQ2FzZSgpPzE6Mil9KSxjLmF0dHJpYnV0ZXMmJmphKGZ1bmN0aW9uKGEpe3JldHVybiBhLmlubmVySFRNTD1cIjxpbnB1dC8+XCIsYS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIiksXCJcIj09PWEuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKX0pfHxrYShcInZhbHVlXCIsZnVuY3Rpb24oYSxiLGMpe2lmKCFjJiZcImlucHV0XCI9PT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpcmV0dXJuIGEuZGVmYXVsdFZhbHVlfSksamEoZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWEuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIil9KXx8a2EoSixmdW5jdGlvbihhLGIsYyl7dmFyIGQ7aWYoIWMpcmV0dXJuIGFbYl09PT0hMD9iLnRvTG93ZXJDYXNlKCk6KGQ9YS5nZXRBdHRyaWJ1dGVOb2RlKGIpKSYmZC5zcGVjaWZpZWQ/ZC52YWx1ZTpudWxsfSksZ2F9KGEpO3IuZmluZD14LHIuZXhwcj14LnNlbGVjdG9ycyxyLmV4cHJbXCI6XCJdPXIuZXhwci5wc2V1ZG9zLHIudW5pcXVlU29ydD1yLnVuaXF1ZT14LnVuaXF1ZVNvcnQsci50ZXh0PXguZ2V0VGV4dCxyLmlzWE1MRG9jPXguaXNYTUwsci5jb250YWlucz14LmNvbnRhaW5zLHIuZXNjYXBlU2VsZWN0b3I9eC5lc2NhcGU7dmFyIHk9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVtdLGU9dm9pZCAwIT09Yzt3aGlsZSgoYT1hW2JdKSYmOSE9PWEubm9kZVR5cGUpaWYoMT09PWEubm9kZVR5cGUpe2lmKGUmJnIoYSkuaXMoYykpYnJlYWs7ZC5wdXNoKGEpfXJldHVybiBkfSx6PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdO2E7YT1hLm5leHRTaWJsaW5nKTE9PT1hLm5vZGVUeXBlJiZhIT09YiYmYy5wdXNoKGEpO3JldHVybiBjfSxBPXIuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQsQj0vXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSxDPS9eLlteOiNcXFtcXC4sXSokLztmdW5jdGlvbiBEKGEsYixjKXtyZXR1cm4gci5pc0Z1bmN0aW9uKGIpP3IuZ3JlcChhLGZ1bmN0aW9uKGEsZCl7cmV0dXJuISFiLmNhbGwoYSxkLGEpIT09Y30pOmIubm9kZVR5cGU/ci5ncmVwKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1iIT09Y30pOlwic3RyaW5nXCIhPXR5cGVvZiBiP3IuZ3JlcChhLGZ1bmN0aW9uKGEpe3JldHVybiBpLmNhbGwoYixhKT4tMSE9PWN9KTpDLnRlc3QoYik/ci5maWx0ZXIoYixhLGMpOihiPXIuZmlsdGVyKGIsYSksci5ncmVwKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGkuY2FsbChiLGEpPi0xIT09YyYmMT09PWEubm9kZVR5cGV9KSl9ci5maWx0ZXI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWJbMF07cmV0dXJuIGMmJihhPVwiOm5vdChcIithK1wiKVwiKSwxPT09Yi5sZW5ndGgmJjE9PT1kLm5vZGVUeXBlP3IuZmluZC5tYXRjaGVzU2VsZWN0b3IoZCxhKT9bZF06W106ci5maW5kLm1hdGNoZXMoYSxyLmdyZXAoYixmdW5jdGlvbihhKXtyZXR1cm4gMT09PWEubm9kZVR5cGV9KSl9LHIuZm4uZXh0ZW5kKHtmaW5kOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZD10aGlzLmxlbmd0aCxlPXRoaXM7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGEpcmV0dXJuIHRoaXMucHVzaFN0YWNrKHIoYSkuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKGI9MDtiPGQ7YisrKWlmKHIuY29udGFpbnMoZVtiXSx0aGlzKSlyZXR1cm4hMH0pKTtmb3IoYz10aGlzLnB1c2hTdGFjayhbXSksYj0wO2I8ZDtiKyspci5maW5kKGEsZVtiXSxjKTtyZXR1cm4gZD4xP3IudW5pcXVlU29ydChjKTpjfSxmaWx0ZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKEQodGhpcyxhfHxbXSwhMSkpfSxub3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKEQodGhpcyxhfHxbXSwhMCkpfSxpczpmdW5jdGlvbihhKXtyZXR1cm4hIUQodGhpcyxcInN0cmluZ1wiPT10eXBlb2YgYSYmQS50ZXN0KGEpP3IoYSk6YXx8W10sITEpLmxlbmd0aH19KTt2YXIgRSxGPS9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLEc9ci5mbi5pbml0PWZ1bmN0aW9uKGEsYixjKXt2YXIgZSxmO2lmKCFhKXJldHVybiB0aGlzO2lmKGM9Y3x8RSxcInN0cmluZ1wiPT10eXBlb2YgYSl7aWYoZT1cIjxcIj09PWFbMF0mJlwiPlwiPT09YVthLmxlbmd0aC0xXSYmYS5sZW5ndGg+PTM/W251bGwsYSxudWxsXTpGLmV4ZWMoYSksIWV8fCFlWzFdJiZiKXJldHVybiFifHxiLmpxdWVyeT8oYnx8YykuZmluZChhKTp0aGlzLmNvbnN0cnVjdG9yKGIpLmZpbmQoYSk7aWYoZVsxXSl7aWYoYj1iIGluc3RhbmNlb2Ygcj9iWzBdOmIsci5tZXJnZSh0aGlzLHIucGFyc2VIVE1MKGVbMV0sYiYmYi5ub2RlVHlwZT9iLm93bmVyRG9jdW1lbnR8fGI6ZCwhMCkpLEIudGVzdChlWzFdKSYmci5pc1BsYWluT2JqZWN0KGIpKWZvcihlIGluIGIpci5pc0Z1bmN0aW9uKHRoaXNbZV0pP3RoaXNbZV0oYltlXSk6dGhpcy5hdHRyKGUsYltlXSk7cmV0dXJuIHRoaXN9cmV0dXJuIGY9ZC5nZXRFbGVtZW50QnlJZChlWzJdKSxmJiYodGhpc1swXT1mLHRoaXMubGVuZ3RoPTEpLHRoaXN9cmV0dXJuIGEubm9kZVR5cGU/KHRoaXNbMF09YSx0aGlzLmxlbmd0aD0xLHRoaXMpOnIuaXNGdW5jdGlvbihhKT92b2lkIDAhPT1jLnJlYWR5P2MucmVhZHkoYSk6YShyKTpyLm1ha2VBcnJheShhLHRoaXMpfTtHLnByb3RvdHlwZT1yLmZuLEU9cihkKTt2YXIgSD0vXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxJPXtjaGlsZHJlbjohMCxjb250ZW50czohMCxuZXh0OiEwLHByZXY6ITB9O3IuZm4uZXh0ZW5kKHtoYXM6ZnVuY3Rpb24oYSl7dmFyIGI9cihhLHRoaXMpLGM9Yi5sZW5ndGg7cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7YTxjO2ErKylpZihyLmNvbnRhaW5zKHRoaXMsYlthXSkpcmV0dXJuITB9KX0sY2xvc2VzdDpmdW5jdGlvbihhLGIpe3ZhciBjLGQ9MCxlPXRoaXMubGVuZ3RoLGY9W10sZz1cInN0cmluZ1wiIT10eXBlb2YgYSYmcihhKTtpZighQS50ZXN0KGEpKWZvcig7ZDxlO2QrKylmb3IoYz10aGlzW2RdO2MmJmMhPT1iO2M9Yy5wYXJlbnROb2RlKWlmKGMubm9kZVR5cGU8MTEmJihnP2cuaW5kZXgoYyk+LTE6MT09PWMubm9kZVR5cGUmJnIuZmluZC5tYXRjaGVzU2VsZWN0b3IoYyxhKSkpe2YucHVzaChjKTticmVha31yZXR1cm4gdGhpcy5wdXNoU3RhY2soZi5sZW5ndGg+MT9yLnVuaXF1ZVNvcnQoZik6Zil9LGluZGV4OmZ1bmN0aW9uKGEpe3JldHVybiBhP1wic3RyaW5nXCI9PXR5cGVvZiBhP2kuY2FsbChyKGEpLHRoaXNbMF0pOmkuY2FsbCh0aGlzLGEuanF1ZXJ5P2FbMF06YSk6dGhpc1swXSYmdGhpc1swXS5wYXJlbnROb2RlP3RoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoOi0xfSxhZGQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soci51bmlxdWVTb3J0KHIubWVyZ2UodGhpcy5nZXQoKSxyKGEsYikpKSl9LGFkZEJhY2s6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYWRkKG51bGw9PWE/dGhpcy5wcmV2T2JqZWN0OnRoaXMucHJldk9iamVjdC5maWx0ZXIoYSkpfX0pO2Z1bmN0aW9uIEooYSxiKXt3aGlsZSgoYT1hW2JdKSYmMSE9PWEubm9kZVR5cGUpO3JldHVybiBhfXIuZWFjaCh7cGFyZW50OmZ1bmN0aW9uKGEpe3ZhciBiPWEucGFyZW50Tm9kZTtyZXR1cm4gYiYmMTEhPT1iLm5vZGVUeXBlP2I6bnVsbH0scGFyZW50czpmdW5jdGlvbihhKXtyZXR1cm4geShhLFwicGFyZW50Tm9kZVwiKX0scGFyZW50c1VudGlsOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4geShhLFwicGFyZW50Tm9kZVwiLGMpfSxuZXh0OmZ1bmN0aW9uKGEpe3JldHVybiBKKGEsXCJuZXh0U2libGluZ1wiKX0scHJldjpmdW5jdGlvbihhKXtyZXR1cm4gSihhLFwicHJldmlvdXNTaWJsaW5nXCIpfSxuZXh0QWxsOmZ1bmN0aW9uKGEpe3JldHVybiB5KGEsXCJuZXh0U2libGluZ1wiKX0scHJldkFsbDpmdW5jdGlvbihhKXtyZXR1cm4geShhLFwicHJldmlvdXNTaWJsaW5nXCIpfSxuZXh0VW50aWw6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB5KGEsXCJuZXh0U2libGluZ1wiLGMpfSxwcmV2VW50aWw6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB5KGEsXCJwcmV2aW91c1NpYmxpbmdcIixjKX0sc2libGluZ3M6ZnVuY3Rpb24oYSl7cmV0dXJuIHooKGEucGFyZW50Tm9kZXx8e30pLmZpcnN0Q2hpbGQsYSl9LGNoaWxkcmVuOmZ1bmN0aW9uKGEpe3JldHVybiB6KGEuZmlyc3RDaGlsZCl9LGNvbnRlbnRzOmZ1bmN0aW9uKGEpe3JldHVybiBhLmNvbnRlbnREb2N1bWVudHx8ci5tZXJnZShbXSxhLmNoaWxkTm9kZXMpfX0sZnVuY3Rpb24oYSxiKXtyLmZuW2FdPWZ1bmN0aW9uKGMsZCl7dmFyIGU9ci5tYXAodGhpcyxiLGMpO3JldHVyblwiVW50aWxcIiE9PWEuc2xpY2UoLTUpJiYoZD1jKSxkJiZcInN0cmluZ1wiPT10eXBlb2YgZCYmKGU9ci5maWx0ZXIoZCxlKSksdGhpcy5sZW5ndGg+MSYmKElbYV18fHIudW5pcXVlU29ydChlKSxILnRlc3QoYSkmJmUucmV2ZXJzZSgpKSx0aGlzLnB1c2hTdGFjayhlKX19KTt2YXIgSz0vW15cXHgyMFxcdFxcclxcblxcZl0rL2c7ZnVuY3Rpb24gTChhKXt2YXIgYj17fTtyZXR1cm4gci5lYWNoKGEubWF0Y2goSyl8fFtdLGZ1bmN0aW9uKGEsYyl7YltjXT0hMH0pLGJ9ci5DYWxsYmFja3M9ZnVuY3Rpb24oYSl7YT1cInN0cmluZ1wiPT10eXBlb2YgYT9MKGEpOnIuZXh0ZW5kKHt9LGEpO3ZhciBiLGMsZCxlLGY9W10sZz1bXSxoPS0xLGk9ZnVuY3Rpb24oKXtmb3IoZT1hLm9uY2UsZD1iPSEwO2cubGVuZ3RoO2g9LTEpe2M9Zy5zaGlmdCgpO3doaWxlKCsraDxmLmxlbmd0aClmW2hdLmFwcGx5KGNbMF0sY1sxXSk9PT0hMSYmYS5zdG9wT25GYWxzZSYmKGg9Zi5sZW5ndGgsYz0hMSl9YS5tZW1vcnl8fChjPSExKSxiPSExLGUmJihmPWM/W106XCJcIil9LGo9e2FkZDpmdW5jdGlvbigpe3JldHVybiBmJiYoYyYmIWImJihoPWYubGVuZ3RoLTEsZy5wdXNoKGMpKSxmdW5jdGlvbiBkKGIpe3IuZWFjaChiLGZ1bmN0aW9uKGIsYyl7ci5pc0Z1bmN0aW9uKGMpP2EudW5pcXVlJiZqLmhhcyhjKXx8Zi5wdXNoKGMpOmMmJmMubGVuZ3RoJiZcInN0cmluZ1wiIT09ci50eXBlKGMpJiZkKGMpfSl9KGFyZ3VtZW50cyksYyYmIWImJmkoKSksdGhpc30scmVtb3ZlOmZ1bmN0aW9uKCl7cmV0dXJuIHIuZWFjaChhcmd1bWVudHMsZnVuY3Rpb24oYSxiKXt2YXIgYzt3aGlsZSgoYz1yLmluQXJyYXkoYixmLGMpKT4tMSlmLnNwbGljZShjLDEpLGM8PWgmJmgtLX0pLHRoaXN9LGhhczpmdW5jdGlvbihhKXtyZXR1cm4gYT9yLmluQXJyYXkoYSxmKT4tMTpmLmxlbmd0aD4wfSxlbXB0eTpmdW5jdGlvbigpe3JldHVybiBmJiYoZj1bXSksdGhpc30sZGlzYWJsZTpmdW5jdGlvbigpe3JldHVybiBlPWc9W10sZj1jPVwiXCIsdGhpc30sZGlzYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hZn0sbG9jazpmdW5jdGlvbigpe3JldHVybiBlPWc9W10sY3x8Ynx8KGY9Yz1cIlwiKSx0aGlzfSxsb2NrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hIWV9LGZpcmVXaXRoOmZ1bmN0aW9uKGEsYyl7cmV0dXJuIGV8fChjPWN8fFtdLGM9W2EsYy5zbGljZT9jLnNsaWNlKCk6Y10sZy5wdXNoKGMpLGJ8fGkoKSksdGhpc30sZmlyZTpmdW5jdGlvbigpe3JldHVybiBqLmZpcmVXaXRoKHRoaXMsYXJndW1lbnRzKSx0aGlzfSxmaXJlZDpmdW5jdGlvbigpe3JldHVybiEhZH19O3JldHVybiBqfTtmdW5jdGlvbiBNKGEpe3JldHVybiBhfWZ1bmN0aW9uIE4oYSl7dGhyb3cgYX1mdW5jdGlvbiBPKGEsYixjKXt2YXIgZDt0cnl7YSYmci5pc0Z1bmN0aW9uKGQ9YS5wcm9taXNlKT9kLmNhbGwoYSkuZG9uZShiKS5mYWlsKGMpOmEmJnIuaXNGdW5jdGlvbihkPWEudGhlbik/ZC5jYWxsKGEsYixjKTpiLmNhbGwodm9pZCAwLGEpfWNhdGNoKGEpe2MuY2FsbCh2b2lkIDAsYSl9fXIuZXh0ZW5kKHtEZWZlcnJlZDpmdW5jdGlvbihiKXt2YXIgYz1bW1wibm90aWZ5XCIsXCJwcm9ncmVzc1wiLHIuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLHIuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLDJdLFtcInJlc29sdmVcIixcImRvbmVcIixyLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLHIuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksMCxcInJlc29sdmVkXCJdLFtcInJlamVjdFwiLFwiZmFpbFwiLHIuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksci5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwxLFwicmVqZWN0ZWRcIl1dLGQ9XCJwZW5kaW5nXCIsZT17c3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sYWx3YXlzOmZ1bmN0aW9uKCl7cmV0dXJuIGYuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSx0aGlzfSxcImNhdGNoXCI6ZnVuY3Rpb24oYSl7cmV0dXJuIGUudGhlbihudWxsLGEpfSxwaXBlOmZ1bmN0aW9uKCl7dmFyIGE9YXJndW1lbnRzO3JldHVybiByLkRlZmVycmVkKGZ1bmN0aW9uKGIpe3IuZWFjaChjLGZ1bmN0aW9uKGMsZCl7dmFyIGU9ci5pc0Z1bmN0aW9uKGFbZFs0XV0pJiZhW2RbNF1dO2ZbZFsxXV0oZnVuY3Rpb24oKXt2YXIgYT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthJiZyLmlzRnVuY3Rpb24oYS5wcm9taXNlKT9hLnByb21pc2UoKS5wcm9ncmVzcyhiLm5vdGlmeSkuZG9uZShiLnJlc29sdmUpLmZhaWwoYi5yZWplY3QpOmJbZFswXStcIldpdGhcIl0odGhpcyxlP1thXTphcmd1bWVudHMpfSl9KSxhPW51bGx9KS5wcm9taXNlKCl9LHRoZW46ZnVuY3Rpb24oYixkLGUpe3ZhciBmPTA7ZnVuY3Rpb24gZyhiLGMsZCxlKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaD10aGlzLGk9YXJndW1lbnRzLGo9ZnVuY3Rpb24oKXt2YXIgYSxqO2lmKCEoYjxmKSl7aWYoYT1kLmFwcGx5KGgsaSksYT09PWMucHJvbWlzZSgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIik7aj1hJiYoXCJvYmplY3RcIj09dHlwZW9mIGF8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGEpJiZhLnRoZW4sci5pc0Z1bmN0aW9uKGopP2U/ai5jYWxsKGEsZyhmLGMsTSxlKSxnKGYsYyxOLGUpKTooZisrLGouY2FsbChhLGcoZixjLE0sZSksZyhmLGMsTixlKSxnKGYsYyxNLGMubm90aWZ5V2l0aCkpKTooZCE9PU0mJihoPXZvaWQgMCxpPVthXSksKGV8fGMucmVzb2x2ZVdpdGgpKGgsaSkpfX0saz1lP2o6ZnVuY3Rpb24oKXt0cnl7aigpfWNhdGNoKGEpe3IuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayYmci5EZWZlcnJlZC5leGNlcHRpb25Ib29rKGEsay5zdGFja1RyYWNlKSxiKzE+PWYmJihkIT09TiYmKGg9dm9pZCAwLGk9W2FdKSxjLnJlamVjdFdpdGgoaCxpKSl9fTtiP2soKTooci5EZWZlcnJlZC5nZXRTdGFja0hvb2smJihrLnN0YWNrVHJhY2U9ci5EZWZlcnJlZC5nZXRTdGFja0hvb2soKSksYS5zZXRUaW1lb3V0KGspKX19cmV0dXJuIHIuRGVmZXJyZWQoZnVuY3Rpb24oYSl7Y1swXVszXS5hZGQoZygwLGEsci5pc0Z1bmN0aW9uKGUpP2U6TSxhLm5vdGlmeVdpdGgpKSxjWzFdWzNdLmFkZChnKDAsYSxyLmlzRnVuY3Rpb24oYik/YjpNKSksY1syXVszXS5hZGQoZygwLGEsci5pc0Z1bmN0aW9uKGQpP2Q6TikpfSkucHJvbWlzZSgpfSxwcm9taXNlOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP3IuZXh0ZW5kKGEsZSk6ZX19LGY9e307cmV0dXJuIHIuZWFjaChjLGZ1bmN0aW9uKGEsYil7dmFyIGc9YlsyXSxoPWJbNV07ZVtiWzFdXT1nLmFkZCxoJiZnLmFkZChmdW5jdGlvbigpe2Q9aH0sY1szLWFdWzJdLmRpc2FibGUsY1swXVsyXS5sb2NrKSxnLmFkZChiWzNdLmZpcmUpLGZbYlswXV09ZnVuY3Rpb24oKXtyZXR1cm4gZltiWzBdK1wiV2l0aFwiXSh0aGlzPT09Zj92b2lkIDA6dGhpcyxhcmd1bWVudHMpLHRoaXN9LGZbYlswXStcIldpdGhcIl09Zy5maXJlV2l0aH0pLGUucHJvbWlzZShmKSxiJiZiLmNhbGwoZixmKSxmfSx3aGVuOmZ1bmN0aW9uKGEpe3ZhciBiPWFyZ3VtZW50cy5sZW5ndGgsYz1iLGQ9QXJyYXkoYyksZT1mLmNhbGwoYXJndW1lbnRzKSxnPXIuRGVmZXJyZWQoKSxoPWZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihjKXtkW2FdPXRoaXMsZVthXT1hcmd1bWVudHMubGVuZ3RoPjE/Zi5jYWxsKGFyZ3VtZW50cyk6YywtLWJ8fGcucmVzb2x2ZVdpdGgoZCxlKX19O2lmKGI8PTEmJihPKGEsZy5kb25lKGgoYykpLnJlc29sdmUsZy5yZWplY3QpLFwicGVuZGluZ1wiPT09Zy5zdGF0ZSgpfHxyLmlzRnVuY3Rpb24oZVtjXSYmZVtjXS50aGVuKSkpcmV0dXJuIGcudGhlbigpO3doaWxlKGMtLSlPKGVbY10saChjKSxnLnJlamVjdCk7cmV0dXJuIGcucHJvbWlzZSgpfX0pO3ZhciBQPS9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO3IuRGVmZXJyZWQuZXhjZXB0aW9uSG9vaz1mdW5jdGlvbihiLGMpe2EuY29uc29sZSYmYS5jb25zb2xlLndhcm4mJmImJlAudGVzdChiLm5hbWUpJiZhLmNvbnNvbGUud2FybihcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiK2IubWVzc2FnZSxiLnN0YWNrLGMpfSxyLnJlYWR5RXhjZXB0aW9uPWZ1bmN0aW9uKGIpe2Euc2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGJ9KX07dmFyIFE9ci5EZWZlcnJlZCgpO3IuZm4ucmVhZHk9ZnVuY3Rpb24oYSl7cmV0dXJuIFEudGhlbihhKVtcImNhdGNoXCJdKGZ1bmN0aW9uKGEpe3IucmVhZHlFeGNlcHRpb24oYSl9KSx0aGlzfSxyLmV4dGVuZCh7aXNSZWFkeTohMSxyZWFkeVdhaXQ6MSxob2xkUmVhZHk6ZnVuY3Rpb24oYSl7YT9yLnJlYWR5V2FpdCsrOnIucmVhZHkoITApfSxyZWFkeTpmdW5jdGlvbihhKXsoYT09PSEwPy0tci5yZWFkeVdhaXQ6ci5pc1JlYWR5KXx8KHIuaXNSZWFkeT0hMCxhIT09ITAmJi0tci5yZWFkeVdhaXQ+MHx8US5yZXNvbHZlV2l0aChkLFtyXSkpfX0pLHIucmVhZHkudGhlbj1RLnRoZW47ZnVuY3Rpb24gUigpe2QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixSKSxcbmEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIixSKSxyLnJlYWR5KCl9XCJjb21wbGV0ZVwiPT09ZC5yZWFkeVN0YXRlfHxcImxvYWRpbmdcIiE9PWQucmVhZHlTdGF0ZSYmIWQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsP2Euc2V0VGltZW91dChyLnJlYWR5KTooZC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLFIpLGEuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixSKSk7dmFyIFM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7dmFyIGg9MCxpPWEubGVuZ3RoLGo9bnVsbD09YztpZihcIm9iamVjdFwiPT09ci50eXBlKGMpKXtlPSEwO2ZvcihoIGluIGMpUyhhLGIsaCxjW2hdLCEwLGYsZyl9ZWxzZSBpZih2b2lkIDAhPT1kJiYoZT0hMCxyLmlzRnVuY3Rpb24oZCl8fChnPSEwKSxqJiYoZz8oYi5jYWxsKGEsZCksYj1udWxsKTooaj1iLGI9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBqLmNhbGwocihhKSxjKX0pKSxiKSlmb3IoO2g8aTtoKyspYihhW2hdLGMsZz9kOmQuY2FsbChhW2hdLGgsYihhW2hdLGMpKSk7cmV0dXJuIGU/YTpqP2IuY2FsbChhKTppP2IoYVswXSxjKTpmfSxUPWZ1bmN0aW9uKGEpe3JldHVybiAxPT09YS5ub2RlVHlwZXx8OT09PWEubm9kZVR5cGV8fCErYS5ub2RlVHlwZX07ZnVuY3Rpb24gVSgpe3RoaXMuZXhwYW5kbz1yLmV4cGFuZG8rVS51aWQrK31VLnVpZD0xLFUucHJvdG90eXBlPXtjYWNoZTpmdW5jdGlvbihhKXt2YXIgYj1hW3RoaXMuZXhwYW5kb107cmV0dXJuIGJ8fChiPXt9LFQoYSkmJihhLm5vZGVUeXBlP2FbdGhpcy5leHBhbmRvXT1iOk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLHRoaXMuZXhwYW5kbyx7dmFsdWU6Yixjb25maWd1cmFibGU6ITB9KSkpLGJ9LHNldDpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZT10aGlzLmNhY2hlKGEpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBiKWVbci5jYW1lbENhc2UoYildPWM7ZWxzZSBmb3IoZCBpbiBiKWVbci5jYW1lbENhc2UoZCldPWJbZF07cmV0dXJuIGV9LGdldDpmdW5jdGlvbihhLGIpe3JldHVybiB2b2lkIDA9PT1iP3RoaXMuY2FjaGUoYSk6YVt0aGlzLmV4cGFuZG9dJiZhW3RoaXMuZXhwYW5kb11bci5jYW1lbENhc2UoYildfSxhY2Nlc3M6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB2b2lkIDA9PT1ifHxiJiZcInN0cmluZ1wiPT10eXBlb2YgYiYmdm9pZCAwPT09Yz90aGlzLmdldChhLGIpOih0aGlzLnNldChhLGIsYyksdm9pZCAwIT09Yz9jOmIpfSxyZW1vdmU6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPWFbdGhpcy5leHBhbmRvXTtpZih2b2lkIDAhPT1kKXtpZih2b2lkIDAhPT1iKXtyLmlzQXJyYXkoYik/Yj1iLm1hcChyLmNhbWVsQ2FzZSk6KGI9ci5jYW1lbENhc2UoYiksYj1iIGluIGQ/W2JdOmIubWF0Y2goSyl8fFtdKSxjPWIubGVuZ3RoO3doaWxlKGMtLSlkZWxldGUgZFtiW2NdXX0odm9pZCAwPT09Ynx8ci5pc0VtcHR5T2JqZWN0KGQpKSYmKGEubm9kZVR5cGU/YVt0aGlzLmV4cGFuZG9dPXZvaWQgMDpkZWxldGUgYVt0aGlzLmV4cGFuZG9dKX19LGhhc0RhdGE6ZnVuY3Rpb24oYSl7dmFyIGI9YVt0aGlzLmV4cGFuZG9dO3JldHVybiB2b2lkIDAhPT1iJiYhci5pc0VtcHR5T2JqZWN0KGIpfX07dmFyIFY9bmV3IFUsVz1uZXcgVSxYPS9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxZPS9bQS1aXS9nO2Z1bmN0aW9uIFooYSl7cmV0dXJuXCJ0cnVlXCI9PT1hfHxcImZhbHNlXCIhPT1hJiYoXCJudWxsXCI9PT1hP251bGw6YT09PSthK1wiXCI/K2E6WC50ZXN0KGEpP0pTT04ucGFyc2UoYSk6YSl9ZnVuY3Rpb24gJChhLGIsYyl7dmFyIGQ7aWYodm9pZCAwPT09YyYmMT09PWEubm9kZVR5cGUpaWYoZD1cImRhdGEtXCIrYi5yZXBsYWNlKFksXCItJCZcIikudG9Mb3dlckNhc2UoKSxjPWEuZ2V0QXR0cmlidXRlKGQpLFwic3RyaW5nXCI9PXR5cGVvZiBjKXt0cnl7Yz1aKGMpfWNhdGNoKGUpe31XLnNldChhLGIsYyl9ZWxzZSBjPXZvaWQgMDtyZXR1cm4gY31yLmV4dGVuZCh7aGFzRGF0YTpmdW5jdGlvbihhKXtyZXR1cm4gVy5oYXNEYXRhKGEpfHxWLmhhc0RhdGEoYSl9LGRhdGE6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBXLmFjY2VzcyhhLGIsYyl9LHJlbW92ZURhdGE6ZnVuY3Rpb24oYSxiKXtXLnJlbW92ZShhLGIpfSxfZGF0YTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIFYuYWNjZXNzKGEsYixjKX0sX3JlbW92ZURhdGE6ZnVuY3Rpb24oYSxiKXtWLnJlbW92ZShhLGIpfX0pLHIuZm4uZXh0ZW5kKHtkYXRhOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGY9dGhpc1swXSxnPWYmJmYuYXR0cmlidXRlcztpZih2b2lkIDA9PT1hKXtpZih0aGlzLmxlbmd0aCYmKGU9Vy5nZXQoZiksMT09PWYubm9kZVR5cGUmJiFWLmdldChmLFwiaGFzRGF0YUF0dHJzXCIpKSl7Yz1nLmxlbmd0aDt3aGlsZShjLS0pZ1tjXSYmKGQ9Z1tjXS5uYW1lLDA9PT1kLmluZGV4T2YoXCJkYXRhLVwiKSYmKGQ9ci5jYW1lbENhc2UoZC5zbGljZSg1KSksJChmLGQsZVtkXSkpKTtWLnNldChmLFwiaGFzRGF0YUF0dHJzXCIsITApfXJldHVybiBlfXJldHVyblwib2JqZWN0XCI9PXR5cGVvZiBhP3RoaXMuZWFjaChmdW5jdGlvbigpe1cuc2V0KHRoaXMsYSl9KTpTKHRoaXMsZnVuY3Rpb24oYil7dmFyIGM7aWYoZiYmdm9pZCAwPT09Yil7aWYoYz1XLmdldChmLGEpLHZvaWQgMCE9PWMpcmV0dXJuIGM7aWYoYz0kKGYsYSksdm9pZCAwIT09YylyZXR1cm4gY31lbHNlIHRoaXMuZWFjaChmdW5jdGlvbigpe1cuc2V0KHRoaXMsYSxiKX0pfSxudWxsLGIsYXJndW1lbnRzLmxlbmd0aD4xLG51bGwsITApfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtXLnJlbW92ZSh0aGlzLGEpfSl9fSksci5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZDtpZihhKXJldHVybiBiPShifHxcImZ4XCIpK1wicXVldWVcIixkPVYuZ2V0KGEsYiksYyYmKCFkfHxyLmlzQXJyYXkoYyk/ZD1WLmFjY2VzcyhhLGIsci5tYWtlQXJyYXkoYykpOmQucHVzaChjKSksZHx8W119LGRlcXVldWU6ZnVuY3Rpb24oYSxiKXtiPWJ8fFwiZnhcIjt2YXIgYz1yLnF1ZXVlKGEsYiksZD1jLmxlbmd0aCxlPWMuc2hpZnQoKSxmPXIuX3F1ZXVlSG9va3MoYSxiKSxnPWZ1bmN0aW9uKCl7ci5kZXF1ZXVlKGEsYil9O1wiaW5wcm9ncmVzc1wiPT09ZSYmKGU9Yy5zaGlmdCgpLGQtLSksZSYmKFwiZnhcIj09PWImJmMudW5zaGlmdChcImlucHJvZ3Jlc3NcIiksZGVsZXRlIGYuc3RvcCxlLmNhbGwoYSxnLGYpKSwhZCYmZiYmZi5lbXB0eS5maXJlKCl9LF9xdWV1ZUhvb2tzOmZ1bmN0aW9uKGEsYil7dmFyIGM9YitcInF1ZXVlSG9va3NcIjtyZXR1cm4gVi5nZXQoYSxjKXx8Vi5hY2Nlc3MoYSxjLHtlbXB0eTpyLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpe1YucmVtb3ZlKGEsW2IrXCJxdWV1ZVwiLGNdKX0pfSl9fSksci5mbi5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9MjtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgYSYmKGI9YSxhPVwiZnhcIixjLS0pLGFyZ3VtZW50cy5sZW5ndGg8Yz9yLnF1ZXVlKHRoaXNbMF0sYSk6dm9pZCAwPT09Yj90aGlzOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBjPXIucXVldWUodGhpcyxhLGIpO3IuX3F1ZXVlSG9va3ModGhpcyxhKSxcImZ4XCI9PT1hJiZcImlucHJvZ3Jlc3NcIiE9PWNbMF0mJnIuZGVxdWV1ZSh0aGlzLGEpfSl9LGRlcXVldWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3IuZGVxdWV1ZSh0aGlzLGEpfSl9LGNsZWFyUXVldWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucXVldWUoYXx8XCJmeFwiLFtdKX0scHJvbWlzZTpmdW5jdGlvbihhLGIpe3ZhciBjLGQ9MSxlPXIuRGVmZXJyZWQoKSxmPXRoaXMsZz10aGlzLmxlbmd0aCxoPWZ1bmN0aW9uKCl7LS1kfHxlLnJlc29sdmVXaXRoKGYsW2ZdKX07XCJzdHJpbmdcIiE9dHlwZW9mIGEmJihiPWEsYT12b2lkIDApLGE9YXx8XCJmeFwiO3doaWxlKGctLSljPVYuZ2V0KGZbZ10sYStcInF1ZXVlSG9va3NcIiksYyYmYy5lbXB0eSYmKGQrKyxjLmVtcHR5LmFkZChoKSk7cmV0dXJuIGgoKSxlLnByb21pc2UoYil9fSk7dmFyIF89L1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8uc291cmNlLGFhPW5ldyBSZWdFeHAoXCJeKD86KFsrLV0pPXwpKFwiK18rXCIpKFthLXolXSopJFwiLFwiaVwiKSxiYT1bXCJUb3BcIixcIlJpZ2h0XCIsXCJCb3R0b21cIixcIkxlZnRcIl0sY2E9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT1ifHxhLFwibm9uZVwiPT09YS5zdHlsZS5kaXNwbGF5fHxcIlwiPT09YS5zdHlsZS5kaXNwbGF5JiZyLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKSYmXCJub25lXCI9PT1yLmNzcyhhLFwiZGlzcGxheVwiKX0sZGE9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGUsZixnPXt9O2ZvcihmIGluIGIpZ1tmXT1hLnN0eWxlW2ZdLGEuc3R5bGVbZl09YltmXTtlPWMuYXBwbHkoYSxkfHxbXSk7Zm9yKGYgaW4gYilhLnN0eWxlW2ZdPWdbZl07cmV0dXJuIGV9O2Z1bmN0aW9uIGVhKGEsYixjLGQpe3ZhciBlLGY9MSxnPTIwLGg9ZD9mdW5jdGlvbigpe3JldHVybiBkLmN1cigpfTpmdW5jdGlvbigpe3JldHVybiByLmNzcyhhLGIsXCJcIil9LGk9aCgpLGo9YyYmY1szXXx8KHIuY3NzTnVtYmVyW2JdP1wiXCI6XCJweFwiKSxrPShyLmNzc051bWJlcltiXXx8XCJweFwiIT09aiYmK2kpJiZhYS5leGVjKHIuY3NzKGEsYikpO2lmKGsmJmtbM10hPT1qKXtqPWp8fGtbM10sYz1jfHxbXSxrPStpfHwxO2RvIGY9Znx8XCIuNVwiLGsvPWYsci5zdHlsZShhLGIsaytqKTt3aGlsZShmIT09KGY9aCgpL2kpJiYxIT09ZiYmLS1nKX1yZXR1cm4gYyYmKGs9K2t8fCtpfHwwLGU9Y1sxXT9rKyhjWzFdKzEpKmNbMl06K2NbMl0sZCYmKGQudW5pdD1qLGQuc3RhcnQ9ayxkLmVuZD1lKSksZX12YXIgZmE9e307ZnVuY3Rpb24gZ2EoYSl7dmFyIGIsYz1hLm93bmVyRG9jdW1lbnQsZD1hLm5vZGVOYW1lLGU9ZmFbZF07cmV0dXJuIGU/ZTooYj1jLmJvZHkuYXBwZW5kQ2hpbGQoYy5jcmVhdGVFbGVtZW50KGQpKSxlPXIuY3NzKGIsXCJkaXNwbGF5XCIpLGIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSxcIm5vbmVcIj09PWUmJihlPVwiYmxvY2tcIiksZmFbZF09ZSxlKX1mdW5jdGlvbiBoYShhLGIpe2Zvcih2YXIgYyxkLGU9W10sZj0wLGc9YS5sZW5ndGg7ZjxnO2YrKylkPWFbZl0sZC5zdHlsZSYmKGM9ZC5zdHlsZS5kaXNwbGF5LGI/KFwibm9uZVwiPT09YyYmKGVbZl09Vi5nZXQoZCxcImRpc3BsYXlcIil8fG51bGwsZVtmXXx8KGQuc3R5bGUuZGlzcGxheT1cIlwiKSksXCJcIj09PWQuc3R5bGUuZGlzcGxheSYmY2EoZCkmJihlW2ZdPWdhKGQpKSk6XCJub25lXCIhPT1jJiYoZVtmXT1cIm5vbmVcIixWLnNldChkLFwiZGlzcGxheVwiLGMpKSk7Zm9yKGY9MDtmPGc7ZisrKW51bGwhPWVbZl0mJihhW2ZdLnN0eWxlLmRpc3BsYXk9ZVtmXSk7cmV0dXJuIGF9ci5mbi5leHRlbmQoe3Nob3c6ZnVuY3Rpb24oKXtyZXR1cm4gaGEodGhpcywhMCl9LGhpZGU6ZnVuY3Rpb24oKXtyZXR1cm4gaGEodGhpcyl9LHRvZ2dsZTpmdW5jdGlvbihhKXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIGE/YT90aGlzLnNob3coKTp0aGlzLmhpZGUoKTp0aGlzLmVhY2goZnVuY3Rpb24oKXtjYSh0aGlzKT9yKHRoaXMpLnNob3coKTpyKHRoaXMpLmhpZGUoKX0pfX0pO3ZhciBpYT0vXig/OmNoZWNrYm94fHJhZGlvKSQvaSxqYT0vPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2ksa2E9L14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSxsYT17b3B0aW9uOlsxLFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLFwiPC9zZWxlY3Q+XCJdLHRoZWFkOlsxLFwiPHRhYmxlPlwiLFwiPC90YWJsZT5cIl0sY29sOlsyLFwiPHRhYmxlPjxjb2xncm91cD5cIixcIjwvY29sZ3JvdXA+PC90YWJsZT5cIl0sdHI6WzIsXCI8dGFibGU+PHRib2R5PlwiLFwiPC90Ym9keT48L3RhYmxlPlwiXSx0ZDpbMyxcIjx0YWJsZT48dGJvZHk+PHRyPlwiLFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCJdLF9kZWZhdWx0OlswLFwiXCIsXCJcIl19O2xhLm9wdGdyb3VwPWxhLm9wdGlvbixsYS50Ym9keT1sYS50Zm9vdD1sYS5jb2xncm91cD1sYS5jYXB0aW9uPWxhLnRoZWFkLGxhLnRoPWxhLnRkO2Z1bmN0aW9uIG1hKGEsYil7dmFyIGM7cmV0dXJuIGM9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEuZ2V0RWxlbWVudHNCeVRhZ05hbWU/YS5nZXRFbGVtZW50c0J5VGFnTmFtZShifHxcIipcIik6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEucXVlcnlTZWxlY3RvckFsbD9hLnF1ZXJ5U2VsZWN0b3JBbGwoYnx8XCIqXCIpOltdLHZvaWQgMD09PWJ8fGImJnIubm9kZU5hbWUoYSxiKT9yLm1lcmdlKFthXSxjKTpjfWZ1bmN0aW9uIG5hKGEsYil7Zm9yKHZhciBjPTAsZD1hLmxlbmd0aDtjPGQ7YysrKVYuc2V0KGFbY10sXCJnbG9iYWxFdmFsXCIsIWJ8fFYuZ2V0KGJbY10sXCJnbG9iYWxFdmFsXCIpKX12YXIgb2E9Lzx8JiM/XFx3KzsvO2Z1bmN0aW9uIHBhKGEsYixjLGQsZSl7Zm9yKHZhciBmLGcsaCxpLGosayxsPWIuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLG09W10sbj0wLG89YS5sZW5ndGg7bjxvO24rKylpZihmPWFbbl0sZnx8MD09PWYpaWYoXCJvYmplY3RcIj09PXIudHlwZShmKSlyLm1lcmdlKG0sZi5ub2RlVHlwZT9bZl06Zik7ZWxzZSBpZihvYS50ZXN0KGYpKXtnPWd8fGwuYXBwZW5kQ2hpbGQoYi5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxoPShqYS5leGVjKGYpfHxbXCJcIixcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSxpPWxhW2hdfHxsYS5fZGVmYXVsdCxnLmlubmVySFRNTD1pWzFdK3IuaHRtbFByZWZpbHRlcihmKStpWzJdLGs9aVswXTt3aGlsZShrLS0pZz1nLmxhc3RDaGlsZDtyLm1lcmdlKG0sZy5jaGlsZE5vZGVzKSxnPWwuZmlyc3RDaGlsZCxnLnRleHRDb250ZW50PVwiXCJ9ZWxzZSBtLnB1c2goYi5jcmVhdGVUZXh0Tm9kZShmKSk7bC50ZXh0Q29udGVudD1cIlwiLG49MDt3aGlsZShmPW1bbisrXSlpZihkJiZyLmluQXJyYXkoZixkKT4tMSllJiZlLnB1c2goZik7ZWxzZSBpZihqPXIuY29udGFpbnMoZi5vd25lckRvY3VtZW50LGYpLGc9bWEobC5hcHBlbmRDaGlsZChmKSxcInNjcmlwdFwiKSxqJiZuYShnKSxjKXtrPTA7d2hpbGUoZj1nW2srK10pa2EudGVzdChmLnR5cGV8fFwiXCIpJiZjLnB1c2goZil9cmV0dXJuIGx9IWZ1bmN0aW9uKCl7dmFyIGE9ZC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksYj1hLmFwcGVuZENoaWxkKGQuY3JlYXRlRWxlbWVudChcImRpdlwiKSksYz1kLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtjLnNldEF0dHJpYnV0ZShcInR5cGVcIixcInJhZGlvXCIpLGMuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLFwiY2hlY2tlZFwiKSxjLnNldEF0dHJpYnV0ZShcIm5hbWVcIixcInRcIiksYi5hcHBlbmRDaGlsZChjKSxvLmNoZWNrQ2xvbmU9Yi5jbG9uZU5vZGUoITApLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmNoZWNrZWQsYi5pbm5lckhUTUw9XCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCIsby5ub0Nsb25lQ2hlY2tlZD0hIWIuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlfSgpO3ZhciBxYT1kLmRvY3VtZW50RWxlbWVudCxyYT0vXmtleS8sc2E9L14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLHRhPS9eKFteLl0qKSg/OlxcLiguKyl8KS87ZnVuY3Rpb24gdWEoKXtyZXR1cm4hMH1mdW5jdGlvbiB2YSgpe3JldHVybiExfWZ1bmN0aW9uIHdhKCl7dHJ5e3JldHVybiBkLmFjdGl2ZUVsZW1lbnR9Y2F0Y2goYSl7fX1mdW5jdGlvbiB4YShhLGIsYyxkLGUsZil7dmFyIGcsaDtpZihcIm9iamVjdFwiPT10eXBlb2YgYil7XCJzdHJpbmdcIiE9dHlwZW9mIGMmJihkPWR8fGMsYz12b2lkIDApO2ZvcihoIGluIGIpeGEoYSxoLGMsZCxiW2hdLGYpO3JldHVybiBhfWlmKG51bGw9PWQmJm51bGw9PWU/KGU9YyxkPWM9dm9pZCAwKTpudWxsPT1lJiYoXCJzdHJpbmdcIj09dHlwZW9mIGM/KGU9ZCxkPXZvaWQgMCk6KGU9ZCxkPWMsYz12b2lkIDApKSxlPT09ITEpZT12YTtlbHNlIGlmKCFlKXJldHVybiBhO3JldHVybiAxPT09ZiYmKGc9ZSxlPWZ1bmN0aW9uKGEpe3JldHVybiByKCkub2ZmKGEpLGcuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxlLmd1aWQ9Zy5ndWlkfHwoZy5ndWlkPXIuZ3VpZCsrKSksYS5lYWNoKGZ1bmN0aW9uKCl7ci5ldmVudC5hZGQodGhpcyxiLGUsZCxjKX0pfXIuZXZlbnQ9e2dsb2JhbDp7fSxhZGQ6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZixnLGgsaSxqLGssbCxtLG4sbyxwLHE9Vi5nZXQoYSk7aWYocSl7Yy5oYW5kbGVyJiYoZj1jLGM9Zi5oYW5kbGVyLGU9Zi5zZWxlY3RvciksZSYmci5maW5kLm1hdGNoZXNTZWxlY3RvcihxYSxlKSxjLmd1aWR8fChjLmd1aWQ9ci5ndWlkKyspLChpPXEuZXZlbnRzKXx8KGk9cS5ldmVudHM9e30pLChnPXEuaGFuZGxlKXx8KGc9cS5oYW5kbGU9ZnVuY3Rpb24oYil7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHImJnIuZXZlbnQudHJpZ2dlcmVkIT09Yi50eXBlP3IuZXZlbnQuZGlzcGF0Y2guYXBwbHkoYSxhcmd1bWVudHMpOnZvaWQgMH0pLGI9KGJ8fFwiXCIpLm1hdGNoKEspfHxbXCJcIl0saj1iLmxlbmd0aDt3aGlsZShqLS0paD10YS5leGVjKGJbal0pfHxbXSxuPXA9aFsxXSxvPShoWzJdfHxcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLG4mJihsPXIuZXZlbnQuc3BlY2lhbFtuXXx8e30sbj0oZT9sLmRlbGVnYXRlVHlwZTpsLmJpbmRUeXBlKXx8bixsPXIuZXZlbnQuc3BlY2lhbFtuXXx8e30saz1yLmV4dGVuZCh7dHlwZTpuLG9yaWdUeXBlOnAsZGF0YTpkLGhhbmRsZXI6YyxndWlkOmMuZ3VpZCxzZWxlY3RvcjplLG5lZWRzQ29udGV4dDplJiZyLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoZSksbmFtZXNwYWNlOm8uam9pbihcIi5cIil9LGYpLChtPWlbbl0pfHwobT1pW25dPVtdLG0uZGVsZWdhdGVDb3VudD0wLGwuc2V0dXAmJmwuc2V0dXAuY2FsbChhLGQsbyxnKSE9PSExfHxhLmFkZEV2ZW50TGlzdGVuZXImJmEuYWRkRXZlbnRMaXN0ZW5lcihuLGcpKSxsLmFkZCYmKGwuYWRkLmNhbGwoYSxrKSxrLmhhbmRsZXIuZ3VpZHx8KGsuaGFuZGxlci5ndWlkPWMuZ3VpZCkpLGU/bS5zcGxpY2UobS5kZWxlZ2F0ZUNvdW50KyssMCxrKTptLnB1c2goayksci5ldmVudC5nbG9iYWxbbl09ITApfX0scmVtb3ZlOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGYsZyxoLGksaixrLGwsbSxuLG8scCxxPVYuaGFzRGF0YShhKSYmVi5nZXQoYSk7aWYocSYmKGk9cS5ldmVudHMpKXtiPShifHxcIlwiKS5tYXRjaChLKXx8W1wiXCJdLGo9Yi5sZW5ndGg7d2hpbGUoai0tKWlmKGg9dGEuZXhlYyhiW2pdKXx8W10sbj1wPWhbMV0sbz0oaFsyXXx8XCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKSxuKXtsPXIuZXZlbnQuc3BlY2lhbFtuXXx8e30sbj0oZD9sLmRlbGVnYXRlVHlwZTpsLmJpbmRUeXBlKXx8bixtPWlbbl18fFtdLGg9aFsyXSYmbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiK28uam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpK1wiKFxcXFwufCQpXCIpLGc9Zj1tLmxlbmd0aDt3aGlsZShmLS0paz1tW2ZdLCFlJiZwIT09ay5vcmlnVHlwZXx8YyYmYy5ndWlkIT09ay5ndWlkfHxoJiYhaC50ZXN0KGsubmFtZXNwYWNlKXx8ZCYmZCE9PWsuc2VsZWN0b3ImJihcIioqXCIhPT1kfHwhay5zZWxlY3Rvcil8fChtLnNwbGljZShmLDEpLGsuc2VsZWN0b3ImJm0uZGVsZWdhdGVDb3VudC0tLGwucmVtb3ZlJiZsLnJlbW92ZS5jYWxsKGEsaykpO2cmJiFtLmxlbmd0aCYmKGwudGVhcmRvd24mJmwudGVhcmRvd24uY2FsbChhLG8scS5oYW5kbGUpIT09ITF8fHIucmVtb3ZlRXZlbnQoYSxuLHEuaGFuZGxlKSxkZWxldGUgaVtuXSl9ZWxzZSBmb3IobiBpbiBpKXIuZXZlbnQucmVtb3ZlKGEsbitiW2pdLGMsZCwhMCk7ci5pc0VtcHR5T2JqZWN0KGkpJiZWLnJlbW92ZShhLFwiaGFuZGxlIGV2ZW50c1wiKX19LGRpc3BhdGNoOmZ1bmN0aW9uKGEpe3ZhciBiPXIuZXZlbnQuZml4KGEpLGMsZCxlLGYsZyxoLGk9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpLGo9KFYuZ2V0KHRoaXMsXCJldmVudHNcIil8fHt9KVtiLnR5cGVdfHxbXSxrPXIuZXZlbnQuc3BlY2lhbFtiLnR5cGVdfHx7fTtmb3IoaVswXT1iLGM9MTtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKWlbY109YXJndW1lbnRzW2NdO2lmKGIuZGVsZWdhdGVUYXJnZXQ9dGhpcywhay5wcmVEaXNwYXRjaHx8ay5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsYikhPT0hMSl7aD1yLmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcyxiLGopLGM9MDt3aGlsZSgoZj1oW2MrK10pJiYhYi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKXtiLmN1cnJlbnRUYXJnZXQ9Zi5lbGVtLGQ9MDt3aGlsZSgoZz1mLmhhbmRsZXJzW2QrK10pJiYhYi5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKWIucm5hbWVzcGFjZSYmIWIucm5hbWVzcGFjZS50ZXN0KGcubmFtZXNwYWNlKXx8KGIuaGFuZGxlT2JqPWcsYi5kYXRhPWcuZGF0YSxlPSgoci5ldmVudC5zcGVjaWFsW2cub3JpZ1R5cGVdfHx7fSkuaGFuZGxlfHxnLmhhbmRsZXIpLmFwcGx5KGYuZWxlbSxpKSx2b2lkIDAhPT1lJiYoYi5yZXN1bHQ9ZSk9PT0hMSYmKGIucHJldmVudERlZmF1bHQoKSxiLnN0b3BQcm9wYWdhdGlvbigpKSl9cmV0dXJuIGsucG9zdERpc3BhdGNoJiZrLnBvc3REaXNwYXRjaC5jYWxsKHRoaXMsYiksYi5yZXN1bHR9fSxoYW5kbGVyczpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmLGcsaD1bXSxpPWIuZGVsZWdhdGVDb3VudCxqPWEudGFyZ2V0O2lmKGkmJmoubm9kZVR5cGUmJiEoXCJjbGlja1wiPT09YS50eXBlJiZhLmJ1dHRvbj49MSkpZm9yKDtqIT09dGhpcztqPWoucGFyZW50Tm9kZXx8dGhpcylpZigxPT09ai5ub2RlVHlwZSYmKFwiY2xpY2tcIiE9PWEudHlwZXx8ai5kaXNhYmxlZCE9PSEwKSl7Zm9yKGY9W10sZz17fSxjPTA7YzxpO2MrKylkPWJbY10sZT1kLnNlbGVjdG9yK1wiIFwiLHZvaWQgMD09PWdbZV0mJihnW2VdPWQubmVlZHNDb250ZXh0P3IoZSx0aGlzKS5pbmRleChqKT4tMTpyLmZpbmQoZSx0aGlzLG51bGwsW2pdKS5sZW5ndGgpLGdbZV0mJmYucHVzaChkKTtmLmxlbmd0aCYmaC5wdXNoKHtlbGVtOmosaGFuZGxlcnM6Zn0pfXJldHVybiBqPXRoaXMsaTxiLmxlbmd0aCYmaC5wdXNoKHtlbGVtOmosaGFuZGxlcnM6Yi5zbGljZShpKX0pLGh9LGFkZFByb3A6ZnVuY3Rpb24oYSxiKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoci5FdmVudC5wcm90b3R5cGUsYSx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OnIuaXNGdW5jdGlvbihiKT9mdW5jdGlvbigpe2lmKHRoaXMub3JpZ2luYWxFdmVudClyZXR1cm4gYih0aGlzLm9yaWdpbmFsRXZlbnQpfTpmdW5jdGlvbigpe2lmKHRoaXMub3JpZ2luYWxFdmVudClyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50W2FdfSxzZXQ6ZnVuY3Rpb24oYil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsYSx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6Yn0pfX0pfSxmaXg6ZnVuY3Rpb24oYSl7cmV0dXJuIGFbci5leHBhbmRvXT9hOm5ldyByLkV2ZW50KGEpfSxzcGVjaWFsOntsb2FkOntub0J1YmJsZTohMH0sZm9jdXM6e3RyaWdnZXI6ZnVuY3Rpb24oKXtpZih0aGlzIT09d2EoKSYmdGhpcy5mb2N1cylyZXR1cm4gdGhpcy5mb2N1cygpLCExfSxkZWxlZ2F0ZVR5cGU6XCJmb2N1c2luXCJ9LGJsdXI6e3RyaWdnZXI6ZnVuY3Rpb24oKXtpZih0aGlzPT09d2EoKSYmdGhpcy5ibHVyKXJldHVybiB0aGlzLmJsdXIoKSwhMX0sZGVsZWdhdGVUeXBlOlwiZm9jdXNvdXRcIn0sY2xpY2s6e3RyaWdnZXI6ZnVuY3Rpb24oKXtpZihcImNoZWNrYm94XCI9PT10aGlzLnR5cGUmJnRoaXMuY2xpY2smJnIubm9kZU5hbWUodGhpcyxcImlucHV0XCIpKXJldHVybiB0aGlzLmNsaWNrKCksITF9LF9kZWZhdWx0OmZ1bmN0aW9uKGEpe3JldHVybiByLm5vZGVOYW1lKGEudGFyZ2V0LFwiYVwiKX19LGJlZm9yZXVubG9hZDp7cG9zdERpc3BhdGNoOmZ1bmN0aW9uKGEpe3ZvaWQgMCE9PWEucmVzdWx0JiZhLm9yaWdpbmFsRXZlbnQmJihhLm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWU9YS5yZXN1bHQpfX19fSxyLnJlbW92ZUV2ZW50PWZ1bmN0aW9uKGEsYixjKXthLnJlbW92ZUV2ZW50TGlzdGVuZXImJmEucmVtb3ZlRXZlbnRMaXN0ZW5lcihiLGMpfSxyLkV2ZW50PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiByLkV2ZW50PyhhJiZhLnR5cGU/KHRoaXMub3JpZ2luYWxFdmVudD1hLHRoaXMudHlwZT1hLnR5cGUsdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9YS5kZWZhdWx0UHJldmVudGVkfHx2b2lkIDA9PT1hLmRlZmF1bHRQcmV2ZW50ZWQmJmEucmV0dXJuVmFsdWU9PT0hMT91YTp2YSx0aGlzLnRhcmdldD1hLnRhcmdldCYmMz09PWEudGFyZ2V0Lm5vZGVUeXBlP2EudGFyZ2V0LnBhcmVudE5vZGU6YS50YXJnZXQsdGhpcy5jdXJyZW50VGFyZ2V0PWEuY3VycmVudFRhcmdldCx0aGlzLnJlbGF0ZWRUYXJnZXQ9YS5yZWxhdGVkVGFyZ2V0KTp0aGlzLnR5cGU9YSxiJiZyLmV4dGVuZCh0aGlzLGIpLHRoaXMudGltZVN0YW1wPWEmJmEudGltZVN0YW1wfHxyLm5vdygpLHZvaWQodGhpc1tyLmV4cGFuZG9dPSEwKSk6bmV3IHIuRXZlbnQoYSxiKX0sci5FdmVudC5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOnIuRXZlbnQsaXNEZWZhdWx0UHJldmVudGVkOnZhLGlzUHJvcGFnYXRpb25TdG9wcGVkOnZhLGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOnZhLGlzU2ltdWxhdGVkOiExLHByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPXVhLGEmJiF0aGlzLmlzU2ltdWxhdGVkJiZhLnByZXZlbnREZWZhdWx0KCl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPXVhLGEmJiF0aGlzLmlzU2ltdWxhdGVkJiZhLnN0b3BQcm9wYWdhdGlvbigpfSxzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD11YSxhJiYhdGhpcy5pc1NpbXVsYXRlZCYmYS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSx0aGlzLnN0b3BQcm9wYWdhdGlvbigpfX0sci5lYWNoKHthbHRLZXk6ITAsYnViYmxlczohMCxjYW5jZWxhYmxlOiEwLGNoYW5nZWRUb3VjaGVzOiEwLGN0cmxLZXk6ITAsZGV0YWlsOiEwLGV2ZW50UGhhc2U6ITAsbWV0YUtleTohMCxwYWdlWDohMCxwYWdlWTohMCxzaGlmdEtleTohMCx2aWV3OiEwLFwiY2hhclwiOiEwLGNoYXJDb2RlOiEwLGtleTohMCxrZXlDb2RlOiEwLGJ1dHRvbjohMCxidXR0b25zOiEwLGNsaWVudFg6ITAsY2xpZW50WTohMCxvZmZzZXRYOiEwLG9mZnNldFk6ITAscG9pbnRlcklkOiEwLHBvaW50ZXJUeXBlOiEwLHNjcmVlblg6ITAsc2NyZWVuWTohMCx0YXJnZXRUb3VjaGVzOiEwLHRvRWxlbWVudDohMCx0b3VjaGVzOiEwLHdoaWNoOmZ1bmN0aW9uKGEpe3ZhciBiPWEuYnV0dG9uO3JldHVybiBudWxsPT1hLndoaWNoJiZyYS50ZXN0KGEudHlwZSk/bnVsbCE9YS5jaGFyQ29kZT9hLmNoYXJDb2RlOmEua2V5Q29kZTohYS53aGljaCYmdm9pZCAwIT09YiYmc2EudGVzdChhLnR5cGUpPzEmYj8xOjImYj8zOjQmYj8yOjA6YS53aGljaH19LHIuZXZlbnQuYWRkUHJvcCksci5lYWNoKHttb3VzZWVudGVyOlwibW91c2VvdmVyXCIsbW91c2VsZWF2ZTpcIm1vdXNlb3V0XCIscG9pbnRlcmVudGVyOlwicG9pbnRlcm92ZXJcIixwb2ludGVybGVhdmU6XCJwb2ludGVyb3V0XCJ9LGZ1bmN0aW9uKGEsYil7ci5ldmVudC5zcGVjaWFsW2FdPXtkZWxlZ2F0ZVR5cGU6YixiaW5kVHlwZTpiLGhhbmRsZTpmdW5jdGlvbihhKXt2YXIgYyxkPXRoaXMsZT1hLnJlbGF0ZWRUYXJnZXQsZj1hLmhhbmRsZU9iajtyZXR1cm4gZSYmKGU9PT1kfHxyLmNvbnRhaW5zKGQsZSkpfHwoYS50eXBlPWYub3JpZ1R5cGUsYz1mLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpLGEudHlwZT1iKSxjfX19KSxyLmZuLmV4dGVuZCh7b246ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHhhKHRoaXMsYSxiLGMsZCl9LG9uZTpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4geGEodGhpcyxhLGIsYyxkLDEpfSxvZmY6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU7aWYoYSYmYS5wcmV2ZW50RGVmYXVsdCYmYS5oYW5kbGVPYmopcmV0dXJuIGQ9YS5oYW5kbGVPYmoscihhLmRlbGVnYXRlVGFyZ2V0KS5vZmYoZC5uYW1lc3BhY2U/ZC5vcmlnVHlwZStcIi5cIitkLm5hbWVzcGFjZTpkLm9yaWdUeXBlLGQuc2VsZWN0b3IsZC5oYW5kbGVyKSx0aGlzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBhKXtmb3IoZSBpbiBhKXRoaXMub2ZmKGUsYixhW2VdKTtyZXR1cm4gdGhpc31yZXR1cm4gYiE9PSExJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBifHwoYz1iLGI9dm9pZCAwKSxjPT09ITEmJihjPXZhKSx0aGlzLmVhY2goZnVuY3Rpb24oKXtyLmV2ZW50LnJlbW92ZSh0aGlzLGEsYyxiKX0pfX0pO3ZhciB5YT0vPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSx6YT0vPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxBYT0vY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLEJhPS9edHJ1ZVxcLyguKikvLENhPS9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztmdW5jdGlvbiBEYShhLGIpe3JldHVybiByLm5vZGVOYW1lKGEsXCJ0YWJsZVwiKSYmci5ub2RlTmFtZSgxMSE9PWIubm9kZVR5cGU/YjpiLmZpcnN0Q2hpbGQsXCJ0clwiKT9hLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIilbMF18fGE6YX1mdW5jdGlvbiBFYShhKXtyZXR1cm4gYS50eXBlPShudWxsIT09YS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKStcIi9cIithLnR5cGUsYX1mdW5jdGlvbiBGYShhKXt2YXIgYj1CYS5leGVjKGEudHlwZSk7cmV0dXJuIGI/YS50eXBlPWJbMV06YS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpLGF9ZnVuY3Rpb24gR2EoYSxiKXt2YXIgYyxkLGUsZixnLGgsaSxqO2lmKDE9PT1iLm5vZGVUeXBlKXtpZihWLmhhc0RhdGEoYSkmJihmPVYuYWNjZXNzKGEpLGc9Vi5zZXQoYixmKSxqPWYuZXZlbnRzKSl7ZGVsZXRlIGcuaGFuZGxlLGcuZXZlbnRzPXt9O2ZvcihlIGluIGopZm9yKGM9MCxkPWpbZV0ubGVuZ3RoO2M8ZDtjKyspci5ldmVudC5hZGQoYixlLGpbZV1bY10pfVcuaGFzRGF0YShhKSYmKGg9Vy5hY2Nlc3MoYSksaT1yLmV4dGVuZCh7fSxoKSxXLnNldChiLGkpKX19ZnVuY3Rpb24gSGEoYSxiKXt2YXIgYz1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XCJpbnB1dFwiPT09YyYmaWEudGVzdChhLnR5cGUpP2IuY2hlY2tlZD1hLmNoZWNrZWQ6XCJpbnB1dFwiIT09YyYmXCJ0ZXh0YXJlYVwiIT09Y3x8KGIuZGVmYXVsdFZhbHVlPWEuZGVmYXVsdFZhbHVlKX1mdW5jdGlvbiBJYShhLGIsYyxkKXtiPWcuYXBwbHkoW10sYik7dmFyIGUsZixoLGksaixrLGw9MCxtPWEubGVuZ3RoLG49bS0xLHE9YlswXSxzPXIuaXNGdW5jdGlvbihxKTtpZihzfHxtPjEmJlwic3RyaW5nXCI9PXR5cGVvZiBxJiYhby5jaGVja0Nsb25lJiZBYS50ZXN0KHEpKXJldHVybiBhLmVhY2goZnVuY3Rpb24oZSl7dmFyIGY9YS5lcShlKTtzJiYoYlswXT1xLmNhbGwodGhpcyxlLGYuaHRtbCgpKSksSWEoZixiLGMsZCl9KTtpZihtJiYoZT1wYShiLGFbMF0ub3duZXJEb2N1bWVudCwhMSxhLGQpLGY9ZS5maXJzdENoaWxkLDE9PT1lLmNoaWxkTm9kZXMubGVuZ3RoJiYoZT1mKSxmfHxkKSl7Zm9yKGg9ci5tYXAobWEoZSxcInNjcmlwdFwiKSxFYSksaT1oLmxlbmd0aDtsPG07bCsrKWo9ZSxsIT09biYmKGo9ci5jbG9uZShqLCEwLCEwKSxpJiZyLm1lcmdlKGgsbWEoaixcInNjcmlwdFwiKSkpLGMuY2FsbChhW2xdLGosbCk7aWYoaSlmb3Ioaz1oW2gubGVuZ3RoLTFdLm93bmVyRG9jdW1lbnQsci5tYXAoaCxGYSksbD0wO2w8aTtsKyspaj1oW2xdLGthLnRlc3Qoai50eXBlfHxcIlwiKSYmIVYuYWNjZXNzKGosXCJnbG9iYWxFdmFsXCIpJiZyLmNvbnRhaW5zKGssaikmJihqLnNyYz9yLl9ldmFsVXJsJiZyLl9ldmFsVXJsKGouc3JjKTpwKGoudGV4dENvbnRlbnQucmVwbGFjZShDYSxcIlwiKSxrKSl9cmV0dXJuIGF9ZnVuY3Rpb24gSmEoYSxiLGMpe2Zvcih2YXIgZCxlPWI/ci5maWx0ZXIoYixhKTphLGY9MDtudWxsIT0oZD1lW2ZdKTtmKyspY3x8MSE9PWQubm9kZVR5cGV8fHIuY2xlYW5EYXRhKG1hKGQpKSxkLnBhcmVudE5vZGUmJihjJiZyLmNvbnRhaW5zKGQub3duZXJEb2N1bWVudCxkKSYmbmEobWEoZCxcInNjcmlwdFwiKSksZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpKTtyZXR1cm4gYX1yLmV4dGVuZCh7aHRtbFByZWZpbHRlcjpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKHlhLFwiPCQxPjwvJDI+XCIpfSxjbG9uZTpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGcsaD1hLmNsb25lTm9kZSghMCksaT1yLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKTtpZighKG8ubm9DbG9uZUNoZWNrZWR8fDEhPT1hLm5vZGVUeXBlJiYxMSE9PWEubm9kZVR5cGV8fHIuaXNYTUxEb2MoYSkpKWZvcihnPW1hKGgpLGY9bWEoYSksZD0wLGU9Zi5sZW5ndGg7ZDxlO2QrKylIYShmW2RdLGdbZF0pO2lmKGIpaWYoYylmb3IoZj1mfHxtYShhKSxnPWd8fG1hKGgpLGQ9MCxlPWYubGVuZ3RoO2Q8ZTtkKyspR2EoZltkXSxnW2RdKTtlbHNlIEdhKGEsaCk7cmV0dXJuIGc9bWEoaCxcInNjcmlwdFwiKSxnLmxlbmd0aD4wJiZuYShnLCFpJiZtYShhLFwic2NyaXB0XCIpKSxofSxjbGVhbkRhdGE6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiLGMsZCxlPXIuZXZlbnQuc3BlY2lhbCxmPTA7dm9pZCAwIT09KGM9YVtmXSk7ZisrKWlmKFQoYykpe2lmKGI9Y1tWLmV4cGFuZG9dKXtpZihiLmV2ZW50cylmb3IoZCBpbiBiLmV2ZW50cyllW2RdP3IuZXZlbnQucmVtb3ZlKGMsZCk6ci5yZW1vdmVFdmVudChjLGQsYi5oYW5kbGUpO2NbVi5leHBhbmRvXT12b2lkIDB9Y1tXLmV4cGFuZG9dJiYoY1tXLmV4cGFuZG9dPXZvaWQgMCl9fX0pLHIuZm4uZXh0ZW5kKHtkZXRhY2g6ZnVuY3Rpb24oYSl7cmV0dXJuIEphKHRoaXMsYSwhMCl9LHJlbW92ZTpmdW5jdGlvbihhKXtyZXR1cm4gSmEodGhpcyxhKX0sdGV4dDpmdW5jdGlvbihhKXtyZXR1cm4gUyh0aGlzLGZ1bmN0aW9uKGEpe3JldHVybiB2b2lkIDA9PT1hP3IudGV4dCh0aGlzKTp0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbigpezEhPT10aGlzLm5vZGVUeXBlJiYxMSE9PXRoaXMubm9kZVR5cGUmJjkhPT10aGlzLm5vZGVUeXBlfHwodGhpcy50ZXh0Q29udGVudD1hKX0pfSxudWxsLGEsYXJndW1lbnRzLmxlbmd0aCl9LGFwcGVuZDpmdW5jdGlvbigpe3JldHVybiBJYSh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihhKXtpZigxPT09dGhpcy5ub2RlVHlwZXx8MTE9PT10aGlzLm5vZGVUeXBlfHw5PT09dGhpcy5ub2RlVHlwZSl7dmFyIGI9RGEodGhpcyxhKTtiLmFwcGVuZENoaWxkKGEpfX0pfSxwcmVwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIElhKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGEpe2lmKDE9PT10aGlzLm5vZGVUeXBlfHwxMT09PXRoaXMubm9kZVR5cGV8fDk9PT10aGlzLm5vZGVUeXBlKXt2YXIgYj1EYSh0aGlzLGEpO2IuaW5zZXJ0QmVmb3JlKGEsYi5maXJzdENoaWxkKX19KX0sYmVmb3JlOmZ1bmN0aW9uKCl7cmV0dXJuIElhKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGEpe3RoaXMucGFyZW50Tm9kZSYmdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLHRoaXMpfSl9LGFmdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIElhKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGEpe3RoaXMucGFyZW50Tm9kZSYmdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLHRoaXMubmV4dFNpYmxpbmcpfSl9LGVtcHR5OmZ1bmN0aW9uKCl7Zm9yKHZhciBhLGI9MDtudWxsIT0oYT10aGlzW2JdKTtiKyspMT09PWEubm9kZVR5cGUmJihyLmNsZWFuRGF0YShtYShhLCExKSksYS50ZXh0Q29udGVudD1cIlwiKTtyZXR1cm4gdGhpc30sY2xvbmU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT1udWxsIT1hJiZhLGI9bnVsbD09Yj9hOmIsdGhpcy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gci5jbG9uZSh0aGlzLGEsYil9KX0saHRtbDpmdW5jdGlvbihhKXtyZXR1cm4gUyh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXNbMF18fHt9LGM9MCxkPXRoaXMubGVuZ3RoO2lmKHZvaWQgMD09PWEmJjE9PT1iLm5vZGVUeXBlKXJldHVybiBiLmlubmVySFRNTDtpZihcInN0cmluZ1wiPT10eXBlb2YgYSYmIXphLnRlc3QoYSkmJiFsYVsoamEuZXhlYyhhKXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCldKXthPXIuaHRtbFByZWZpbHRlcihhKTt0cnl7Zm9yKDtjPGQ7YysrKWI9dGhpc1tjXXx8e30sMT09PWIubm9kZVR5cGUmJihyLmNsZWFuRGF0YShtYShiLCExKSksYi5pbm5lckhUTUw9YSk7Yj0wfWNhdGNoKGUpe319YiYmdGhpcy5lbXB0eSgpLmFwcGVuZChhKX0sbnVsbCxhLGFyZ3VtZW50cy5sZW5ndGgpfSxyZXBsYWNlV2l0aDpmdW5jdGlvbigpe3ZhciBhPVtdO3JldHVybiBJYSh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihiKXt2YXIgYz10aGlzLnBhcmVudE5vZGU7ci5pbkFycmF5KHRoaXMsYSk8MCYmKHIuY2xlYW5EYXRhKG1hKHRoaXMpKSxjJiZjLnJlcGxhY2VDaGlsZChiLHRoaXMpKX0sYSl9fSksci5lYWNoKHthcHBlbmRUbzpcImFwcGVuZFwiLHByZXBlbmRUbzpcInByZXBlbmRcIixpbnNlcnRCZWZvcmU6XCJiZWZvcmVcIixpbnNlcnRBZnRlcjpcImFmdGVyXCIscmVwbGFjZUFsbDpcInJlcGxhY2VXaXRoXCJ9LGZ1bmN0aW9uKGEsYil7ci5mblthXT1mdW5jdGlvbihhKXtmb3IodmFyIGMsZD1bXSxlPXIoYSksZj1lLmxlbmd0aC0xLGc9MDtnPD1mO2crKyljPWc9PT1mP3RoaXM6dGhpcy5jbG9uZSghMCkscihlW2ddKVtiXShjKSxoLmFwcGx5KGQsYy5nZXQoKSk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGQpfX0pO3ZhciBLYT0vXm1hcmdpbi8sTGE9bmV3IFJlZ0V4cChcIl4oXCIrXytcIikoPyFweClbYS16JV0rJFwiLFwiaVwiKSxNYT1mdW5jdGlvbihiKXt2YXIgYz1iLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7cmV0dXJuIGMmJmMub3BlbmVyfHwoYz1hKSxjLmdldENvbXB1dGVkU3R5bGUoYil9OyFmdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXtpZihpKXtpLnN0eWxlLmNzc1RleHQ9XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jazttYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O3RvcDoxJTt3aWR0aDo1MCVcIixpLmlubmVySFRNTD1cIlwiLHFhLmFwcGVuZENoaWxkKGgpO3ZhciBiPWEuZ2V0Q29tcHV0ZWRTdHlsZShpKTtjPVwiMSVcIiE9PWIudG9wLGc9XCIycHhcIj09PWIubWFyZ2luTGVmdCxlPVwiNHB4XCI9PT1iLndpZHRoLGkuc3R5bGUubWFyZ2luUmlnaHQ9XCI1MCVcIixmPVwiNHB4XCI9PT1iLm1hcmdpblJpZ2h0LHFhLnJlbW92ZUNoaWxkKGgpLGk9bnVsbH19dmFyIGMsZSxmLGcsaD1kLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksaT1kLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aS5zdHlsZSYmKGkuc3R5bGUuYmFja2dyb3VuZENsaXA9XCJjb250ZW50LWJveFwiLGkuY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcD1cIlwiLG8uY2xlYXJDbG9uZVN0eWxlPVwiY29udGVudC1ib3hcIj09PWkuc3R5bGUuYmFja2dyb3VuZENsaXAsaC5zdHlsZS5jc3NUZXh0PVwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtwYWRkaW5nOjA7bWFyZ2luLXRvcDoxcHg7cG9zaXRpb246YWJzb2x1dGVcIixoLmFwcGVuZENoaWxkKGkpLHIuZXh0ZW5kKG8se3BpeGVsUG9zaXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gYigpLGN9LGJveFNpemluZ1JlbGlhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIGIoKSxlfSxwaXhlbE1hcmdpblJpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIGIoKSxmfSxyZWxpYWJsZU1hcmdpbkxlZnQ6ZnVuY3Rpb24oKXtyZXR1cm4gYigpLGd9fSkpfSgpO2Z1bmN0aW9uIE5hKGEsYixjKXt2YXIgZCxlLGYsZyxoPWEuc3R5bGU7cmV0dXJuIGM9Y3x8TWEoYSksYyYmKGc9Yy5nZXRQcm9wZXJ0eVZhbHVlKGIpfHxjW2JdLFwiXCIhPT1nfHxyLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKXx8KGc9ci5zdHlsZShhLGIpKSwhby5waXhlbE1hcmdpblJpZ2h0KCkmJkxhLnRlc3QoZykmJkthLnRlc3QoYikmJihkPWgud2lkdGgsZT1oLm1pbldpZHRoLGY9aC5tYXhXaWR0aCxoLm1pbldpZHRoPWgubWF4V2lkdGg9aC53aWR0aD1nLGc9Yy53aWR0aCxoLndpZHRoPWQsaC5taW5XaWR0aD1lLGgubWF4V2lkdGg9ZikpLHZvaWQgMCE9PWc/ZytcIlwiOmd9ZnVuY3Rpb24gT2EoYSxiKXtyZXR1cm57Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEoKT92b2lkIGRlbGV0ZSB0aGlzLmdldDoodGhpcy5nZXQ9YikuYXBwbHkodGhpcyxhcmd1bWVudHMpfX19dmFyIFBhPS9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxRYT17cG9zaXRpb246XCJhYnNvbHV0ZVwiLHZpc2liaWxpdHk6XCJoaWRkZW5cIixkaXNwbGF5OlwiYmxvY2tcIn0sUmE9e2xldHRlclNwYWNpbmc6XCIwXCIsZm9udFdlaWdodDpcIjQwMFwifSxTYT1bXCJXZWJraXRcIixcIk1velwiLFwibXNcIl0sVGE9ZC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlO2Z1bmN0aW9uIFVhKGEpe2lmKGEgaW4gVGEpcmV0dXJuIGE7dmFyIGI9YVswXS50b1VwcGVyQ2FzZSgpK2Euc2xpY2UoMSksYz1TYS5sZW5ndGg7d2hpbGUoYy0tKWlmKGE9U2FbY10rYixhIGluIFRhKXJldHVybiBhfWZ1bmN0aW9uIFZhKGEsYixjKXt2YXIgZD1hYS5leGVjKGIpO3JldHVybiBkP01hdGgubWF4KDAsZFsyXS0oY3x8MCkpKyhkWzNdfHxcInB4XCIpOmJ9ZnVuY3Rpb24gV2EoYSxiLGMsZCxlKXt2YXIgZixnPTA7Zm9yKGY9Yz09PShkP1wiYm9yZGVyXCI6XCJjb250ZW50XCIpPzQ6XCJ3aWR0aFwiPT09Yj8xOjA7Zjw0O2YrPTIpXCJtYXJnaW5cIj09PWMmJihnKz1yLmNzcyhhLGMrYmFbZl0sITAsZSkpLGQ/KFwiY29udGVudFwiPT09YyYmKGctPXIuY3NzKGEsXCJwYWRkaW5nXCIrYmFbZl0sITAsZSkpLFwibWFyZ2luXCIhPT1jJiYoZy09ci5jc3MoYSxcImJvcmRlclwiK2JhW2ZdK1wiV2lkdGhcIiwhMCxlKSkpOihnKz1yLmNzcyhhLFwicGFkZGluZ1wiK2JhW2ZdLCEwLGUpLFwicGFkZGluZ1wiIT09YyYmKGcrPXIuY3NzKGEsXCJib3JkZXJcIitiYVtmXStcIldpZHRoXCIsITAsZSkpKTtyZXR1cm4gZ31mdW5jdGlvbiBYYShhLGIsYyl7dmFyIGQsZT0hMCxmPU1hKGEpLGc9XCJib3JkZXItYm94XCI9PT1yLmNzcyhhLFwiYm94U2l6aW5nXCIsITEsZik7aWYoYS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCYmKGQ9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtiXSksZDw9MHx8bnVsbD09ZCl7aWYoZD1OYShhLGIsZiksKGQ8MHx8bnVsbD09ZCkmJihkPWEuc3R5bGVbYl0pLExhLnRlc3QoZCkpcmV0dXJuIGQ7ZT1nJiYoby5ib3hTaXppbmdSZWxpYWJsZSgpfHxkPT09YS5zdHlsZVtiXSksZD1wYXJzZUZsb2F0KGQpfHwwfXJldHVybiBkK1dhKGEsYixjfHwoZz9cImJvcmRlclwiOlwiY29udGVudFwiKSxlLGYpK1wicHhcIn1yLmV4dGVuZCh7Y3NzSG9va3M6e29wYWNpdHk6e2dldDpmdW5jdGlvbihhLGIpe2lmKGIpe3ZhciBjPU5hKGEsXCJvcGFjaXR5XCIpO3JldHVyblwiXCI9PT1jP1wiMVwiOmN9fX19LGNzc051bWJlcjp7YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ITAsY29sdW1uQ291bnQ6ITAsZmlsbE9wYWNpdHk6ITAsZmxleEdyb3c6ITAsZmxleFNocmluazohMCxmb250V2VpZ2h0OiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHdpZG93czohMCx6SW5kZXg6ITAsem9vbTohMH0sY3NzUHJvcHM6e1wiZmxvYXRcIjpcImNzc0Zsb2F0XCJ9LHN0eWxlOmZ1bmN0aW9uKGEsYixjLGQpe2lmKGEmJjMhPT1hLm5vZGVUeXBlJiY4IT09YS5ub2RlVHlwZSYmYS5zdHlsZSl7dmFyIGUsZixnLGg9ci5jYW1lbENhc2UoYiksaT1hLnN0eWxlO3JldHVybiBiPXIuY3NzUHJvcHNbaF18fChyLmNzc1Byb3BzW2hdPVVhKGgpfHxoKSxnPXIuY3NzSG9va3NbYl18fHIuY3NzSG9va3NbaF0sdm9pZCAwPT09Yz9nJiZcImdldFwiaW4gZyYmdm9pZCAwIT09KGU9Zy5nZXQoYSwhMSxkKSk/ZTppW2JdOihmPXR5cGVvZiBjLFwic3RyaW5nXCI9PT1mJiYoZT1hYS5leGVjKGMpKSYmZVsxXSYmKGM9ZWEoYSxiLGUpLGY9XCJudW1iZXJcIiksbnVsbCE9YyYmYz09PWMmJihcIm51bWJlclwiPT09ZiYmKGMrPWUmJmVbM118fChyLmNzc051bWJlcltoXT9cIlwiOlwicHhcIikpLG8uY2xlYXJDbG9uZVN0eWxlfHxcIlwiIT09Y3x8MCE9PWIuaW5kZXhPZihcImJhY2tncm91bmRcIil8fChpW2JdPVwiaW5oZXJpdFwiKSxnJiZcInNldFwiaW4gZyYmdm9pZCAwPT09KGM9Zy5zZXQoYSxjLGQpKXx8KGlbYl09YykpLHZvaWQgMCl9fSxjc3M6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGUsZixnLGg9ci5jYW1lbENhc2UoYik7cmV0dXJuIGI9ci5jc3NQcm9wc1toXXx8KHIuY3NzUHJvcHNbaF09VWEoaCl8fGgpLGc9ci5jc3NIb29rc1tiXXx8ci5jc3NIb29rc1toXSxnJiZcImdldFwiaW4gZyYmKGU9Zy5nZXQoYSwhMCxjKSksdm9pZCAwPT09ZSYmKGU9TmEoYSxiLGQpKSxcIm5vcm1hbFwiPT09ZSYmYiBpbiBSYSYmKGU9UmFbYl0pLFwiXCI9PT1jfHxjPyhmPXBhcnNlRmxvYXQoZSksYz09PSEwfHxpc0Zpbml0ZShmKT9mfHwwOmUpOmV9fSksci5lYWNoKFtcImhlaWdodFwiLFwid2lkdGhcIl0sZnVuY3Rpb24oYSxiKXtyLmNzc0hvb2tzW2JdPXtnZXQ6ZnVuY3Rpb24oYSxjLGQpe2lmKGMpcmV0dXJuIVBhLnRlc3Qoci5jc3MoYSxcImRpc3BsYXlcIikpfHxhLmdldENsaWVudFJlY3RzKCkubGVuZ3RoJiZhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoP1hhKGEsYixkKTpkYShhLFFhLGZ1bmN0aW9uKCl7cmV0dXJuIFhhKGEsYixkKX0pfSxzZXQ6ZnVuY3Rpb24oYSxjLGQpe3ZhciBlLGY9ZCYmTWEoYSksZz1kJiZXYShhLGIsZCxcImJvcmRlci1ib3hcIj09PXIuY3NzKGEsXCJib3hTaXppbmdcIiwhMSxmKSxmKTtyZXR1cm4gZyYmKGU9YWEuZXhlYyhjKSkmJlwicHhcIiE9PShlWzNdfHxcInB4XCIpJiYoYS5zdHlsZVtiXT1jLGM9ci5jc3MoYSxiKSksVmEoYSxjLGcpfX19KSxyLmNzc0hvb2tzLm1hcmdpbkxlZnQ9T2Eoby5yZWxpYWJsZU1hcmdpbkxlZnQsZnVuY3Rpb24oYSxiKXtpZihiKXJldHVybihwYXJzZUZsb2F0KE5hKGEsXCJtYXJnaW5MZWZ0XCIpKXx8YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LWRhKGEse21hcmdpbkxlZnQ6MH0sZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0fSkpK1wicHhcIn0pLHIuZWFjaCh7bWFyZ2luOlwiXCIscGFkZGluZzpcIlwiLGJvcmRlcjpcIldpZHRoXCJ9LGZ1bmN0aW9uKGEsYil7ci5jc3NIb29rc1thK2JdPXtleHBhbmQ6ZnVuY3Rpb24oYyl7Zm9yKHZhciBkPTAsZT17fSxmPVwic3RyaW5nXCI9PXR5cGVvZiBjP2Muc3BsaXQoXCIgXCIpOltjXTtkPDQ7ZCsrKWVbYStiYVtkXStiXT1mW2RdfHxmW2QtMl18fGZbMF07cmV0dXJuIGV9fSxLYS50ZXN0KGEpfHwoci5jc3NIb29rc1thK2JdLnNldD1WYSl9KSxyLmZuLmV4dGVuZCh7Y3NzOmZ1bmN0aW9uKGEsYil7cmV0dXJuIFModGhpcyxmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPXt9LGc9MDtpZihyLmlzQXJyYXkoYikpe2ZvcihkPU1hKGEpLGU9Yi5sZW5ndGg7ZzxlO2crKylmW2JbZ11dPXIuY3NzKGEsYltnXSwhMSxkKTtyZXR1cm4gZn1yZXR1cm4gdm9pZCAwIT09Yz9yLnN0eWxlKGEsYixjKTpyLmNzcyhhLGIpfSxhLGIsYXJndW1lbnRzLmxlbmd0aD4xKX19KTtmdW5jdGlvbiBZYShhLGIsYyxkLGUpe3JldHVybiBuZXcgWWEucHJvdG90eXBlLmluaXQoYSxiLGMsZCxlKX1yLlR3ZWVuPVlhLFlhLnByb3RvdHlwZT17Y29uc3RydWN0b3I6WWEsaW5pdDpmdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5lbGVtPWEsdGhpcy5wcm9wPWMsdGhpcy5lYXNpbmc9ZXx8ci5lYXNpbmcuX2RlZmF1bHQsdGhpcy5vcHRpb25zPWIsdGhpcy5zdGFydD10aGlzLm5vdz10aGlzLmN1cigpLHRoaXMuZW5kPWQsdGhpcy51bml0PWZ8fChyLmNzc051bWJlcltjXT9cIlwiOlwicHhcIil9LGN1cjpmdW5jdGlvbigpe3ZhciBhPVlhLnByb3BIb29rc1t0aGlzLnByb3BdO3JldHVybiBhJiZhLmdldD9hLmdldCh0aGlzKTpZYS5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpfSxydW46ZnVuY3Rpb24oYSl7dmFyIGIsYz1ZYS5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gdGhpcy5vcHRpb25zLmR1cmF0aW9uP3RoaXMucG9zPWI9ci5lYXNpbmdbdGhpcy5lYXNpbmddKGEsdGhpcy5vcHRpb25zLmR1cmF0aW9uKmEsMCwxLHRoaXMub3B0aW9ucy5kdXJhdGlvbik6dGhpcy5wb3M9Yj1hLHRoaXMubm93PSh0aGlzLmVuZC10aGlzLnN0YXJ0KSpiK3RoaXMuc3RhcnQsdGhpcy5vcHRpb25zLnN0ZXAmJnRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5lbGVtLHRoaXMubm93LHRoaXMpLGMmJmMuc2V0P2Muc2V0KHRoaXMpOllhLnByb3BIb29rcy5fZGVmYXVsdC5zZXQodGhpcyksdGhpc319LFlhLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZT1ZYS5wcm90b3R5cGUsWWEucHJvcEhvb2tzPXtfZGVmYXVsdDp7Z2V0OmZ1bmN0aW9uKGEpe3ZhciBiO3JldHVybiAxIT09YS5lbGVtLm5vZGVUeXBlfHxudWxsIT1hLmVsZW1bYS5wcm9wXSYmbnVsbD09YS5lbGVtLnN0eWxlW2EucHJvcF0/YS5lbGVtW2EucHJvcF06KGI9ci5jc3MoYS5lbGVtLGEucHJvcCxcIlwiKSxiJiZcImF1dG9cIiE9PWI/YjowKX0sc2V0OmZ1bmN0aW9uKGEpe3IuZnguc3RlcFthLnByb3BdP3IuZnguc3RlcFthLnByb3BdKGEpOjEhPT1hLmVsZW0ubm9kZVR5cGV8fG51bGw9PWEuZWxlbS5zdHlsZVtyLmNzc1Byb3BzW2EucHJvcF1dJiYhci5jc3NIb29rc1thLnByb3BdP2EuZWxlbVthLnByb3BdPWEubm93OnIuc3R5bGUoYS5lbGVtLGEucHJvcCxhLm5vdythLnVuaXQpfX19LFlhLnByb3BIb29rcy5zY3JvbGxUb3A9WWEucHJvcEhvb2tzLnNjcm9sbExlZnQ9e3NldDpmdW5jdGlvbihhKXthLmVsZW0ubm9kZVR5cGUmJmEuZWxlbS5wYXJlbnROb2RlJiYoYS5lbGVtW2EucHJvcF09YS5ub3cpfX0sci5lYXNpbmc9e2xpbmVhcjpmdW5jdGlvbihhKXtyZXR1cm4gYX0sc3dpbmc6ZnVuY3Rpb24oYSl7cmV0dXJuLjUtTWF0aC5jb3MoYSpNYXRoLlBJKS8yfSxfZGVmYXVsdDpcInN3aW5nXCJ9LHIuZng9WWEucHJvdG90eXBlLmluaXQsci5meC5zdGVwPXt9O3ZhciBaYSwkYSxfYT0vXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sYWI9L3F1ZXVlSG9va3MkLztmdW5jdGlvbiBiYigpeyRhJiYoYS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYmIpLHIuZngudGljaygpKX1mdW5jdGlvbiBjYigpe3JldHVybiBhLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtaYT12b2lkIDB9KSxaYT1yLm5vdygpfWZ1bmN0aW9uIGRiKGEsYil7dmFyIGMsZD0wLGU9e2hlaWdodDphfTtmb3IoYj1iPzE6MDtkPDQ7ZCs9Mi1iKWM9YmFbZF0sZVtcIm1hcmdpblwiK2NdPWVbXCJwYWRkaW5nXCIrY109YTtyZXR1cm4gYiYmKGUub3BhY2l0eT1lLndpZHRoPWEpLGV9ZnVuY3Rpb24gZWIoYSxiLGMpe2Zvcih2YXIgZCxlPShoYi50d2VlbmVyc1tiXXx8W10pLmNvbmNhdChoYi50d2VlbmVyc1tcIipcIl0pLGY9MCxnPWUubGVuZ3RoO2Y8ZztmKyspaWYoZD1lW2ZdLmNhbGwoYyxiLGEpKXJldHVybiBkfWZ1bmN0aW9uIGZiKGEsYixjKXt2YXIgZCxlLGYsZyxoLGksaixrLGw9XCJ3aWR0aFwiaW4gYnx8XCJoZWlnaHRcImluIGIsbT10aGlzLG49e30sbz1hLnN0eWxlLHA9YS5ub2RlVHlwZSYmY2EoYSkscT1WLmdldChhLFwiZnhzaG93XCIpO2MucXVldWV8fChnPXIuX3F1ZXVlSG9va3MoYSxcImZ4XCIpLG51bGw9PWcudW5xdWV1ZWQmJihnLnVucXVldWVkPTAsaD1nLmVtcHR5LmZpcmUsZy5lbXB0eS5maXJlPWZ1bmN0aW9uKCl7Zy51bnF1ZXVlZHx8aCgpfSksZy51bnF1ZXVlZCsrLG0uYWx3YXlzKGZ1bmN0aW9uKCl7bS5hbHdheXMoZnVuY3Rpb24oKXtnLnVucXVldWVkLS0sci5xdWV1ZShhLFwiZnhcIikubGVuZ3RofHxnLmVtcHR5LmZpcmUoKX0pfSkpO2ZvcihkIGluIGIpaWYoZT1iW2RdLF9hLnRlc3QoZSkpe2lmKGRlbGV0ZSBiW2RdLGY9Znx8XCJ0b2dnbGVcIj09PWUsZT09PShwP1wiaGlkZVwiOlwic2hvd1wiKSl7aWYoXCJzaG93XCIhPT1lfHwhcXx8dm9pZCAwPT09cVtkXSljb250aW51ZTtwPSEwfW5bZF09cSYmcVtkXXx8ci5zdHlsZShhLGQpfWlmKGk9IXIuaXNFbXB0eU9iamVjdChiKSxpfHwhci5pc0VtcHR5T2JqZWN0KG4pKXtsJiYxPT09YS5ub2RlVHlwZSYmKGMub3ZlcmZsb3c9W28ub3ZlcmZsb3csby5vdmVyZmxvd1gsby5vdmVyZmxvd1ldLGo9cSYmcS5kaXNwbGF5LG51bGw9PWomJihqPVYuZ2V0KGEsXCJkaXNwbGF5XCIpKSxrPXIuY3NzKGEsXCJkaXNwbGF5XCIpLFwibm9uZVwiPT09ayYmKGo/az1qOihoYShbYV0sITApLGo9YS5zdHlsZS5kaXNwbGF5fHxqLGs9ci5jc3MoYSxcImRpc3BsYXlcIiksaGEoW2FdKSkpLChcImlubGluZVwiPT09a3x8XCJpbmxpbmUtYmxvY2tcIj09PWsmJm51bGwhPWopJiZcIm5vbmVcIj09PXIuY3NzKGEsXCJmbG9hdFwiKSYmKGl8fChtLmRvbmUoZnVuY3Rpb24oKXtvLmRpc3BsYXk9an0pLG51bGw9PWomJihrPW8uZGlzcGxheSxqPVwibm9uZVwiPT09az9cIlwiOmspKSxvLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIikpLGMub3ZlcmZsb3cmJihvLm92ZXJmbG93PVwiaGlkZGVuXCIsbS5hbHdheXMoZnVuY3Rpb24oKXtvLm92ZXJmbG93PWMub3ZlcmZsb3dbMF0sby5vdmVyZmxvd1g9Yy5vdmVyZmxvd1sxXSxvLm92ZXJmbG93WT1jLm92ZXJmbG93WzJdfSkpLGk9ITE7Zm9yKGQgaW4gbilpfHwocT9cImhpZGRlblwiaW4gcSYmKHA9cS5oaWRkZW4pOnE9Vi5hY2Nlc3MoYSxcImZ4c2hvd1wiLHtkaXNwbGF5Omp9KSxmJiYocS5oaWRkZW49IXApLHAmJmhhKFthXSwhMCksbS5kb25lKGZ1bmN0aW9uKCl7cHx8aGEoW2FdKSxWLnJlbW92ZShhLFwiZnhzaG93XCIpO2ZvcihkIGluIG4pci5zdHlsZShhLGQsbltkXSl9KSksaT1lYihwP3FbZF06MCxkLG0pLGQgaW4gcXx8KHFbZF09aS5zdGFydCxwJiYoaS5lbmQ9aS5zdGFydCxpLnN0YXJ0PTApKX19ZnVuY3Rpb24gZ2IoYSxiKXt2YXIgYyxkLGUsZixnO2ZvcihjIGluIGEpaWYoZD1yLmNhbWVsQ2FzZShjKSxlPWJbZF0sZj1hW2NdLHIuaXNBcnJheShmKSYmKGU9ZlsxXSxmPWFbY109ZlswXSksYyE9PWQmJihhW2RdPWYsZGVsZXRlIGFbY10pLGc9ci5jc3NIb29rc1tkXSxnJiZcImV4cGFuZFwiaW4gZyl7Zj1nLmV4cGFuZChmKSxkZWxldGUgYVtkXTtmb3IoYyBpbiBmKWMgaW4gYXx8KGFbY109ZltjXSxiW2NdPWUpfWVsc2UgYltkXT1lfWZ1bmN0aW9uIGhiKGEsYixjKXt2YXIgZCxlLGY9MCxnPWhiLnByZWZpbHRlcnMubGVuZ3RoLGg9ci5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbigpe2RlbGV0ZSBpLmVsZW19KSxpPWZ1bmN0aW9uKCl7aWYoZSlyZXR1cm4hMTtmb3IodmFyIGI9WmF8fGNiKCksYz1NYXRoLm1heCgwLGouc3RhcnRUaW1lK2ouZHVyYXRpb24tYiksZD1jL2ouZHVyYXRpb258fDAsZj0xLWQsZz0wLGk9ai50d2VlbnMubGVuZ3RoO2c8aTtnKyspai50d2VlbnNbZ10ucnVuKGYpO3JldHVybiBoLm5vdGlmeVdpdGgoYSxbaixmLGNdKSxmPDEmJmk/YzooaC5yZXNvbHZlV2l0aChhLFtqXSksITEpfSxqPWgucHJvbWlzZSh7ZWxlbTphLHByb3BzOnIuZXh0ZW5kKHt9LGIpLG9wdHM6ci5leHRlbmQoITAse3NwZWNpYWxFYXNpbmc6e30sZWFzaW5nOnIuZWFzaW5nLl9kZWZhdWx0fSxjKSxvcmlnaW5hbFByb3BlcnRpZXM6YixvcmlnaW5hbE9wdGlvbnM6YyxzdGFydFRpbWU6WmF8fGNiKCksZHVyYXRpb246Yy5kdXJhdGlvbix0d2VlbnM6W10sY3JlYXRlVHdlZW46ZnVuY3Rpb24oYixjKXt2YXIgZD1yLlR3ZWVuKGEsai5vcHRzLGIsYyxqLm9wdHMuc3BlY2lhbEVhc2luZ1tiXXx8ai5vcHRzLmVhc2luZyk7cmV0dXJuIGoudHdlZW5zLnB1c2goZCksZH0sc3RvcDpmdW5jdGlvbihiKXt2YXIgYz0wLGQ9Yj9qLnR3ZWVucy5sZW5ndGg6MDtpZihlKXJldHVybiB0aGlzO2ZvcihlPSEwO2M8ZDtjKyspai50d2VlbnNbY10ucnVuKDEpO3JldHVybiBiPyhoLm5vdGlmeVdpdGgoYSxbaiwxLDBdKSxoLnJlc29sdmVXaXRoKGEsW2osYl0pKTpoLnJlamVjdFdpdGgoYSxbaixiXSksdGhpc319KSxrPWoucHJvcHM7Zm9yKGdiKGssai5vcHRzLnNwZWNpYWxFYXNpbmcpO2Y8ZztmKyspaWYoZD1oYi5wcmVmaWx0ZXJzW2ZdLmNhbGwoaixhLGssai5vcHRzKSlyZXR1cm4gci5pc0Z1bmN0aW9uKGQuc3RvcCkmJihyLl9xdWV1ZUhvb2tzKGouZWxlbSxqLm9wdHMucXVldWUpLnN0b3A9ci5wcm94eShkLnN0b3AsZCkpLGQ7cmV0dXJuIHIubWFwKGssZWIsaiksci5pc0Z1bmN0aW9uKGoub3B0cy5zdGFydCkmJmoub3B0cy5zdGFydC5jYWxsKGEsaiksci5meC50aW1lcihyLmV4dGVuZChpLHtlbGVtOmEsYW5pbTpqLHF1ZXVlOmoub3B0cy5xdWV1ZX0pKSxqLnByb2dyZXNzKGoub3B0cy5wcm9ncmVzcykuZG9uZShqLm9wdHMuZG9uZSxqLm9wdHMuY29tcGxldGUpLmZhaWwoai5vcHRzLmZhaWwpLmFsd2F5cyhqLm9wdHMuYWx3YXlzKX1yLkFuaW1hdGlvbj1yLmV4dGVuZChoYix7dHdlZW5lcnM6e1wiKlwiOltmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuY3JlYXRlVHdlZW4oYSxiKTtyZXR1cm4gZWEoYy5lbGVtLGEsYWEuZXhlYyhiKSxjKSxjfV19LHR3ZWVuZXI6ZnVuY3Rpb24oYSxiKXtyLmlzRnVuY3Rpb24oYSk/KGI9YSxhPVtcIipcIl0pOmE9YS5tYXRjaChLKTtmb3IodmFyIGMsZD0wLGU9YS5sZW5ndGg7ZDxlO2QrKyljPWFbZF0saGIudHdlZW5lcnNbY109aGIudHdlZW5lcnNbY118fFtdLGhiLnR3ZWVuZXJzW2NdLnVuc2hpZnQoYil9LHByZWZpbHRlcnM6W2ZiXSxwcmVmaWx0ZXI6ZnVuY3Rpb24oYSxiKXtiP2hiLnByZWZpbHRlcnMudW5zaGlmdChhKTpoYi5wcmVmaWx0ZXJzLnB1c2goYSl9fSksci5zcGVlZD1mdW5jdGlvbihhLGIsYyl7dmFyIGU9YSYmXCJvYmplY3RcIj09dHlwZW9mIGE/ci5leHRlbmQoe30sYSk6e2NvbXBsZXRlOmN8fCFjJiZifHxyLmlzRnVuY3Rpb24oYSkmJmEsZHVyYXRpb246YSxlYXNpbmc6YyYmYnx8YiYmIXIuaXNGdW5jdGlvbihiKSYmYn07cmV0dXJuIHIuZngub2ZmfHxkLmhpZGRlbj9lLmR1cmF0aW9uPTA6XCJudW1iZXJcIiE9dHlwZW9mIGUuZHVyYXRpb24mJihlLmR1cmF0aW9uIGluIHIuZnguc3BlZWRzP2UuZHVyYXRpb249ci5meC5zcGVlZHNbZS5kdXJhdGlvbl06ZS5kdXJhdGlvbj1yLmZ4LnNwZWVkcy5fZGVmYXVsdCksbnVsbCE9ZS5xdWV1ZSYmZS5xdWV1ZSE9PSEwfHwoZS5xdWV1ZT1cImZ4XCIpLGUub2xkPWUuY29tcGxldGUsZS5jb21wbGV0ZT1mdW5jdGlvbigpe3IuaXNGdW5jdGlvbihlLm9sZCkmJmUub2xkLmNhbGwodGhpcyksZS5xdWV1ZSYmci5kZXF1ZXVlKHRoaXMsZS5xdWV1ZSl9LGV9LHIuZm4uZXh0ZW5kKHtmYWRlVG86ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMuZmlsdGVyKGNhKS5jc3MoXCJvcGFjaXR5XCIsMCkuc2hvdygpLmVuZCgpLmFuaW1hdGUoe29wYWNpdHk6Yn0sYSxjLGQpfSxhbmltYXRlOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXIuaXNFbXB0eU9iamVjdChhKSxmPXIuc3BlZWQoYixjLGQpLGc9ZnVuY3Rpb24oKXt2YXIgYj1oYih0aGlzLHIuZXh0ZW5kKHt9LGEpLGYpOyhlfHxWLmdldCh0aGlzLFwiZmluaXNoXCIpKSYmYi5zdG9wKCEwKX07cmV0dXJuIGcuZmluaXNoPWcsZXx8Zi5xdWV1ZT09PSExP3RoaXMuZWFjaChnKTp0aGlzLnF1ZXVlKGYucXVldWUsZyl9LHN0b3A6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWZ1bmN0aW9uKGEpe3ZhciBiPWEuc3RvcDtkZWxldGUgYS5zdG9wLGIoYyl9O3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBhJiYoYz1iLGI9YSxhPXZvaWQgMCksYiYmYSE9PSExJiZ0aGlzLnF1ZXVlKGF8fFwiZnhcIixbXSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGI9ITAsZT1udWxsIT1hJiZhK1wicXVldWVIb29rc1wiLGY9ci50aW1lcnMsZz1WLmdldCh0aGlzKTtpZihlKWdbZV0mJmdbZV0uc3RvcCYmZChnW2VdKTtlbHNlIGZvcihlIGluIGcpZ1tlXSYmZ1tlXS5zdG9wJiZhYi50ZXN0KGUpJiZkKGdbZV0pO2ZvcihlPWYubGVuZ3RoO2UtLTspZltlXS5lbGVtIT09dGhpc3x8bnVsbCE9YSYmZltlXS5xdWV1ZSE9PWF8fChmW2VdLmFuaW0uc3RvcChjKSxiPSExLGYuc3BsaWNlKGUsMSkpOyFiJiZjfHxyLmRlcXVldWUodGhpcyxhKX0pfSxmaW5pc2g6ZnVuY3Rpb24oYSl7cmV0dXJuIGEhPT0hMSYmKGE9YXx8XCJmeFwiKSx0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYixjPVYuZ2V0KHRoaXMpLGQ9Y1thK1wicXVldWVcIl0sZT1jW2ErXCJxdWV1ZUhvb2tzXCJdLGY9ci50aW1lcnMsZz1kP2QubGVuZ3RoOjA7Zm9yKGMuZmluaXNoPSEwLHIucXVldWUodGhpcyxhLFtdKSxlJiZlLnN0b3AmJmUuc3RvcC5jYWxsKHRoaXMsITApLGI9Zi5sZW5ndGg7Yi0tOylmW2JdLmVsZW09PT10aGlzJiZmW2JdLnF1ZXVlPT09YSYmKGZbYl0uYW5pbS5zdG9wKCEwKSxmLnNwbGljZShiLDEpKTtmb3IoYj0wO2I8ZztiKyspZFtiXSYmZFtiXS5maW5pc2gmJmRbYl0uZmluaXNoLmNhbGwodGhpcyk7ZGVsZXRlIGMuZmluaXNofSl9fSksci5lYWNoKFtcInRvZ2dsZVwiLFwic2hvd1wiLFwiaGlkZVwiXSxmdW5jdGlvbihhLGIpe3ZhciBjPXIuZm5bYl07ci5mbltiXT1mdW5jdGlvbihhLGQsZSl7cmV0dXJuIG51bGw9PWF8fFwiYm9vbGVhblwiPT10eXBlb2YgYT9jLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLmFuaW1hdGUoZGIoYiwhMCksYSxkLGUpfX0pLHIuZWFjaCh7c2xpZGVEb3duOmRiKFwic2hvd1wiKSxzbGlkZVVwOmRiKFwiaGlkZVwiKSxzbGlkZVRvZ2dsZTpkYihcInRvZ2dsZVwiKSxmYWRlSW46e29wYWNpdHk6XCJzaG93XCJ9LGZhZGVPdXQ6e29wYWNpdHk6XCJoaWRlXCJ9LGZhZGVUb2dnbGU6e29wYWNpdHk6XCJ0b2dnbGVcIn19LGZ1bmN0aW9uKGEsYil7ci5mblthXT1mdW5jdGlvbihhLGMsZCl7cmV0dXJuIHRoaXMuYW5pbWF0ZShiLGEsYyxkKX19KSxyLnRpbWVycz1bXSxyLmZ4LnRpY2s9ZnVuY3Rpb24oKXt2YXIgYSxiPTAsYz1yLnRpbWVycztmb3IoWmE9ci5ub3coKTtiPGMubGVuZ3RoO2IrKylhPWNbYl0sYSgpfHxjW2JdIT09YXx8Yy5zcGxpY2UoYi0tLDEpO2MubGVuZ3RofHxyLmZ4LnN0b3AoKSxaYT12b2lkIDB9LHIuZngudGltZXI9ZnVuY3Rpb24oYSl7ci50aW1lcnMucHVzaChhKSxhKCk/ci5meC5zdGFydCgpOnIudGltZXJzLnBvcCgpfSxyLmZ4LmludGVydmFsPTEzLHIuZnguc3RhcnQ9ZnVuY3Rpb24oKXskYXx8KCRhPWEucmVxdWVzdEFuaW1hdGlvbkZyYW1lP2EucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGJiKTphLnNldEludGVydmFsKHIuZngudGljayxyLmZ4LmludGVydmFsKSl9LHIuZnguc3RvcD1mdW5jdGlvbigpe2EuY2FuY2VsQW5pbWF0aW9uRnJhbWU/YS5jYW5jZWxBbmltYXRpb25GcmFtZSgkYSk6YS5jbGVhckludGVydmFsKCRhKSwkYT1udWxsfSxyLmZ4LnNwZWVkcz17c2xvdzo2MDAsZmFzdDoyMDAsX2RlZmF1bHQ6NDAwfSxyLmZuLmRlbGF5PWZ1bmN0aW9uKGIsYyl7cmV0dXJuIGI9ci5meD9yLmZ4LnNwZWVkc1tiXXx8YjpiLGM9Y3x8XCJmeFwiLHRoaXMucXVldWUoYyxmdW5jdGlvbihjLGQpe3ZhciBlPWEuc2V0VGltZW91dChjLGIpO2Quc3RvcD1mdW5jdGlvbigpe2EuY2xlYXJUaW1lb3V0KGUpfX0pfSxmdW5jdGlvbigpe3ZhciBhPWQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLGI9ZC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLGM9Yi5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpO2EudHlwZT1cImNoZWNrYm94XCIsby5jaGVja09uPVwiXCIhPT1hLnZhbHVlLG8ub3B0U2VsZWN0ZWQ9Yy5zZWxlY3RlZCxhPWQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLGEudmFsdWU9XCJ0XCIsYS50eXBlPVwicmFkaW9cIixvLnJhZGlvVmFsdWU9XCJ0XCI9PT1hLnZhbHVlfSgpO3ZhciBpYixqYj1yLmV4cHIuYXR0ckhhbmRsZTtyLmZuLmV4dGVuZCh7YXR0cjpmdW5jdGlvbihhLGIpe3JldHVybiBTKHRoaXMsci5hdHRyLGEsYixhcmd1bWVudHMubGVuZ3RoPjEpfSxyZW1vdmVBdHRyOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtyLnJlbW92ZUF0dHIodGhpcyxhKX0pfX0pLHIuZXh0ZW5kKHthdHRyOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGY9YS5ub2RlVHlwZTtpZigzIT09ZiYmOCE9PWYmJjIhPT1mKXJldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBhLmdldEF0dHJpYnV0ZT9yLnByb3AoYSxiLGMpOigxPT09ZiYmci5pc1hNTERvYyhhKXx8KGU9ci5hdHRySG9va3NbYi50b0xvd2VyQ2FzZSgpXXx8KHIuZXhwci5tYXRjaC5ib29sLnRlc3QoYik/aWI6dm9pZCAwKSksXG52b2lkIDAhPT1jP251bGw9PT1jP3ZvaWQgci5yZW1vdmVBdHRyKGEsYik6ZSYmXCJzZXRcImluIGUmJnZvaWQgMCE9PShkPWUuc2V0KGEsYyxiKSk/ZDooYS5zZXRBdHRyaWJ1dGUoYixjK1wiXCIpLGMpOmUmJlwiZ2V0XCJpbiBlJiZudWxsIT09KGQ9ZS5nZXQoYSxiKSk/ZDooZD1yLmZpbmQuYXR0cihhLGIpLG51bGw9PWQ/dm9pZCAwOmQpKX0sYXR0ckhvb2tzOnt0eXBlOntzZXQ6ZnVuY3Rpb24oYSxiKXtpZighby5yYWRpb1ZhbHVlJiZcInJhZGlvXCI9PT1iJiZyLm5vZGVOYW1lKGEsXCJpbnB1dFwiKSl7dmFyIGM9YS52YWx1ZTtyZXR1cm4gYS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsYiksYyYmKGEudmFsdWU9YyksYn19fX0scmVtb3ZlQXR0cjpmdW5jdGlvbihhLGIpe3ZhciBjLGQ9MCxlPWImJmIubWF0Y2goSyk7aWYoZSYmMT09PWEubm9kZVR5cGUpd2hpbGUoYz1lW2QrK10pYS5yZW1vdmVBdHRyaWJ1dGUoYyl9fSksaWI9e3NldDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGI9PT0hMT9yLnJlbW92ZUF0dHIoYSxjKTphLnNldEF0dHJpYnV0ZShjLGMpLGN9fSxyLmVhY2goci5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKC9cXHcrL2cpLGZ1bmN0aW9uKGEsYil7dmFyIGM9amJbYl18fHIuZmluZC5hdHRyO2piW2JdPWZ1bmN0aW9uKGEsYixkKXt2YXIgZSxmLGc9Yi50b0xvd2VyQ2FzZSgpO3JldHVybiBkfHwoZj1qYltnXSxqYltnXT1lLGU9bnVsbCE9YyhhLGIsZCk/ZzpudWxsLGpiW2ddPWYpLGV9fSk7dmFyIGtiPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksbGI9L14oPzphfGFyZWEpJC9pO3IuZm4uZXh0ZW5kKHtwcm9wOmZ1bmN0aW9uKGEsYil7cmV0dXJuIFModGhpcyxyLnByb3AsYSxiLGFyZ3VtZW50cy5sZW5ndGg+MSl9LHJlbW92ZVByb3A6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2RlbGV0ZSB0aGlzW3IucHJvcEZpeFthXXx8YV19KX19KSxyLmV4dGVuZCh7cHJvcDpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPWEubm9kZVR5cGU7aWYoMyE9PWYmJjghPT1mJiYyIT09ZilyZXR1cm4gMT09PWYmJnIuaXNYTUxEb2MoYSl8fChiPXIucHJvcEZpeFtiXXx8YixlPXIucHJvcEhvb2tzW2JdKSx2b2lkIDAhPT1jP2UmJlwic2V0XCJpbiBlJiZ2b2lkIDAhPT0oZD1lLnNldChhLGMsYikpP2Q6YVtiXT1jOmUmJlwiZ2V0XCJpbiBlJiZudWxsIT09KGQ9ZS5nZXQoYSxiKSk/ZDphW2JdfSxwcm9wSG9va3M6e3RhYkluZGV4OntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9ci5maW5kLmF0dHIoYSxcInRhYmluZGV4XCIpO3JldHVybiBiP3BhcnNlSW50KGIsMTApOmtiLnRlc3QoYS5ub2RlTmFtZSl8fGxiLnRlc3QoYS5ub2RlTmFtZSkmJmEuaHJlZj8wOi0xfX19LHByb3BGaXg6e1wiZm9yXCI6XCJodG1sRm9yXCIsXCJjbGFzc1wiOlwiY2xhc3NOYW1lXCJ9fSksby5vcHRTZWxlY3RlZHx8KHIucHJvcEhvb2tzLnNlbGVjdGVkPXtnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5wYXJlbnROb2RlO3JldHVybiBiJiZiLnBhcmVudE5vZGUmJmIucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LG51bGx9LHNldDpmdW5jdGlvbihhKXt2YXIgYj1hLnBhcmVudE5vZGU7YiYmKGIuc2VsZWN0ZWRJbmRleCxiLnBhcmVudE5vZGUmJmIucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4KX19KSxyLmVhY2goW1widGFiSW5kZXhcIixcInJlYWRPbmx5XCIsXCJtYXhMZW5ndGhcIixcImNlbGxTcGFjaW5nXCIsXCJjZWxsUGFkZGluZ1wiLFwicm93U3BhblwiLFwiY29sU3BhblwiLFwidXNlTWFwXCIsXCJmcmFtZUJvcmRlclwiLFwiY29udGVudEVkaXRhYmxlXCJdLGZ1bmN0aW9uKCl7ci5wcm9wRml4W3RoaXMudG9Mb3dlckNhc2UoKV09dGhpc30pO2Z1bmN0aW9uIG1iKGEpe3ZhciBiPWEubWF0Y2goSyl8fFtdO3JldHVybiBiLmpvaW4oXCIgXCIpfWZ1bmN0aW9uIG5iKGEpe3JldHVybiBhLmdldEF0dHJpYnV0ZSYmYS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKXx8XCJcIn1yLmZuLmV4dGVuZCh7YWRkQ2xhc3M6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGgsaT0wO2lmKHIuaXNGdW5jdGlvbihhKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGIpe3IodGhpcykuYWRkQ2xhc3MoYS5jYWxsKHRoaXMsYixuYih0aGlzKSkpfSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGEmJmEpe2I9YS5tYXRjaChLKXx8W107d2hpbGUoYz10aGlzW2krK10paWYoZT1uYihjKSxkPTE9PT1jLm5vZGVUeXBlJiZcIiBcIittYihlKStcIiBcIil7Zz0wO3doaWxlKGY9YltnKytdKWQuaW5kZXhPZihcIiBcIitmK1wiIFwiKTwwJiYoZCs9ZitcIiBcIik7aD1tYihkKSxlIT09aCYmYy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLGgpfX1yZXR1cm4gdGhpc30scmVtb3ZlQ2xhc3M6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGgsaT0wO2lmKHIuaXNGdW5jdGlvbihhKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGIpe3IodGhpcykucmVtb3ZlQ2xhc3MoYS5jYWxsKHRoaXMsYixuYih0aGlzKSkpfSk7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuYXR0cihcImNsYXNzXCIsXCJcIik7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGEmJmEpe2I9YS5tYXRjaChLKXx8W107d2hpbGUoYz10aGlzW2krK10paWYoZT1uYihjKSxkPTE9PT1jLm5vZGVUeXBlJiZcIiBcIittYihlKStcIiBcIil7Zz0wO3doaWxlKGY9YltnKytdKXdoaWxlKGQuaW5kZXhPZihcIiBcIitmK1wiIFwiKT4tMSlkPWQucmVwbGFjZShcIiBcIitmK1wiIFwiLFwiIFwiKTtoPW1iKGQpLGUhPT1oJiZjLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsaCl9fXJldHVybiB0aGlzfSx0b2dnbGVDbGFzczpmdW5jdGlvbihhLGIpe3ZhciBjPXR5cGVvZiBhO3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgYiYmXCJzdHJpbmdcIj09PWM/Yj90aGlzLmFkZENsYXNzKGEpOnRoaXMucmVtb3ZlQ2xhc3MoYSk6ci5pc0Z1bmN0aW9uKGEpP3RoaXMuZWFjaChmdW5jdGlvbihjKXtyKHRoaXMpLnRvZ2dsZUNsYXNzKGEuY2FsbCh0aGlzLGMsbmIodGhpcyksYiksYil9KTp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYixkLGUsZjtpZihcInN0cmluZ1wiPT09Yyl7ZD0wLGU9cih0aGlzKSxmPWEubWF0Y2goSyl8fFtdO3doaWxlKGI9ZltkKytdKWUuaGFzQ2xhc3MoYik/ZS5yZW1vdmVDbGFzcyhiKTplLmFkZENsYXNzKGIpfWVsc2Ugdm9pZCAwIT09YSYmXCJib29sZWFuXCIhPT1jfHwoYj1uYih0aGlzKSxiJiZWLnNldCh0aGlzLFwiX19jbGFzc05hbWVfX1wiLGIpLHRoaXMuc2V0QXR0cmlidXRlJiZ0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsYnx8YT09PSExP1wiXCI6Vi5nZXQodGhpcyxcIl9fY2xhc3NOYW1lX19cIil8fFwiXCIpKX0pfSxoYXNDbGFzczpmdW5jdGlvbihhKXt2YXIgYixjLGQ9MDtiPVwiIFwiK2ErXCIgXCI7d2hpbGUoYz10aGlzW2QrK10paWYoMT09PWMubm9kZVR5cGUmJihcIiBcIittYihuYihjKSkrXCIgXCIpLmluZGV4T2YoYik+LTEpcmV0dXJuITA7cmV0dXJuITF9fSk7dmFyIG9iPS9cXHIvZztyLmZuLmV4dGVuZCh7dmFsOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlPXRoaXNbMF07e2lmKGFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGQ9ci5pc0Z1bmN0aW9uKGEpLHRoaXMuZWFjaChmdW5jdGlvbihjKXt2YXIgZTsxPT09dGhpcy5ub2RlVHlwZSYmKGU9ZD9hLmNhbGwodGhpcyxjLHIodGhpcykudmFsKCkpOmEsbnVsbD09ZT9lPVwiXCI6XCJudW1iZXJcIj09dHlwZW9mIGU/ZSs9XCJcIjpyLmlzQXJyYXkoZSkmJihlPXIubWFwKGUsZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/XCJcIjphK1wiXCJ9KSksYj1yLnZhbEhvb2tzW3RoaXMudHlwZV18fHIudmFsSG9va3NbdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSxiJiZcInNldFwiaW4gYiYmdm9pZCAwIT09Yi5zZXQodGhpcyxlLFwidmFsdWVcIil8fCh0aGlzLnZhbHVlPWUpKX0pO2lmKGUpcmV0dXJuIGI9ci52YWxIb29rc1tlLnR5cGVdfHxyLnZhbEhvb2tzW2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sYiYmXCJnZXRcImluIGImJnZvaWQgMCE9PShjPWIuZ2V0KGUsXCJ2YWx1ZVwiKSk/YzooYz1lLnZhbHVlLFwic3RyaW5nXCI9PXR5cGVvZiBjP2MucmVwbGFjZShvYixcIlwiKTpudWxsPT1jP1wiXCI6Yyl9fX0pLHIuZXh0ZW5kKHt2YWxIb29rczp7b3B0aW9uOntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9ci5maW5kLmF0dHIoYSxcInZhbHVlXCIpO3JldHVybiBudWxsIT1iP2I6bWIoci50ZXh0KGEpKX19LHNlbGVjdDp7Z2V0OmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlPWEub3B0aW9ucyxmPWEuc2VsZWN0ZWRJbmRleCxnPVwic2VsZWN0LW9uZVwiPT09YS50eXBlLGg9Zz9udWxsOltdLGk9Zz9mKzE6ZS5sZW5ndGg7Zm9yKGQ9ZjwwP2k6Zz9mOjA7ZDxpO2QrKylpZihjPWVbZF0sKGMuc2VsZWN0ZWR8fGQ9PT1mKSYmIWMuZGlzYWJsZWQmJighYy5wYXJlbnROb2RlLmRpc2FibGVkfHwhci5ub2RlTmFtZShjLnBhcmVudE5vZGUsXCJvcHRncm91cFwiKSkpe2lmKGI9cihjKS52YWwoKSxnKXJldHVybiBiO2gucHVzaChiKX1yZXR1cm4gaH0sc2V0OmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlPWEub3B0aW9ucyxmPXIubWFrZUFycmF5KGIpLGc9ZS5sZW5ndGg7d2hpbGUoZy0tKWQ9ZVtnXSwoZC5zZWxlY3RlZD1yLmluQXJyYXkoci52YWxIb29rcy5vcHRpb24uZ2V0KGQpLGYpPi0xKSYmKGM9ITApO3JldHVybiBjfHwoYS5zZWxlY3RlZEluZGV4PS0xKSxmfX19fSksci5lYWNoKFtcInJhZGlvXCIsXCJjaGVja2JveFwiXSxmdW5jdGlvbigpe3IudmFsSG9va3NbdGhpc109e3NldDpmdW5jdGlvbihhLGIpe2lmKHIuaXNBcnJheShiKSlyZXR1cm4gYS5jaGVja2VkPXIuaW5BcnJheShyKGEpLnZhbCgpLGIpPi0xfX0sby5jaGVja09ufHwoci52YWxIb29rc1t0aGlzXS5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PT1hLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpP1wib25cIjphLnZhbHVlfSl9KTt2YXIgcGI9L14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO3IuZXh0ZW5kKHIuZXZlbnQse3RyaWdnZXI6ZnVuY3Rpb24oYixjLGUsZil7dmFyIGcsaCxpLGosayxtLG4sbz1bZXx8ZF0scD1sLmNhbGwoYixcInR5cGVcIik/Yi50eXBlOmIscT1sLmNhbGwoYixcIm5hbWVzcGFjZVwiKT9iLm5hbWVzcGFjZS5zcGxpdChcIi5cIik6W107aWYoaD1pPWU9ZXx8ZCwzIT09ZS5ub2RlVHlwZSYmOCE9PWUubm9kZVR5cGUmJiFwYi50ZXN0KHArci5ldmVudC50cmlnZ2VyZWQpJiYocC5pbmRleE9mKFwiLlwiKT4tMSYmKHE9cC5zcGxpdChcIi5cIikscD1xLnNoaWZ0KCkscS5zb3J0KCkpLGs9cC5pbmRleE9mKFwiOlwiKTwwJiZcIm9uXCIrcCxiPWJbci5leHBhbmRvXT9iOm5ldyByLkV2ZW50KHAsXCJvYmplY3RcIj09dHlwZW9mIGImJmIpLGIuaXNUcmlnZ2VyPWY/MjozLGIubmFtZXNwYWNlPXEuam9pbihcIi5cIiksYi5ybmFtZXNwYWNlPWIubmFtZXNwYWNlP25ldyBSZWdFeHAoXCIoXnxcXFxcLilcIitxLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKTpudWxsLGIucmVzdWx0PXZvaWQgMCxiLnRhcmdldHx8KGIudGFyZ2V0PWUpLGM9bnVsbD09Yz9bYl06ci5tYWtlQXJyYXkoYyxbYl0pLG49ci5ldmVudC5zcGVjaWFsW3BdfHx7fSxmfHwhbi50cmlnZ2VyfHxuLnRyaWdnZXIuYXBwbHkoZSxjKSE9PSExKSl7aWYoIWYmJiFuLm5vQnViYmxlJiYhci5pc1dpbmRvdyhlKSl7Zm9yKGo9bi5kZWxlZ2F0ZVR5cGV8fHAscGIudGVzdChqK3ApfHwoaD1oLnBhcmVudE5vZGUpO2g7aD1oLnBhcmVudE5vZGUpby5wdXNoKGgpLGk9aDtpPT09KGUub3duZXJEb2N1bWVudHx8ZCkmJm8ucHVzaChpLmRlZmF1bHRWaWV3fHxpLnBhcmVudFdpbmRvd3x8YSl9Zz0wO3doaWxlKChoPW9bZysrXSkmJiFiLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpYi50eXBlPWc+MT9qOm4uYmluZFR5cGV8fHAsbT0oVi5nZXQoaCxcImV2ZW50c1wiKXx8e30pW2IudHlwZV0mJlYuZ2V0KGgsXCJoYW5kbGVcIiksbSYmbS5hcHBseShoLGMpLG09ayYmaFtrXSxtJiZtLmFwcGx5JiZUKGgpJiYoYi5yZXN1bHQ9bS5hcHBseShoLGMpLGIucmVzdWx0PT09ITEmJmIucHJldmVudERlZmF1bHQoKSk7cmV0dXJuIGIudHlwZT1wLGZ8fGIuaXNEZWZhdWx0UHJldmVudGVkKCl8fG4uX2RlZmF1bHQmJm4uX2RlZmF1bHQuYXBwbHkoby5wb3AoKSxjKSE9PSExfHwhVChlKXx8ayYmci5pc0Z1bmN0aW9uKGVbcF0pJiYhci5pc1dpbmRvdyhlKSYmKGk9ZVtrXSxpJiYoZVtrXT1udWxsKSxyLmV2ZW50LnRyaWdnZXJlZD1wLGVbcF0oKSxyLmV2ZW50LnRyaWdnZXJlZD12b2lkIDAsaSYmKGVba109aSkpLGIucmVzdWx0fX0sc2ltdWxhdGU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXIuZXh0ZW5kKG5ldyByLkV2ZW50LGMse3R5cGU6YSxpc1NpbXVsYXRlZDohMH0pO3IuZXZlbnQudHJpZ2dlcihkLG51bGwsYil9fSksci5mbi5leHRlbmQoe3RyaWdnZXI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7ci5ldmVudC50cmlnZ2VyKGEsYix0aGlzKX0pfSx0cmlnZ2VySGFuZGxlcjpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXNbMF07aWYoYylyZXR1cm4gci5ldmVudC50cmlnZ2VyKGEsYixjLCEwKX19KSxyLmVhY2goXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGEsYil7ci5mbltiXT1mdW5jdGlvbihhLGMpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPjA/dGhpcy5vbihiLG51bGwsYSxjKTp0aGlzLnRyaWdnZXIoYil9fSksci5mbi5leHRlbmQoe2hvdmVyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMubW91c2VlbnRlcihhKS5tb3VzZWxlYXZlKGJ8fGEpfX0pLG8uZm9jdXNpbj1cIm9uZm9jdXNpblwiaW4gYSxvLmZvY3VzaW58fHIuZWFjaCh7Zm9jdXM6XCJmb2N1c2luXCIsYmx1cjpcImZvY3Vzb3V0XCJ9LGZ1bmN0aW9uKGEsYil7dmFyIGM9ZnVuY3Rpb24oYSl7ci5ldmVudC5zaW11bGF0ZShiLGEudGFyZ2V0LHIuZXZlbnQuZml4KGEpKX07ci5ldmVudC5zcGVjaWFsW2JdPXtzZXR1cDpmdW5jdGlvbigpe3ZhciBkPXRoaXMub3duZXJEb2N1bWVudHx8dGhpcyxlPVYuYWNjZXNzKGQsYik7ZXx8ZC5hZGRFdmVudExpc3RlbmVyKGEsYywhMCksVi5hY2Nlc3MoZCxiLChlfHwwKSsxKX0sdGVhcmRvd246ZnVuY3Rpb24oKXt2YXIgZD10aGlzLm93bmVyRG9jdW1lbnR8fHRoaXMsZT1WLmFjY2VzcyhkLGIpLTE7ZT9WLmFjY2VzcyhkLGIsZSk6KGQucmVtb3ZlRXZlbnRMaXN0ZW5lcihhLGMsITApLFYucmVtb3ZlKGQsYikpfX19KTt2YXIgcWI9YS5sb2NhdGlvbixyYj1yLm5vdygpLHNiPS9cXD8vO3IucGFyc2VYTUw9ZnVuY3Rpb24oYil7dmFyIGM7aWYoIWJ8fFwic3RyaW5nXCIhPXR5cGVvZiBiKXJldHVybiBudWxsO3RyeXtjPShuZXcgYS5ET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZyhiLFwidGV4dC94bWxcIil9Y2F0Y2goZCl7Yz12b2lkIDB9cmV0dXJuIGMmJiFjLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIikubGVuZ3RofHxyLmVycm9yKFwiSW52YWxpZCBYTUw6IFwiK2IpLGN9O3ZhciB0Yj0vXFxbXFxdJC8sdWI9L1xccj9cXG4vZyx2Yj0vXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksd2I9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO2Z1bmN0aW9uIHhiKGEsYixjLGQpe3ZhciBlO2lmKHIuaXNBcnJheShiKSlyLmVhY2goYixmdW5jdGlvbihiLGUpe2N8fHRiLnRlc3QoYSk/ZChhLGUpOnhiKGErXCJbXCIrKFwib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT1lP2I6XCJcIikrXCJdXCIsZSxjLGQpfSk7ZWxzZSBpZihjfHxcIm9iamVjdFwiIT09ci50eXBlKGIpKWQoYSxiKTtlbHNlIGZvcihlIGluIGIpeGIoYStcIltcIitlK1wiXVwiLGJbZV0sYyxkKX1yLnBhcmFtPWZ1bmN0aW9uKGEsYil7dmFyIGMsZD1bXSxlPWZ1bmN0aW9uKGEsYil7dmFyIGM9ci5pc0Z1bmN0aW9uKGIpP2IoKTpiO2RbZC5sZW5ndGhdPWVuY29kZVVSSUNvbXBvbmVudChhKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQobnVsbD09Yz9cIlwiOmMpfTtpZihyLmlzQXJyYXkoYSl8fGEuanF1ZXJ5JiYhci5pc1BsYWluT2JqZWN0KGEpKXIuZWFjaChhLGZ1bmN0aW9uKCl7ZSh0aGlzLm5hbWUsdGhpcy52YWx1ZSl9KTtlbHNlIGZvcihjIGluIGEpeGIoYyxhW2NdLGIsZSk7cmV0dXJuIGQuam9pbihcIiZcIil9LHIuZm4uZXh0ZW5kKHtzZXJpYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gci5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpfSxzZXJpYWxpemVBcnJheTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBhPXIucHJvcCh0aGlzLFwiZWxlbWVudHNcIik7cmV0dXJuIGE/ci5tYWtlQXJyYXkoYSk6dGhpc30pLmZpbHRlcihmdW5jdGlvbigpe3ZhciBhPXRoaXMudHlwZTtyZXR1cm4gdGhpcy5uYW1lJiYhcih0aGlzKS5pcyhcIjpkaXNhYmxlZFwiKSYmd2IudGVzdCh0aGlzLm5vZGVOYW1lKSYmIXZiLnRlc3QoYSkmJih0aGlzLmNoZWNrZWR8fCFpYS50ZXN0KGEpKX0pLm1hcChmdW5jdGlvbihhLGIpe3ZhciBjPXIodGhpcykudmFsKCk7cmV0dXJuIG51bGw9PWM/bnVsbDpyLmlzQXJyYXkoYyk/ci5tYXAoYyxmdW5jdGlvbihhKXtyZXR1cm57bmFtZTpiLm5hbWUsdmFsdWU6YS5yZXBsYWNlKHViLFwiXFxyXFxuXCIpfX0pOntuYW1lOmIubmFtZSx2YWx1ZTpjLnJlcGxhY2UodWIsXCJcXHJcXG5cIil9fSkuZ2V0KCl9fSk7dmFyIHliPS8lMjAvZyx6Yj0vIy4qJC8sQWI9LyhbPyZdKV89W14mXSovLEJiPS9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvZ20sQ2I9L14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sRGI9L14oPzpHRVR8SEVBRCkkLyxFYj0vXlxcL1xcLy8sRmI9e30sR2I9e30sSGI9XCIqL1wiLmNvbmNhdChcIipcIiksSWI9ZC5jcmVhdGVFbGVtZW50KFwiYVwiKTtJYi5ocmVmPXFiLmhyZWY7ZnVuY3Rpb24gSmIoYSl7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7XCJzdHJpbmdcIiE9dHlwZW9mIGImJihjPWIsYj1cIipcIik7dmFyIGQsZT0wLGY9Yi50b0xvd2VyQ2FzZSgpLm1hdGNoKEspfHxbXTtpZihyLmlzRnVuY3Rpb24oYykpd2hpbGUoZD1mW2UrK10pXCIrXCI9PT1kWzBdPyhkPWQuc2xpY2UoMSl8fFwiKlwiLChhW2RdPWFbZF18fFtdKS51bnNoaWZ0KGMpKTooYVtkXT1hW2RdfHxbXSkucHVzaChjKX19ZnVuY3Rpb24gS2IoYSxiLGMsZCl7dmFyIGU9e30sZj1hPT09R2I7ZnVuY3Rpb24gZyhoKXt2YXIgaTtyZXR1cm4gZVtoXT0hMCxyLmVhY2goYVtoXXx8W10sZnVuY3Rpb24oYSxoKXt2YXIgaj1oKGIsYyxkKTtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2Yganx8Znx8ZVtqXT9mPyEoaT1qKTp2b2lkIDA6KGIuZGF0YVR5cGVzLnVuc2hpZnQoaiksZyhqKSwhMSl9KSxpfXJldHVybiBnKGIuZGF0YVR5cGVzWzBdKXx8IWVbXCIqXCJdJiZnKFwiKlwiKX1mdW5jdGlvbiBMYihhLGIpe3ZhciBjLGQsZT1yLmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9uc3x8e307Zm9yKGMgaW4gYil2b2lkIDAhPT1iW2NdJiYoKGVbY10/YTpkfHwoZD17fSkpW2NdPWJbY10pO3JldHVybiBkJiZyLmV4dGVuZCghMCxhLGQpLGF9ZnVuY3Rpb24gTWIoYSxiLGMpe3ZhciBkLGUsZixnLGg9YS5jb250ZW50cyxpPWEuZGF0YVR5cGVzO3doaWxlKFwiKlwiPT09aVswXSlpLnNoaWZ0KCksdm9pZCAwPT09ZCYmKGQ9YS5taW1lVHlwZXx8Yi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSk7aWYoZClmb3IoZSBpbiBoKWlmKGhbZV0mJmhbZV0udGVzdChkKSl7aS51bnNoaWZ0KGUpO2JyZWFrfWlmKGlbMF1pbiBjKWY9aVswXTtlbHNle2ZvcihlIGluIGMpe2lmKCFpWzBdfHxhLmNvbnZlcnRlcnNbZStcIiBcIitpWzBdXSl7Zj1lO2JyZWFrfWd8fChnPWUpfWY9Znx8Z31pZihmKXJldHVybiBmIT09aVswXSYmaS51bnNoaWZ0KGYpLGNbZl19ZnVuY3Rpb24gTmIoYSxiLGMsZCl7dmFyIGUsZixnLGgsaSxqPXt9LGs9YS5kYXRhVHlwZXMuc2xpY2UoKTtpZihrWzFdKWZvcihnIGluIGEuY29udmVydGVycylqW2cudG9Mb3dlckNhc2UoKV09YS5jb252ZXJ0ZXJzW2ddO2Y9ay5zaGlmdCgpO3doaWxlKGYpaWYoYS5yZXNwb25zZUZpZWxkc1tmXSYmKGNbYS5yZXNwb25zZUZpZWxkc1tmXV09YiksIWkmJmQmJmEuZGF0YUZpbHRlciYmKGI9YS5kYXRhRmlsdGVyKGIsYS5kYXRhVHlwZSkpLGk9ZixmPWsuc2hpZnQoKSlpZihcIipcIj09PWYpZj1pO2Vsc2UgaWYoXCIqXCIhPT1pJiZpIT09Zil7aWYoZz1qW2krXCIgXCIrZl18fGpbXCIqIFwiK2ZdLCFnKWZvcihlIGluIGopaWYoaD1lLnNwbGl0KFwiIFwiKSxoWzFdPT09ZiYmKGc9altpK1wiIFwiK2hbMF1dfHxqW1wiKiBcIitoWzBdXSkpe2c9PT0hMD9nPWpbZV06altlXSE9PSEwJiYoZj1oWzBdLGsudW5zaGlmdChoWzFdKSk7YnJlYWt9aWYoZyE9PSEwKWlmKGcmJmFbXCJ0aHJvd3NcIl0pYj1nKGIpO2Vsc2UgdHJ5e2I9ZyhiKX1jYXRjaChsKXtyZXR1cm57c3RhdGU6XCJwYXJzZXJlcnJvclwiLGVycm9yOmc/bDpcIk5vIGNvbnZlcnNpb24gZnJvbSBcIitpK1wiIHRvIFwiK2Z9fX1yZXR1cm57c3RhdGU6XCJzdWNjZXNzXCIsZGF0YTpifX1yLmV4dGVuZCh7YWN0aXZlOjAsbGFzdE1vZGlmaWVkOnt9LGV0YWc6e30sYWpheFNldHRpbmdzOnt1cmw6cWIuaHJlZix0eXBlOlwiR0VUXCIsaXNMb2NhbDpDYi50ZXN0KHFiLnByb3RvY29sKSxnbG9iYWw6ITAscHJvY2Vzc0RhdGE6ITAsYXN5bmM6ITAsY29udGVudFR5cGU6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixhY2NlcHRzOntcIipcIjpIYix0ZXh0OlwidGV4dC9wbGFpblwiLGh0bWw6XCJ0ZXh0L2h0bWxcIix4bWw6XCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsanNvbjpcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwifSxjb250ZW50czp7eG1sOi9cXGJ4bWxcXGIvLGh0bWw6L1xcYmh0bWwvLGpzb246L1xcYmpzb25cXGIvfSxyZXNwb25zZUZpZWxkczp7eG1sOlwicmVzcG9uc2VYTUxcIix0ZXh0OlwicmVzcG9uc2VUZXh0XCIsanNvbjpcInJlc3BvbnNlSlNPTlwifSxjb252ZXJ0ZXJzOntcIiogdGV4dFwiOlN0cmluZyxcInRleHQgaHRtbFwiOiEwLFwidGV4dCBqc29uXCI6SlNPTi5wYXJzZSxcInRleHQgeG1sXCI6ci5wYXJzZVhNTH0sZmxhdE9wdGlvbnM6e3VybDohMCxjb250ZXh0OiEwfX0sYWpheFNldHVwOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGI/TGIoTGIoYSxyLmFqYXhTZXR0aW5ncyksYik6TGIoci5hamF4U2V0dGluZ3MsYSl9LGFqYXhQcmVmaWx0ZXI6SmIoRmIpLGFqYXhUcmFuc3BvcnQ6SmIoR2IpLGFqYXg6ZnVuY3Rpb24oYixjKXtcIm9iamVjdFwiPT10eXBlb2YgYiYmKGM9YixiPXZvaWQgMCksYz1jfHx7fTt2YXIgZSxmLGcsaCxpLGosayxsLG0sbixvPXIuYWpheFNldHVwKHt9LGMpLHA9by5jb250ZXh0fHxvLHE9by5jb250ZXh0JiYocC5ub2RlVHlwZXx8cC5qcXVlcnkpP3IocCk6ci5ldmVudCxzPXIuRGVmZXJyZWQoKSx0PXIuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksdT1vLnN0YXR1c0NvZGV8fHt9LHY9e30sdz17fSx4PVwiY2FuY2VsZWRcIix5PXtyZWFkeVN0YXRlOjAsZ2V0UmVzcG9uc2VIZWFkZXI6ZnVuY3Rpb24oYSl7dmFyIGI7aWYoayl7aWYoIWgpe2g9e307d2hpbGUoYj1CYi5leGVjKGcpKWhbYlsxXS50b0xvd2VyQ2FzZSgpXT1iWzJdfWI9aFthLnRvTG93ZXJDYXNlKCldfXJldHVybiBudWxsPT1iP251bGw6Yn0sZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOmZ1bmN0aW9uKCl7cmV0dXJuIGs/ZzpudWxsfSxzZXRSZXF1ZXN0SGVhZGVyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGw9PWsmJihhPXdbYS50b0xvd2VyQ2FzZSgpXT13W2EudG9Mb3dlckNhc2UoKV18fGEsdlthXT1iKSx0aGlzfSxvdmVycmlkZU1pbWVUeXBlOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1rJiYoby5taW1lVHlwZT1hKSx0aGlzfSxzdGF0dXNDb2RlOmZ1bmN0aW9uKGEpe3ZhciBiO2lmKGEpaWYoayl5LmFsd2F5cyhhW3kuc3RhdHVzXSk7ZWxzZSBmb3IoYiBpbiBhKXVbYl09W3VbYl0sYVtiXV07cmV0dXJuIHRoaXN9LGFib3J0OmZ1bmN0aW9uKGEpe3ZhciBiPWF8fHg7cmV0dXJuIGUmJmUuYWJvcnQoYiksQSgwLGIpLHRoaXN9fTtpZihzLnByb21pc2UoeSksby51cmw9KChifHxvLnVybHx8cWIuaHJlZikrXCJcIikucmVwbGFjZShFYixxYi5wcm90b2NvbCtcIi8vXCIpLG8udHlwZT1jLm1ldGhvZHx8Yy50eXBlfHxvLm1ldGhvZHx8by50eXBlLG8uZGF0YVR5cGVzPShvLmRhdGFUeXBlfHxcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChLKXx8W1wiXCJdLG51bGw9PW8uY3Jvc3NEb21haW4pe2o9ZC5jcmVhdGVFbGVtZW50KFwiYVwiKTt0cnl7ai5ocmVmPW8udXJsLGouaHJlZj1qLmhyZWYsby5jcm9zc0RvbWFpbj1JYi5wcm90b2NvbCtcIi8vXCIrSWIuaG9zdCE9ai5wcm90b2NvbCtcIi8vXCIrai5ob3N0fWNhdGNoKHope28uY3Jvc3NEb21haW49ITB9fWlmKG8uZGF0YSYmby5wcm9jZXNzRGF0YSYmXCJzdHJpbmdcIiE9dHlwZW9mIG8uZGF0YSYmKG8uZGF0YT1yLnBhcmFtKG8uZGF0YSxvLnRyYWRpdGlvbmFsKSksS2IoRmIsbyxjLHkpLGspcmV0dXJuIHk7bD1yLmV2ZW50JiZvLmdsb2JhbCxsJiYwPT09ci5hY3RpdmUrKyYmci5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpLG8udHlwZT1vLnR5cGUudG9VcHBlckNhc2UoKSxvLmhhc0NvbnRlbnQ9IURiLnRlc3Qoby50eXBlKSxmPW8udXJsLnJlcGxhY2UoemIsXCJcIiksby5oYXNDb250ZW50P28uZGF0YSYmby5wcm9jZXNzRGF0YSYmMD09PShvLmNvbnRlbnRUeXBlfHxcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpJiYoby5kYXRhPW8uZGF0YS5yZXBsYWNlKHliLFwiK1wiKSk6KG49by51cmwuc2xpY2UoZi5sZW5ndGgpLG8uZGF0YSYmKGYrPShzYi50ZXN0KGYpP1wiJlwiOlwiP1wiKStvLmRhdGEsZGVsZXRlIG8uZGF0YSksby5jYWNoZT09PSExJiYoZj1mLnJlcGxhY2UoQWIsXCIkMVwiKSxuPShzYi50ZXN0KGYpP1wiJlwiOlwiP1wiKStcIl89XCIrcmIrKyArbiksby51cmw9ZituKSxvLmlmTW9kaWZpZWQmJihyLmxhc3RNb2RpZmllZFtmXSYmeS5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIixyLmxhc3RNb2RpZmllZFtmXSksci5ldGFnW2ZdJiZ5LnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Ob25lLU1hdGNoXCIsci5ldGFnW2ZdKSksKG8uZGF0YSYmby5oYXNDb250ZW50JiZvLmNvbnRlbnRUeXBlIT09ITF8fGMuY29udGVudFR5cGUpJiZ5LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIixvLmNvbnRlbnRUeXBlKSx5LnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIixvLmRhdGFUeXBlc1swXSYmby5hY2NlcHRzW28uZGF0YVR5cGVzWzBdXT9vLmFjY2VwdHNbby5kYXRhVHlwZXNbMF1dKyhcIipcIiE9PW8uZGF0YVR5cGVzWzBdP1wiLCBcIitIYitcIjsgcT0wLjAxXCI6XCJcIik6by5hY2NlcHRzW1wiKlwiXSk7Zm9yKG0gaW4gby5oZWFkZXJzKXkuc2V0UmVxdWVzdEhlYWRlcihtLG8uaGVhZGVyc1ttXSk7aWYoby5iZWZvcmVTZW5kJiYoby5iZWZvcmVTZW5kLmNhbGwocCx5LG8pPT09ITF8fGspKXJldHVybiB5LmFib3J0KCk7aWYoeD1cImFib3J0XCIsdC5hZGQoby5jb21wbGV0ZSkseS5kb25lKG8uc3VjY2VzcykseS5mYWlsKG8uZXJyb3IpLGU9S2IoR2IsbyxjLHkpKXtpZih5LnJlYWR5U3RhdGU9MSxsJiZxLnRyaWdnZXIoXCJhamF4U2VuZFwiLFt5LG9dKSxrKXJldHVybiB5O28uYXN5bmMmJm8udGltZW91dD4wJiYoaT1hLnNldFRpbWVvdXQoZnVuY3Rpb24oKXt5LmFib3J0KFwidGltZW91dFwiKX0sby50aW1lb3V0KSk7dHJ5e2s9ITEsZS5zZW5kKHYsQSl9Y2F0Y2goeil7aWYoayl0aHJvdyB6O0EoLTEseil9fWVsc2UgQSgtMSxcIk5vIFRyYW5zcG9ydFwiKTtmdW5jdGlvbiBBKGIsYyxkLGgpe3ZhciBqLG0sbix2LHcseD1jO2t8fChrPSEwLGkmJmEuY2xlYXJUaW1lb3V0KGkpLGU9dm9pZCAwLGc9aHx8XCJcIix5LnJlYWR5U3RhdGU9Yj4wPzQ6MCxqPWI+PTIwMCYmYjwzMDB8fDMwND09PWIsZCYmKHY9TWIobyx5LGQpKSx2PU5iKG8sdix5LGopLGo/KG8uaWZNb2RpZmllZCYmKHc9eS5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIiksdyYmKHIubGFzdE1vZGlmaWVkW2ZdPXcpLHc9eS5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIiksdyYmKHIuZXRhZ1tmXT13KSksMjA0PT09Ynx8XCJIRUFEXCI9PT1vLnR5cGU/eD1cIm5vY29udGVudFwiOjMwND09PWI/eD1cIm5vdG1vZGlmaWVkXCI6KHg9di5zdGF0ZSxtPXYuZGF0YSxuPXYuZXJyb3Isaj0hbikpOihuPXgsIWImJnh8fCh4PVwiZXJyb3JcIixiPDAmJihiPTApKSkseS5zdGF0dXM9Yix5LnN0YXR1c1RleHQ9KGN8fHgpK1wiXCIsaj9zLnJlc29sdmVXaXRoKHAsW20seCx5XSk6cy5yZWplY3RXaXRoKHAsW3kseCxuXSkseS5zdGF0dXNDb2RlKHUpLHU9dm9pZCAwLGwmJnEudHJpZ2dlcihqP1wiYWpheFN1Y2Nlc3NcIjpcImFqYXhFcnJvclwiLFt5LG8saj9tOm5dKSx0LmZpcmVXaXRoKHAsW3kseF0pLGwmJihxLnRyaWdnZXIoXCJhamF4Q29tcGxldGVcIixbeSxvXSksLS1yLmFjdGl2ZXx8ci5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIikpKX1yZXR1cm4geX0sZ2V0SlNPTjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHIuZ2V0KGEsYixjLFwianNvblwiKX0sZ2V0U2NyaXB0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIHIuZ2V0KGEsdm9pZCAwLGIsXCJzY3JpcHRcIil9fSksci5lYWNoKFtcImdldFwiLFwicG9zdFwiXSxmdW5jdGlvbihhLGIpe3JbYl09ZnVuY3Rpb24oYSxjLGQsZSl7cmV0dXJuIHIuaXNGdW5jdGlvbihjKSYmKGU9ZXx8ZCxkPWMsYz12b2lkIDApLHIuYWpheChyLmV4dGVuZCh7dXJsOmEsdHlwZTpiLGRhdGFUeXBlOmUsZGF0YTpjLHN1Y2Nlc3M6ZH0sci5pc1BsYWluT2JqZWN0KGEpJiZhKSl9fSksci5fZXZhbFVybD1mdW5jdGlvbihhKXtyZXR1cm4gci5hamF4KHt1cmw6YSx0eXBlOlwiR0VUXCIsZGF0YVR5cGU6XCJzY3JpcHRcIixjYWNoZTohMCxhc3luYzohMSxnbG9iYWw6ITEsXCJ0aHJvd3NcIjohMH0pfSxyLmZuLmV4dGVuZCh7d3JhcEFsbDpmdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gdGhpc1swXSYmKHIuaXNGdW5jdGlvbihhKSYmKGE9YS5jYWxsKHRoaXNbMF0pKSxiPXIoYSx0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKSx0aGlzWzBdLnBhcmVudE5vZGUmJmIuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLGIubWFwKGZ1bmN0aW9uKCl7dmFyIGE9dGhpczt3aGlsZShhLmZpcnN0RWxlbWVudENoaWxkKWE9YS5maXJzdEVsZW1lbnRDaGlsZDtyZXR1cm4gYX0pLmFwcGVuZCh0aGlzKSksdGhpc30sd3JhcElubmVyOmZ1bmN0aW9uKGEpe3JldHVybiByLmlzRnVuY3Rpb24oYSk/dGhpcy5lYWNoKGZ1bmN0aW9uKGIpe3IodGhpcykud3JhcElubmVyKGEuY2FsbCh0aGlzLGIpKX0pOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPXIodGhpcyksYz1iLmNvbnRlbnRzKCk7Yy5sZW5ndGg/Yy53cmFwQWxsKGEpOmIuYXBwZW5kKGEpfSl9LHdyYXA6ZnVuY3Rpb24oYSl7dmFyIGI9ci5pc0Z1bmN0aW9uKGEpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oYyl7cih0aGlzKS53cmFwQWxsKGI/YS5jYWxsKHRoaXMsYyk6YSl9KX0sdW53cmFwOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnBhcmVudChhKS5ub3QoXCJib2R5XCIpLmVhY2goZnVuY3Rpb24oKXtyKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyl9KSx0aGlzfX0pLHIuZXhwci5wc2V1ZG9zLmhpZGRlbj1mdW5jdGlvbihhKXtyZXR1cm4hci5leHByLnBzZXVkb3MudmlzaWJsZShhKX0sci5leHByLnBzZXVkb3MudmlzaWJsZT1mdW5jdGlvbihhKXtyZXR1cm4hIShhLm9mZnNldFdpZHRofHxhLm9mZnNldEhlaWdodHx8YS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCl9LHIuYWpheFNldHRpbmdzLnhocj1mdW5jdGlvbigpe3RyeXtyZXR1cm4gbmV3IGEuWE1MSHR0cFJlcXVlc3R9Y2F0Y2goYil7fX07dmFyIE9iPXswOjIwMCwxMjIzOjIwNH0sUGI9ci5hamF4U2V0dGluZ3MueGhyKCk7by5jb3JzPSEhUGImJlwid2l0aENyZWRlbnRpYWxzXCJpbiBQYixvLmFqYXg9UGI9ISFQYixyLmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24oYil7dmFyIGMsZDtpZihvLmNvcnN8fFBiJiYhYi5jcm9zc0RvbWFpbilyZXR1cm57c2VuZDpmdW5jdGlvbihlLGYpe3ZhciBnLGg9Yi54aHIoKTtpZihoLm9wZW4oYi50eXBlLGIudXJsLGIuYXN5bmMsYi51c2VybmFtZSxiLnBhc3N3b3JkKSxiLnhockZpZWxkcylmb3IoZyBpbiBiLnhockZpZWxkcyloW2ddPWIueGhyRmllbGRzW2ddO2IubWltZVR5cGUmJmgub3ZlcnJpZGVNaW1lVHlwZSYmaC5vdmVycmlkZU1pbWVUeXBlKGIubWltZVR5cGUpLGIuY3Jvc3NEb21haW58fGVbXCJYLVJlcXVlc3RlZC1XaXRoXCJdfHwoZVtcIlgtUmVxdWVzdGVkLVdpdGhcIl09XCJYTUxIdHRwUmVxdWVzdFwiKTtmb3IoZyBpbiBlKWguc2V0UmVxdWVzdEhlYWRlcihnLGVbZ10pO2M9ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKCl7YyYmKGM9ZD1oLm9ubG9hZD1oLm9uZXJyb3I9aC5vbmFib3J0PWgub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsXCJhYm9ydFwiPT09YT9oLmFib3J0KCk6XCJlcnJvclwiPT09YT9cIm51bWJlclwiIT10eXBlb2YgaC5zdGF0dXM/ZigwLFwiZXJyb3JcIik6ZihoLnN0YXR1cyxoLnN0YXR1c1RleHQpOmYoT2JbaC5zdGF0dXNdfHxoLnN0YXR1cyxoLnN0YXR1c1RleHQsXCJ0ZXh0XCIhPT0oaC5yZXNwb25zZVR5cGV8fFwidGV4dFwiKXx8XCJzdHJpbmdcIiE9dHlwZW9mIGgucmVzcG9uc2VUZXh0P3tiaW5hcnk6aC5yZXNwb25zZX06e3RleHQ6aC5yZXNwb25zZVRleHR9LGguZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKX19LGgub25sb2FkPWMoKSxkPWgub25lcnJvcj1jKFwiZXJyb3JcIiksdm9pZCAwIT09aC5vbmFib3J0P2gub25hYm9ydD1kOmgub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7ND09PWgucmVhZHlTdGF0ZSYmYS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YyYmZCgpfSl9LGM9YyhcImFib3J0XCIpO3RyeXtoLnNlbmQoYi5oYXNDb250ZW50JiZiLmRhdGF8fG51bGwpfWNhdGNoKGkpe2lmKGMpdGhyb3cgaX19LGFib3J0OmZ1bmN0aW9uKCl7YyYmYygpfX19KSxyLmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24oYSl7YS5jcm9zc0RvbWFpbiYmKGEuY29udGVudHMuc2NyaXB0PSExKX0pLHIuYWpheFNldHVwKHthY2NlcHRzOntzY3JpcHQ6XCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwifSxjb250ZW50czp7c2NyaXB0Oi9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL30sY29udmVydGVyczp7XCJ0ZXh0IHNjcmlwdFwiOmZ1bmN0aW9uKGEpe3JldHVybiByLmdsb2JhbEV2YWwoYSksYX19fSksci5hamF4UHJlZmlsdGVyKFwic2NyaXB0XCIsZnVuY3Rpb24oYSl7dm9pZCAwPT09YS5jYWNoZSYmKGEuY2FjaGU9ITEpLGEuY3Jvc3NEb21haW4mJihhLnR5cGU9XCJHRVRcIil9KSxyLmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIixmdW5jdGlvbihhKXtpZihhLmNyb3NzRG9tYWluKXt2YXIgYixjO3JldHVybntzZW5kOmZ1bmN0aW9uKGUsZil7Yj1yKFwiPHNjcmlwdD5cIikucHJvcCh7Y2hhcnNldDphLnNjcmlwdENoYXJzZXQsc3JjOmEudXJsfSkub24oXCJsb2FkIGVycm9yXCIsYz1mdW5jdGlvbihhKXtiLnJlbW92ZSgpLGM9bnVsbCxhJiZmKFwiZXJyb3JcIj09PWEudHlwZT80MDQ6MjAwLGEudHlwZSl9KSxkLmhlYWQuYXBwZW5kQ2hpbGQoYlswXSl9LGFib3J0OmZ1bmN0aW9uKCl7YyYmYygpfX19fSk7dmFyIFFiPVtdLFJiPS8oPSlcXD8oPz0mfCQpfFxcP1xcPy87ci5hamF4U2V0dXAoe2pzb25wOlwiY2FsbGJhY2tcIixqc29ucENhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGE9UWIucG9wKCl8fHIuZXhwYW5kbytcIl9cIityYisrO3JldHVybiB0aGlzW2FdPSEwLGF9fSksci5hamF4UHJlZmlsdGVyKFwianNvbiBqc29ucFwiLGZ1bmN0aW9uKGIsYyxkKXt2YXIgZSxmLGcsaD1iLmpzb25wIT09ITEmJihSYi50ZXN0KGIudXJsKT9cInVybFwiOlwic3RyaW5nXCI9PXR5cGVvZiBiLmRhdGEmJjA9PT0oYi5jb250ZW50VHlwZXx8XCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSYmUmIudGVzdChiLmRhdGEpJiZcImRhdGFcIik7aWYoaHx8XCJqc29ucFwiPT09Yi5kYXRhVHlwZXNbMF0pcmV0dXJuIGU9Yi5qc29ucENhbGxiYWNrPXIuaXNGdW5jdGlvbihiLmpzb25wQ2FsbGJhY2spP2IuanNvbnBDYWxsYmFjaygpOmIuanNvbnBDYWxsYmFjayxoP2JbaF09YltoXS5yZXBsYWNlKFJiLFwiJDFcIitlKTpiLmpzb25wIT09ITEmJihiLnVybCs9KHNiLnRlc3QoYi51cmwpP1wiJlwiOlwiP1wiKStiLmpzb25wK1wiPVwiK2UpLGIuY29udmVydGVyc1tcInNjcmlwdCBqc29uXCJdPWZ1bmN0aW9uKCl7cmV0dXJuIGd8fHIuZXJyb3IoZStcIiB3YXMgbm90IGNhbGxlZFwiKSxnWzBdfSxiLmRhdGFUeXBlc1swXT1cImpzb25cIixmPWFbZV0sYVtlXT1mdW5jdGlvbigpe2c9YXJndW1lbnRzfSxkLmFsd2F5cyhmdW5jdGlvbigpe3ZvaWQgMD09PWY/cihhKS5yZW1vdmVQcm9wKGUpOmFbZV09ZixiW2VdJiYoYi5qc29ucENhbGxiYWNrPWMuanNvbnBDYWxsYmFjayxRYi5wdXNoKGUpKSxnJiZyLmlzRnVuY3Rpb24oZikmJmYoZ1swXSksZz1mPXZvaWQgMH0pLFwic2NyaXB0XCJ9KSxvLmNyZWF0ZUhUTUxEb2N1bWVudD1mdW5jdGlvbigpe3ZhciBhPWQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpLmJvZHk7cmV0dXJuIGEuaW5uZXJIVE1MPVwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIiwyPT09YS5jaGlsZE5vZGVzLmxlbmd0aH0oKSxyLnBhcnNlSFRNTD1mdW5jdGlvbihhLGIsYyl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGEpcmV0dXJuW107XCJib29sZWFuXCI9PXR5cGVvZiBiJiYoYz1iLGI9ITEpO3ZhciBlLGYsZztyZXR1cm4gYnx8KG8uY3JlYXRlSFRNTERvY3VtZW50PyhiPWQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpLGU9Yi5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKSxlLmhyZWY9ZC5sb2NhdGlvbi5ocmVmLGIuaGVhZC5hcHBlbmRDaGlsZChlKSk6Yj1kKSxmPUIuZXhlYyhhKSxnPSFjJiZbXSxmP1tiLmNyZWF0ZUVsZW1lbnQoZlsxXSldOihmPXBhKFthXSxiLGcpLGcmJmcubGVuZ3RoJiZyKGcpLnJlbW92ZSgpLHIubWVyZ2UoW10sZi5jaGlsZE5vZGVzKSl9LHIuZm4ubG9hZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGc9dGhpcyxoPWEuaW5kZXhPZihcIiBcIik7cmV0dXJuIGg+LTEmJihkPW1iKGEuc2xpY2UoaCkpLGE9YS5zbGljZSgwLGgpKSxyLmlzRnVuY3Rpb24oYik/KGM9YixiPXZvaWQgMCk6YiYmXCJvYmplY3RcIj09dHlwZW9mIGImJihlPVwiUE9TVFwiKSxnLmxlbmd0aD4wJiZyLmFqYXgoe3VybDphLHR5cGU6ZXx8XCJHRVRcIixkYXRhVHlwZTpcImh0bWxcIixkYXRhOmJ9KS5kb25lKGZ1bmN0aW9uKGEpe2Y9YXJndW1lbnRzLGcuaHRtbChkP3IoXCI8ZGl2PlwiKS5hcHBlbmQoci5wYXJzZUhUTUwoYSkpLmZpbmQoZCk6YSl9KS5hbHdheXMoYyYmZnVuY3Rpb24oYSxiKXtnLmVhY2goZnVuY3Rpb24oKXtjLmFwcGx5KHRoaXMsZnx8W2EucmVzcG9uc2VUZXh0LGIsYV0pfSl9KSx0aGlzfSxyLmVhY2goW1wiYWpheFN0YXJ0XCIsXCJhamF4U3RvcFwiLFwiYWpheENvbXBsZXRlXCIsXCJhamF4RXJyb3JcIixcImFqYXhTdWNjZXNzXCIsXCJhamF4U2VuZFwiXSxmdW5jdGlvbihhLGIpe3IuZm5bYl09ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMub24oYixhKX19KSxyLmV4cHIucHNldWRvcy5hbmltYXRlZD1mdW5jdGlvbihhKXtyZXR1cm4gci5ncmVwKHIudGltZXJzLGZ1bmN0aW9uKGIpe3JldHVybiBhPT09Yi5lbGVtfSkubGVuZ3RofTtmdW5jdGlvbiBTYihhKXtyZXR1cm4gci5pc1dpbmRvdyhhKT9hOjk9PT1hLm5vZGVUeXBlJiZhLmRlZmF1bHRWaWV3fXIub2Zmc2V0PXtzZXRPZmZzZXQ6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGgsaSxqLGs9ci5jc3MoYSxcInBvc2l0aW9uXCIpLGw9cihhKSxtPXt9O1wic3RhdGljXCI9PT1rJiYoYS5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIpLGg9bC5vZmZzZXQoKSxmPXIuY3NzKGEsXCJ0b3BcIiksaT1yLmNzcyhhLFwibGVmdFwiKSxqPShcImFic29sdXRlXCI9PT1rfHxcImZpeGVkXCI9PT1rKSYmKGYraSkuaW5kZXhPZihcImF1dG9cIik+LTEsaj8oZD1sLnBvc2l0aW9uKCksZz1kLnRvcCxlPWQubGVmdCk6KGc9cGFyc2VGbG9hdChmKXx8MCxlPXBhcnNlRmxvYXQoaSl8fDApLHIuaXNGdW5jdGlvbihiKSYmKGI9Yi5jYWxsKGEsYyxyLmV4dGVuZCh7fSxoKSkpLG51bGwhPWIudG9wJiYobS50b3A9Yi50b3AtaC50b3ArZyksbnVsbCE9Yi5sZWZ0JiYobS5sZWZ0PWIubGVmdC1oLmxlZnQrZSksXCJ1c2luZ1wiaW4gYj9iLnVzaW5nLmNhbGwoYSxtKTpsLmNzcyhtKX19LHIuZm4uZXh0ZW5kKHtvZmZzZXQ6ZnVuY3Rpb24oYSl7aWYoYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdm9pZCAwPT09YT90aGlzOnRoaXMuZWFjaChmdW5jdGlvbihiKXtyLm9mZnNldC5zZXRPZmZzZXQodGhpcyxhLGIpfSk7dmFyIGIsYyxkLGUsZj10aGlzWzBdO2lmKGYpcmV0dXJuIGYuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGg/KGQ9Zi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxkLndpZHRofHxkLmhlaWdodD8oZT1mLm93bmVyRG9jdW1lbnQsYz1TYihlKSxiPWUuZG9jdW1lbnRFbGVtZW50LHt0b3A6ZC50b3ArYy5wYWdlWU9mZnNldC1iLmNsaWVudFRvcCxsZWZ0OmQubGVmdCtjLnBhZ2VYT2Zmc2V0LWIuY2xpZW50TGVmdH0pOmQpOnt0b3A6MCxsZWZ0OjB9fSxwb3NpdGlvbjpmdW5jdGlvbigpe2lmKHRoaXNbMF0pe3ZhciBhLGIsYz10aGlzWzBdLGQ9e3RvcDowLGxlZnQ6MH07cmV0dXJuXCJmaXhlZFwiPT09ci5jc3MoYyxcInBvc2l0aW9uXCIpP2I9Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTooYT10aGlzLm9mZnNldFBhcmVudCgpLGI9dGhpcy5vZmZzZXQoKSxyLm5vZGVOYW1lKGFbMF0sXCJodG1sXCIpfHwoZD1hLm9mZnNldCgpKSxkPXt0b3A6ZC50b3Arci5jc3MoYVswXSxcImJvcmRlclRvcFdpZHRoXCIsITApLGxlZnQ6ZC5sZWZ0K3IuY3NzKGFbMF0sXCJib3JkZXJMZWZ0V2lkdGhcIiwhMCl9KSx7dG9wOmIudG9wLWQudG9wLXIuY3NzKGMsXCJtYXJnaW5Ub3BcIiwhMCksbGVmdDpiLmxlZnQtZC5sZWZ0LXIuY3NzKGMsXCJtYXJnaW5MZWZ0XCIsITApfX19LG9mZnNldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBhPXRoaXMub2Zmc2V0UGFyZW50O3doaWxlKGEmJlwic3RhdGljXCI9PT1yLmNzcyhhLFwicG9zaXRpb25cIikpYT1hLm9mZnNldFBhcmVudDtyZXR1cm4gYXx8cWF9KX19KSxyLmVhY2goe3Njcm9sbExlZnQ6XCJwYWdlWE9mZnNldFwiLHNjcm9sbFRvcDpcInBhZ2VZT2Zmc2V0XCJ9LGZ1bmN0aW9uKGEsYil7dmFyIGM9XCJwYWdlWU9mZnNldFwiPT09YjtyLmZuW2FdPWZ1bmN0aW9uKGQpe3JldHVybiBTKHRoaXMsZnVuY3Rpb24oYSxkLGUpe3ZhciBmPVNiKGEpO3JldHVybiB2b2lkIDA9PT1lP2Y/ZltiXTphW2RdOnZvaWQoZj9mLnNjcm9sbFRvKGM/Zi5wYWdlWE9mZnNldDplLGM/ZTpmLnBhZ2VZT2Zmc2V0KTphW2RdPWUpfSxhLGQsYXJndW1lbnRzLmxlbmd0aCl9fSksci5lYWNoKFtcInRvcFwiLFwibGVmdFwiXSxmdW5jdGlvbihhLGIpe3IuY3NzSG9va3NbYl09T2Eoby5waXhlbFBvc2l0aW9uLGZ1bmN0aW9uKGEsYyl7aWYoYylyZXR1cm4gYz1OYShhLGIpLExhLnRlc3QoYyk/cihhKS5wb3NpdGlvbigpW2JdK1wicHhcIjpjfSl9KSxyLmVhY2goe0hlaWdodDpcImhlaWdodFwiLFdpZHRoOlwid2lkdGhcIn0sZnVuY3Rpb24oYSxiKXtyLmVhY2goe3BhZGRpbmc6XCJpbm5lclwiK2EsY29udGVudDpiLFwiXCI6XCJvdXRlclwiK2F9LGZ1bmN0aW9uKGMsZCl7ci5mbltkXT1mdW5jdGlvbihlLGYpe3ZhciBnPWFyZ3VtZW50cy5sZW5ndGgmJihjfHxcImJvb2xlYW5cIiE9dHlwZW9mIGUpLGg9Y3x8KGU9PT0hMHx8Zj09PSEwP1wibWFyZ2luXCI6XCJib3JkZXJcIik7cmV0dXJuIFModGhpcyxmdW5jdGlvbihiLGMsZSl7dmFyIGY7cmV0dXJuIHIuaXNXaW5kb3coYik/MD09PWQuaW5kZXhPZihcIm91dGVyXCIpP2JbXCJpbm5lclwiK2FdOmIuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIrYV06OT09PWIubm9kZVR5cGU/KGY9Yi5kb2N1bWVudEVsZW1lbnQsTWF0aC5tYXgoYi5ib2R5W1wic2Nyb2xsXCIrYV0sZltcInNjcm9sbFwiK2FdLGIuYm9keVtcIm9mZnNldFwiK2FdLGZbXCJvZmZzZXRcIithXSxmW1wiY2xpZW50XCIrYV0pKTp2b2lkIDA9PT1lP3IuY3NzKGIsYyxoKTpyLnN0eWxlKGIsYyxlLGgpfSxiLGc/ZTp2b2lkIDAsZyl9fSl9KSxyLmZuLmV4dGVuZCh7YmluZDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMub24oYSxudWxsLGIsYyl9LHVuYmluZDpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLm9mZihhLG51bGwsYil9LGRlbGVnYXRlOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB0aGlzLm9uKGIsYSxjLGQpfSx1bmRlbGVnYXRlOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/dGhpcy5vZmYoYSxcIioqXCIpOnRoaXMub2ZmKGIsYXx8XCIqKlwiLGMpfX0pLHIucGFyc2VKU09OPUpTT04ucGFyc2UsXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoXCJqcXVlcnlcIixbXSxmdW5jdGlvbigpe3JldHVybiByfSk7dmFyIFRiPWEualF1ZXJ5LFViPWEuJDtyZXR1cm4gci5ub0NvbmZsaWN0PWZ1bmN0aW9uKGIpe3JldHVybiBhLiQ9PT1yJiYoYS4kPVViKSxiJiZhLmpRdWVyeT09PXImJihhLmpRdWVyeT1UYikscn0sYnx8KGEualF1ZXJ5PWEuJD1yKSxyfSk7XG4iLCIoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBmdW5jdGlvbiBpbml0aWFsaXplUGFnZSgpe1xyXG4gICAgc2V0Q2Fyb3VzZWwoKTtcclxuICAgIGdldFByb2R1Y3QoKTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBnZXRQcm9kdWN0KCl7XHJcbiAgICAgICQuYWpheCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wcm9kdWN0Lmpzb24nKS50aGVuKGFsZXJ0KCdoZXknKSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXRDYXJvdXNlbCgpe1xyXG4gICAgbmV3IGNoLkNhcm91c2VsKGNoKCcucmVsYXRlZC1wcm9kdWN0cy1zbGlkZXInKVswXSwgeyBwYWdpbmF0aW9uOiB0cnVlIH0pO1xyXG4gIH1cclxuXHJcbiAgaW5pdGlhbGl6ZVBhZ2UoKTtcclxuICBcclxufSkoKTtcclxuIl19
